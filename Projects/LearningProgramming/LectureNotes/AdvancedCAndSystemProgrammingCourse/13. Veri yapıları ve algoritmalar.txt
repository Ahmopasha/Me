> Veri Yapıları ve Algoritmalar: Kursumuzun bu bölümünde dikkatimizi veri yapıları ve algoritmalar konusuna yönelteceğiz. Şimdi sırasıyla incelemelerde bulunalım:
    >> Bir sistem programcınının temel veri yapıları ve algoritmalar konusunda belli düzeyde bilgi sahibi olması gerekmektedir. Aralarında fiziksel ya da mantıksal ilişki olan bir grup nesnenin oluşturduğu topluluğa "veri yapısı (data structure)" denilmektedir.
    Veri yapısı denildiğinde tekil bir nesne değil belli bir düzen içerisinde bulunan bir grup nesne anlaşılmaktadır. Çok temel veri yapıları programlama dillerinin sentaksı tarafından built-in biçimde desteklenmektedir. Örneğin C'de "diziler (arrrays)",
    "yapılar (structures)", "birlikler (unions)" dilin sentaksı tarafından desteklenen built-in veri yapılarıdır. Ancak C tarafından doğrudan desteklenen bu veri yapıları dış dünyadaki olayları modellemekte yetersiz kalmaktadır. Programcının dilin sentaksı ile
    doğrudan desteklenen veri yapılarını kullanarak diğer veri yapılarını oluşturması gerekebilmektedir. Nesne Yönelimli Programlama Dillerinde genellikle o dillerin kütüphanelerinde pek çok veri yapısı sınıflar biçiminde zaten hazır olarak bulunudurlmaktadır.
    Örneğin C++'ın standart kütüphanesinde, C# (.NET) ve Java'nın temel kütüphanelerinde "kuyruk sistsmleri (queues)" gibi, "bağlı listeler (linked lists)" gibi "hash tabloları (hash tables)" gibi veri yapıları hazır bir biçimde bulunmaktadır. Halbuki C'de bu
    veri yapıları C'nin standart kütüphanesi tarafından desteklenmemektedir. Her ne kadar pek çok nesne yönelimli programlama dilinin kütüphanelerinde bu bölümde ele alacağımız veri yapıları zaten hazır bir biçimde bulunuyorsa da sistem programcısının bu veri
    yapılarını yazabilecek düzeyde tanıması önemli olmaktadır.
    
    >> Bir problemi kesin çözüme götüren adımlar topluluğuna "algoritma (algorithm)" denilmektedir. Algoritma sözcüğü Fars bilim adamı Ebû Ca'fer Muhammed bin Mûsâ el-Hârizmî'nin isminden hareketle (bazı yanlış anlaşılmalarla) uydurulmuş bir sözcüktür.
    Algoritmaların problemi kesin çözüme götürmesi gerekir. Eğer söz konusu adımlar problemi kesin çözüme götürmüyor ancak iyi bir çözüm sunuyorsa buna "algoritma" yerine "sezgisel yöntemler (heuristic)" denilmektedir. Pekiyi algoritmalar nasıl ifade edilmektedir?
    Örneğin "bir dizinin en büyük elemanını bulan algoritma" teknik olarak nasıl açıklanabilir? Algoritmaları cümlelerle sözel biçimde açıklamak hala kullanılan temel yöntemlerden biridir. Örneğin "dizini ilk elemanını en büyük kabul edilip bir değişkende saklanır.
    Sonra diğer tüm elemanlar bir döngü içerisinde bu elemanla karşılaştırılır. Daha büyük eleman görülürse bu değişkene yerleştirilir" gibi. Ancak sözel açıklama teknik anlamda belirsiz olabilmektedir. Sözükler yerine sembollerin kullanılması daha kesin
    belirlemelerin yapılmasına olanak sağlamaktadır. İşte algoritmalar "pseude kodlar" yoluyla, "akış diyagramları" yoluyla ya da "belli bir programlama dilinde yazılmış kodlar" yoluyla da ifade edilebilmektedir. Eskiden "pseudo kodlar" ve akış diyagramları daha
    çok kullanılırdı. Artık algoritmanın ifadesi için mevcut programlama dillerinden biri seçilmektedir. Tabii her zaman sözel açıklama da sürece eşlik etmektedir. Pekiyi algoritmaları ifade etmek için hangi programlama dili tercih edilmelidir? Çok yüksek seviyeli
    diller bu iş için uygun değildir. Dil ne kadar alçak seviyeli olursa algoritmadaki inceliği o kadar iyi yansıtabilmektedir. Bu bakımdan C Programalama Dili tercihler arasında ön plandadır. Ancak son 20 yıldır algoritmaların ifade edilmesinde Java gibi, C# gibi
    nesne yönelimli diller de yoğun olarak kullanılmaktadır. Python kanımızca algoritmaları ifade etmek için fazlaca yüksek seviyeli bir dildir. Ancak Python üzeirnden de algoritmaları anlatan kitaplar ve dokümanlar bulunmaktadır. Gerçekten de popüler algoritma
    kitaplarına bakıldığında "Algorithms in C" gibi, "Algorithms in Java" gibi, anlatımın mevcut bir dil kullanılarak yapıldığı görülmektedir. Özete günümüzde algoritmalar hem sözel olarak hem de bir programlama dilinde yazılmış kodlar biçiminde ifade edilmektedir.
    Algoritmalar konusunda en bilindik kişi Donald Knuth isimli araştırmacıdır. Knuth'un ansiklopedik nitelikte üç ciltlik klasikleşmiş "The Art of Compuer Programming" isimli kitabı vardır. Daha sonra Knuth bu seriye birkaç ince fasikül de eklemiştir. Knuth bu
    önemli başvuru kitabında algoritmaları ifade etmek için kendisinin uydurduğu MIX isimli bir sembolik makine dili kullanmıştır. Daha sonra bu MIX dilinin RMIX isimli RISC tabanlı biçimini de geliştirmiştir. Bir problemi çözebilen pek çok alternatif algoritmalar
    söz konusu olabilmektedir. Bunların hangisinin daha iyi olduğunun belirlenmesi gerekir. Tabii bunun için bir "iyilik ölçütü" tespit edilmelidir. Algoritmaları kıyaslamak için ölçüt ne olmalıdır? Kıyaslama için iki önemli ölçüt "hız" ve "kaynak kullanımıdır".
    Ancak baskın ve default ölçüt hızdır. Yani genellikle hangi alternatif algoritma daha hızlı sonuç veriyorsa o algoritma tercih edilmektedir. Tabii bazen kısıtlı kaynakların söz konusu olduğu durumlarda programcı hız yerine kaynak kullanımı (tipik olarak bellek
    kullanımı)" ölçütünü de ön plana alabilir. İki algoritmanın hızlarını kıyaslamak kolay bir işlem değildir. Çünkü algoritmada koşula dayalı işlemler yapılyor olabilr. Bu koşulların sağlanması ya da sağlanmaması girdilere bağlı olabilir. Algoritmaların önemli bir
    bölümü dizi gibi veri yapıları üzerinde işlemler yapmaktadır. Bu durumda örneğin dizinin dağılımı hız üzerinde etkili olabilmektedir. Algoritmaların hızlarını kıyaslamak için "simülasyon yöntemi" kullanılabilir. Bu yöntemde alternatif algoritmaların kodları
    yazılır. Bu algoritmalar rastgele girdilerle çok fazla kez çalıştırılır, bir ortalama zaman hesaplanır. Simülasyon yöntemi bazen başvurulan yardımcı yöntemlerden biridir. Ancak simülasyon yöntemini uygulamak oldukça zordur. Her algoritmayı simüle edecek kodun
    yazılması ve bunun çok kez çalıştırılması zor bir süreçtir. Bunun yerine tamamen cebrik yöntemlerin kullanılması daha uygundur. Algoritmaların cebrik yöntemlerle hızlarının ve kaynak kullanımlarının analizine ilişkin sürece "algoritma analizi (analysis of
    algorithms)" denilmektedir. Pekiyi algoritma analizi nasıl yapılmaktadır? Bunun temel yolu algoritmanın çözümü için gereken işlem sayısının bulunmasıdır. Tabii bu işlem sayısı girdi büyüklüğüne bağlı olarak parametrik bir biçimde hesaplanacaktır. Ancak yukarıda
    da belirttiğimiz gibi algortimadaki işlemlerin sayısı girdilere bağlı olarak da değişebilmektedir. (Tabii aslında her işlem aynı sürede yapılmayabilir. Örneğin pek çok işlemcide çarpma işlemi toplama işlemine göre çok daha yavaş yapılmaktadır.) Örneğin bir dizi
    içerisinde var olduğunu bildiğimiz belli bir değerin kaç işlemde bulunacağını hesaplamak isteyelim. 
        * Örnek 1, Algoritma şöyle olsun:

            int a[N];

            for (int i = 0; i < N; ++i)
                if (a[i] == VAL)
                    break;		/* bulundu */

        Burada işlem sayısına şu işlemler dahildir:

            int i = 0
            i < N
            ++i
            a[i] == VAL

        Ancak burada aranacak olan VAL değerinin dizinin kaçıncı elemanında olduğu diziye bağlıdır. Algoritmaya bağlı değildir. İşte bu tür durumlarda algoritma analiz edilirken tipik olarak iki durum için hesaplama yapılır:

            -> En kötü durum analizi (worst case analyisis)
            -> Ortalama durum analizi (average case analysis)

        En iyi durum analizi de söz konusu olabilirse de pratikte çok iyimser bir yaklaşım olduğu için uygulanmamaktadır. Yukarıdaki sıralı aramamın en kötü durum analizini yapmaya çalışalım. En köü durumda eleman dizinin son elemanı olarak bulunur. Böylece
        en kötü durumdaki işlem sayısı 1 + 3N kadardır. Bu algoritmadaki ortalama işlem sayısı aranacak değerin 1'inci, 2'inci, 3'üncü, ... N'inci indekslerde bulunması durumunun toplamının N'e bölünmesiyle elde edilebilir. Bunu matematiksel olarak şöyle yazabiliriz:

            1 + (3 * (1 + 2 + 3 + ... + N) / N)

        1'den N'e kadar sayıların toplamı N * (N + 1) olduğuna göre buradan şu değer elde edilir:

            1 + (3 * (N + 1) / 2)

        Tabii bu tür hesaplamalarda bizim sabit olmayan kısmın artışına bakmamız doğru olur. Buradaki 1 toplamı, 3 çarpımı ve 2'ye bölüm sabittir. Bu tür durumlarda bizim için önemli olan bu N değerinin artması ile algoritmanın davranışıdır. Algoritmalar dünyasında girdi
        büyüklüğüne (örneğin dizinin uzunluğuna) bağlı olarak algoritmada yapılan işlemlerin sayısını elde etmekte kullanılan ifadelere "algoritmanın karmaşıklığı (complexity of algorithms)" denilmektedir. Yani algoritmanın karmaşıklığı girdi büyüklüüne bağlı olarak
        algortimanın hızının betimlenmesi için kullanılan ifadelere denilmektedir. Örneğin yukarıdaki sıralaı aramanın karmaşıklığı 1 + (3 * (N + 1) / 2) olarak belirtilebilir.
    
    Bir algoritmanın en kötü durum ve özellikle de ortalama durumdaki karmaşıklığının (yani girdiye dayalı olarak işlem sayısının) hesaplanması oldukça zor olabilmektedir. Bu nedenle genellikle karmaşıklık için kesin bir değer bulma yerine karmaşıklıkları kategorilere
    ayırıp karşılaştırma yoluna gidilmektedir. Bu tür kategorik karşılaştırmalar her ne kadar algoritmanın aldığı zaman konusunda ince bir değer vermese de onun karakteri hakkında kısa sürece içerisinde önemli bir bilgi vermektedir. Algoritmaları kategorik olarak
    sınıflandırmak için "asimtotik notasyonlar" denilen özel notasyonlar kullanılmaktadır. Asimtotik notasyonlar aslında matematikte programlamanın dışında ele alınıp kullanılmış olan tekniklerdir. Başka bir deyişle asimtoto, k notasyonlar bir fonksiyonun büyüme
    karakteristiği ile ilgili çalışmalardan kaynaklanmaktadır. Ancak bu konu algoritma analizinde önemli bir uygulama alanı bulmuştur. Algoritma karmaşıklığında kullanılan asimtotik notasyonlar şunlardır:

        -> Big O Notasyonu
        ->Büyük Teta Notasyonu
        -> Büyük Omega Notasyonu
        -> Küçük o Notasyonu

	Ancak Big O notasyonu en çok kullanılan notasyondur. Bu notasyonlar aslında bir grup fonksiyonu karakterize etmek için düşünülmüştür. 
        >>> Big O Notasyonu : Aşağıdaki gibi belirtilmektedir:

            f(x) = O(g(x))

        Burada f(x) ve g(x) iki fonksiyondur. Notasyondaki eşittir karakteri eleştirilmektedir. Buradaki eşittir karakteri aslında matematikteki eşitliği anlatmamaktadır. Burada aslında "f(x) fonksiyonunun Big O notasyonuna göre g(x) kategorisinden olduğu"
        anlatılmaktadır. Örneğin:

            3x = O(X^2)
            5X^2 = O(X^2)

        Burada 3x ve 5X^2 fonksiyonları big O notasyonuna göre X^2 kategorisindendir. Big O notasyonunun matematiksel sembollerle biçimsel (formal) açıklaması biraz ayrıntılıdır. Bu açıklamalar için Ebook klasöründeki "Algorithms and Complexity" kitabının Birinci bölümüne
        başvurabilirsiniz. Biz burada önce biçimsel olmayan açıklama yapacağız. Sonra biçimsel açıklama üzerinde duracağız. Big O notasyonunda kategori olarak O(gx(x)) ifadesiyle belirtilmiş olan fonksiyon ile üstel bakımdan aynı olan ve bundan küçük olan tüm 
        fonksiyonlar kstedilmektedir. Örneğin O(x^2) kategorisi üssü en fazla iki olan tüm fonksiyonları ve üssü bundan küçük olan tüm fonksiyonları belirtmektedir. Örneğin aşağıdaki fonksiyonların hepsi O(x^2) kategorisine sahiptir, dolayısıyla f(x) = O(x^2) biçiminde
        ifade edilebilir:

            f(x) = 100
            f(x) = 3x
            f(x) = 3x^2
            f(x) = 100x^2 + 80x +5
            f(x) = 2X^2 - 5x - 8

        Burada x^2'nin katsayısının bir önemi olmadığına dikkat ediniz. Başka bir deyişle O(x^2) kategorisi k x^2 ve x^1 ve sabitin tüm toplamlarına ilişkin fonksiyonları belirtmektedir. Benzer biçimde O(x) kategorisine ilişkin bazı fonksiyonlar şunlardır:

            f(x) = 3x
            f(x) 0 100x - 5
            f(x) = x - 1
            f(x) = 10

        Burada da x'in katsayısının bir önemi yoktur. Big O notasyonunda O(1) karmaşıklığına sahip (Burada 1 yerine başka bir sayıda kullanılabilir. Ancak en düşük sayı 1 olduğu için 1 tercih edilmektedir. Yani O(5) ile O(1) aynı anlamdadır.) fonksiyonlardan bazıları
        şunlardır:

            f(x) = 123
            f(x) = 1234567
            f(x) = 1

        Big O notasyonunda g(x) fonksiyonundaki çarpanın önemli olmadığına dikkat ediniz. Örneğin O(x^2) kategorisi ile O(3x^2) kategorisi arasında hiçbir farklılık yoktur. Benzer biçimde bunlarla O(5X^2 + 2) kategorisi arasında da bir farklılık yoktur. Bu nedenle
        kategoriler belirtilirken gereksiz biçimde g(x) fonksiyonunda çarpan ve toplam değerler belirtilmez. Big O natsyonunun biçimsel açıklaması şöylşe yapılabilir: 

            f(x) = O(g(x)) (x → ∞) if ∃ C, x0 öyle ki |f(x)| < Cg(x) tüm x > x0 değerleri için

        Burada şu belirtilmektedir: f(x) = O(g(x)) olabilmesi için |f(x)| < Cg(x) eşitliğini sağlayabilecek bir C değerinin bulunması gerekir. Örneğin 3x^2 + 5x + 2 = O(x^2) yazılabilir. Çünkü burada örneğin C = 5 gibi bir C değeri bulunabilir. Böylece 5X^2 belli bir x0
        değerinde sonra her zaman 3X^2 + 5x + 2 değerinden büyük kalacaktır. Algoritmaları kıyaslamak için iyiden kötüye doğru çeşitli Big O kategorileri kullanılmaktadır. Bu kategoriler şunlardır (Burada x yerine N gösterimini kullanacağız):

            O(1)									Sabit Karmaşıklık
            O(log log N)							Çifte Logaritmik Karmaşıklık
            O(log N)								Logaritmik Karmaşıklık
            O((log N)^c) c > 1 olmak üzere			Polylogaritmik Karmaşıklık
            O(N^c) c < 0 < 1 olmak üzere			Oransal Kuvvet Karmaşıklığı
            O(N)									Doğrusal Karmaşıklık
            O(N log N)								N Log N karmaşıklığı
            O(N^2)									Karesel Karmaşıklık
            O(N^3)									Küpsel Karmaşıklık
            O(N^c)									Polinomsal Karmaşıklık
            O(c^N)	c > 1 olmak üzere				Üstel Karmaşıklık
            O(N!)									Faktöriyel Karmaşıklığı

        Algoritmaları Big O notasyonuna göre kategorik olarak karşılaştırmak kolaydır. Alternatif algoritmaların kategorileri belirlenir. Hangi kategorinin diğerinden daha iyi olup olmadığına bakılır. Aynı kategoriye giren algoritmalar arasında bir farklılık söz konusu
        olsa da bu farklılık kategorik bir farklılık değildir. Biz aynı Big O kategorisindeki algoritmaları aynı karakterde kabul edebiliriz. Pekiyi bir algoritmanın yukarıda belirttiğimiz Big O kategorisi nasıl tespit edilir? Algoritmanın girdisinin N olduğunu varsayalım. 
        Örneğin N bir dizinin uzunluğu olabilir. Bazı kategorilerin tespiti şöyle yapılabilir:

            - Tekil ifadeler içeren ve N değrine bağlı olmayan sabit uzunluklu döngüler içeren algoritmalar O(1) karmaşıklıktadır. Örneğin üçgenin alanın hesaplanması, dikdörtgenin çevresinin hesaplanması, bir yılın artık yıl olup olmadığının tespit edilmesi gibi
            algoritmalar O(1) yani sabit karmaşıklıktadır. Sabit karmaşıklık en iyi karmaşıklık kategorisidir. Örneğin bir problemde "bunun için sabit karmaşıklığa sahip bir algoritma kullanın" ifadesi "N değerine dayalı döngü kullanmadan tekil ifadelerle çözümü bulun"
            anlamına gelmektedir. Örneğin, dizinin bir elemanına erişilmesi sabit karmaşıklıklı bir işlemdir. 

            - Bir algoritmada bir döngü varsa ancak döngü N'in logaritması kadar dönüyorsa (tabii algoritma tekiş ilemler de içerebilir) bu algoritma O(log N) karmaşıklıktadır. Örneğin "ikili arama (binary search)" algoritmasında N değeri arttıkça döngü log2 N kadar
            artmaktadır. 

            - Bir algoritma N'e dayalı tekil döngüler içeriyorsa ve tekil işlemler içeriyorsa bu algoritma O(N) karmaşıklıktadır. Bu tür karmaşıklıklara sözel olarak "doğrusal karmaşıklık" da denilmektedir. Örneğin "dizinin en büyük elemanının bulunması", "dizinin
            aritmetik ortalamasının bulunması", "dizide bir elemanın bulunması" gibi algoritmalar O(N) karmaşıklıktadır. Sıralı bir dizi bulunyor olsun. Biz de bu sıralı dizide belli bir elemanı bulmak isteyelim. İkili arama (binary search) O(log N) karmaşıklıkta,
            sıralı arama O(N) karmaşıklıktadır. O halde ikili arama sıralı aramdan daha iyidir.

            - O(N log N) karmaşıklıkta iç içe iki döngü bulunabilir. Dıştaki döngü N'e dayalı dönerken içteki dönü N'nin logaritmasına dayalı dönmektedir. Tabii algoritma başka N'e dayalı döngüler ve tekil işlemler içerebilir. Uick Sort gibi, Heap sort gibi kaliteli
            sort algoritmaları O(N log N) karmaşıklıktadır. 

            - N'e dayalı iç içe iki döngü varsa (tabii ayrık N'e dayalı döngüler ve tekil işlemler de olabilir) bu tür algoritmalar O(N^2) karmaşıklıktadır. Örneğin "boubble sort", "selection sort" gibi algoritmalar O(N^2) karmaşıklıktadır. Bu karmaşıklığa "karesel
            karmaşıklık" da denilmektedir. Bu durumda örneğin "selection sort" algoritması "quick sort" algoritmasından daha kötüdür.

            - N'e dayalı iç içe üç döngü varsa (tabii N'e dayalı iç içe döngüler, tekil döngüler ve tekil işlemler de olabilir) bu tür algoritmalar O(N^3) yani küpsel karmaşıklığa sahiptir. Örneğin tipik matris çarpımı küpsel karmaşıklığa sahiptir. Ancak karesel
            kamaşıklığa sahip çözümleri de vardır. 

            - İç içe k tane döngü içerebilen tüm algoritmalara genel olarak "polinomsal karmaşıklıktaki (polynomial complexity) algortimalar" denilmektedir. 

            - Alt küme işlemlerine ilişkin algoritmalar tipik olarak O(c^n) yani üstel karmaşıklıktadır. Bir kümenin tüm alt kğmelerinin sayısının 2^n olduğunu anımsayınız. 

            - Bazı graf ptoblemleri O(N!) yani faktöriyelsel karmaşıklıktadır. Örneğin "gezgin satıcı problemi (traveling salesmen problem)" faktöriyelsel karmaşıklıktadır. Faktöriyelsel karmaşıklık en kötü karmaşıklık kategorisidir. 

        Üstel karmaşıklığa ve faktöriyelsel karmaşıklığa "polinomsal olmayan (nonpolynomial)" karmaşıklar denilmektedir. Polinomsal olmayan karmaşıklık kısaca "NP karmaşıklık" olarak da ifade edilmektedir. NP karmaşıklıktaki problemler bugünkü bilgisayarlarda bile
        binlerce sene zaman alabilecek boyutlara gelebilmektedir. Pek çok NP algoritma için polinomsal karmaşıklığa sahip daha makul algoritmalar aranmaktadır. Ancak bu konuda önemli başarılar elde edilmemiştir. Pekiyi NP karmaşıklıktaki problemler için neler yapılabilir?
        İşte bu alanda "sezgisel yöntemler (heuristic)" denilen yöntemler kullanılmaktadır. Anımsanacağı gibi "sezgisel yöntemler (heuristic)" en iyi çözümü hedeflemeyen ancak tatmin edici bir çözümü makul bir zaman içerisinde bulmayı sağlayan yöntemlerdir. 

    >> C'de "diziler", "yapılar" ve "birlikler" built-in veri yapılarıdır. Yani dilin sentaksı taarafından birnci elde desteklenmektedir. Ancak bu veri yapıları bazı uygulamaları gerçekleştirmek için yetersiz kalmaktadır. İşte bu bölümde C'nin sentaksı tarafından doğrudan 
	desteklenmeyen ancak uygulamalarda sıkça karşılaşılan veri yapılarını inceleyeceğiz. Bu veri yapıları pek çok nesne yönelimli programlama dilinin temel kütüphanelerinde birer sınıf biçiminde bulunmaktadır. Yani eğer C++, Java ve C# fillerle çalışıyorsanız burada
    göreceğimiz veri yapıları zaten o dilelrin temel kütüphanlerinde hazır bir biçimde bulunmaktadır. Ancak ne olursa olsun bu veri yapılarının nasıl çalıştığının ve nasıl gerçekleştirildiğinin sistem programcıları tarafından bilinmesi gerekmektedir. 

    >> Veri yapıları dünyasında bir süredir çok karşılaşılan terimlerden biri de "abstract data type" terimidir. Bu terimi Türkçe'ye "soyut veri türü" biçiminde çevirebiliriz. Abstract data type denildiğinde Belli bir veri yapısını gerçekleştiren data ve fonksiyon grubu
    anlaşılmalıdır. Burada "abstract" sözcüğü "soyutlama" yani "aytrıntıların göz ardı edilerek işlevlere dikkatin yöneltilmesi" anlamına gelmektedir. Abstract data type denildiğinde bir veri yapısı üzerinde işlem yapan API arayüzü anlaşılır. Tipik olarak bu kavran nesne
    yönelimli programlama tekniğinde bir sınıf ve o sınıfın desteklediği arayüz biçiminde oluiturulmaktadır.

Şimdi de sırasıyla bu veri yapılarını ve algoritmalarını kategori bazlı incelemeye koyulalım: 
    >> Dinamik Diziler : En çok kullanılan veri yapılarından biri "dinamk dizi (dynamic array)" denilen veri yapısıdır. Dinamik dizi "gerektiğinde büyütülen" dizi anlamına gelmektedir. Bu veri yapısını kullanan programcı veri yapısına bir eleman eklediğinde ekleme
    fonksiyonu eğer gerekiyorsa tahsis etmiş olduğu diziyi büyütmektedir. Ancak veri yapısını kullanan kişi işin bu kısmıyla uğraşmamaktadır. Bu veri yapısı C++'ın standart kütüphanesinde "vector" ismi ile C# ve Java ortamlarının temel kütüphanelerinde "ArrayList" ismiyle
    bulunmaktadır. Dinamik dizilerin gerçekleştirilmesinde önemli olan birkaç nokta vardır. Bunlardan en önemlisi dinamik dizi için ayrılan alan yetmediğinde dizinin ne kadar büyütüleceğidir. Diziyi birer birer büyütmek iyi bir fikir değildir. Çünkü dinamik tahsisatlar
    yavaş olma eğilimindedir. Genellikle büyütme "eskisinin iki katı olacak" biçimde yapılmaktadır. Böylece büyütme (reallocation) dizi uzunluğuna göre logaritmik karmaşıklıkta (yani O(log N) karmaşıklıkta) yapılmış olur. Gerçekleştirimde programcının o anda dinamk dizi
    içerisinde kaç elemanın bulunduğunu ve o anda dizi için tahsis edilen elemanın kaç eleman uzunluğunda olduğunu tutması gerekir. Dizide var olan eleman sayısına "count" ya da "size" denilmektedir. Dizi için tahsis edilmiş olan eleman sayısına ise genellikle "capacity"
    debilmektedir. Dinamik dizinin sonuna eleman eklerken eleman count (ya da size) ile belirtien indekse eklenir ve count değer bir artılır. count değeri capacity değerine ulaştığında yeniden tahsisat (reallocation) yapılarak dinamik dizi büyütülmelidir. Dinamik dizilerde
    araya eleman da benzer biçimde eklenmektedir. Genel olarka dinamik dizilerin gerçekleştirimlerinde eleman silindiğinde kapasite azaltılması yapılmamaktadır. Dinamik dizilerin gerçekleştirilmesinde kullanıcılara sunulacak temel işlevler şunlardır:

        -> Dinamik dizinin yaratılması
        -> Dinamik dizinin yok edilmesi
        -> Dinamik dizinin sonuna eleman eklenmesi
        -> Araya elemanın insert edilmesi
        -> Count ve capacity değerleriin dışarıya verilmesi
        -> Elemanların get ve set edilmesi
        -> Belli bir indeksteki elemanın silinmesi
        -> Dizideki tüm elemanların silinmesi
        -> Capacity değerinin büyütülmesi
        -> Capacity değerinin count değerine çekilmesi

	Genel olarak dinamik büyütülen dizilerde bir elemanın silinmesi ya da tüm elemanların silinmesi capaciry değerinde bir değişiklik yaratmamaktadır. Genellikle bu tür veri yapılarında capacity değerinin büyütülmesine izin verilir. Ancak küçültülmsine izin verilmez. Ancak
    özel bir durum olarak capacity değeri count değerine çekilebilmektedir. Aşağıdaki dinamik dizilerin gerçekleştirimine ilişkin bir örnek verilmiştir. Bu örnekte bazı küçük fonksiyonlar makro yerine static inline fonksiyon biçiminde başlık dosyasının içerisinde
    tanımlanmıştır.
        * Örnek 1,
            /* dynamicarray.h */
                #ifndef DYNAMICARRAY_H_
                #define DYNAMICARRAY_H_

                /* Symbolic Constants */

                #define DARRAY_DEF_CAPACITY		8
                #define DARRAY_FAILED			((size_t)-1)

                /* Type Declaratrions */

                typedef int DATATYPE;

                typedef struct tagDARRAY {
                    DATATYPE *darray;
                    size_t capacity;
                    size_t count;
                } DARRAY, *HDARRAY;

                /* Function Prototypes */

                HDARRAY create_darray(void);
                void destroy_darray(HDARRAY hdarray);
                size_t add_darray(HDARRAY hdarray, DATATYPE val);
                size_t multiadd_darray(HDARRAY hdarray, const DATATYPE *vals, size_t size);
                size_t addp_darray(HDARRAY hdarray, const DATATYPE *val);
                size_t insert_darray(HDARRAY hdarray, size_t index, DATATYPE val);
                size_t remove_darray(HDARRAY hdarray, size_t index);
                size_t reserve_darray(HDARRAY hdarray, size_t newcapacity);

                /* inine function definitions */

                static inline size_t capacity_darray(HDARRAY hdarray)
                {
                    return hdarray->capacity;
                }

                static inline size_t count_darray(HDARRAY hdarray)
                {
                    return hdarray->count;
                }

                static inline DATATYPE get_darray(HDARRAY hdarray, size_t index)
                {
                    return hdarray->darray[index];
                }

                static inline void set_darray(HDARRAY hdarray, size_t index, DATATYPE val)
                {
                    hdarray->darray[index] = val;
                }

                static inline void setp_darray(HDARRAY hdarray, size_t index, const DATATYPE *val)
                {
                    hdarray->darray[index] = *val;
                }

                static inline void getp_darray(HDARRAY hdarray, size_t index, DATATYPE *val)
                {
                    *val = hdarray->darray[index];
                }

                static inline void clear_darray(HDARRAY hdarray)
                {
                    hdarray->count = 0;
                }

                #endif

            /* dynamic.arry.c */
                #include <stdio.h>
                #include <stdlib.h>
                #include "dynamicarray.h"

                static int reallocate(HDARRAY hdarray, size_t newcapacity);

                HDARRAY create_darray(void)
                {
                    HDARRAY hdarray;

                    if ((hdarray = (HDARRAY)malloc(sizeof(DARRAY))) == NULL)
                        return NULL;

                    if ((hdarray->darray = (DATATYPE *)malloc(sizeof(DATATYPE) * DARRAY_DEF_CAPACITY)) == NULL) {
                        free(hdarray);
                        return NULL;
                    }

                    hdarray->capacity = DARRAY_DEF_CAPACITY;
                    hdarray->count = 0;

                    return hdarray;
                }

                void destroy_darray(HDARRAY hdarray)
                {
                    free(hdarray->darray);
                    free(hdarray);
                }

                size_t add_darray(HDARRAY hdarray, DATATYPE val)
                {
                    if (hdarray->count == hdarray->capacity && reallocate(hdarray, hdarray->capacity * 2) == -1)
                        return DARRAY_FAILED;

                    hdarray->darray[hdarray->count++] = val;

                    return hdarray->count - 1;
                }

                size_t multiadd_darray(HDARRAY hdarray, const DATATYPE *vals, size_t size)
                {
                    if (hdarray->count + size > hdarray->capacity && reallocate(hdarray, hdarray->capacity * 2 + size) == -1)
                        return DARRAY_FAILED;

                    memmove(hdarray->darray + hdarray->count, vals, sizeof(DATATYPE) * size);
                    hdarray->count += size;

                    return hdarray->count - 1;
                }

                size_t addp_darray(HDARRAY hdarray, const DATATYPE *val)
                {
                    if (hdarray->count == hdarray->capacity && reallocate(hdarray, hdarray->capacity * 2) == -1)
                        return DARRAY_FAILED;

                    hdarray->darray[hdarray->count++] = *val;

                    return hdarray->count - 1;
                }

                size_t insert_darray(HDARRAY hdarray, size_t index, DATATYPE val)
                {
                    if (index > hdarray->count)
                        return DARRAY_FAILED;

                    if (hdarray->count == hdarray->capacity && reallocate(hdarray, hdarray->capacity * 2) == -1)
                        return DARRAY_FAILED;

                    memmove(hdarray->darray + index + 1, hdarray->darray + index, (hdarray->count - index) * sizeof(DATATYPE));
                    hdarray->darray[index] = val;
                    ++hdarray->count;

                    return index;
                }

                size_t insertp_darray(HDARRAY hdarray, size_t index, const DATATYPE *val)
                {
                    if (index > hdarray->count)
                        return DARRAY_FAILED;

                    if (hdarray->count == hdarray->capacity && reallocate(hdarray, hdarray->capacity * 2) == -1)
                        return DARRAY_FAILED;

                    memmove(hdarray->darray + index + 1, hdarray->darray + index, (hdarray->count - index) * sizeof(DATATYPE));
                    hdarray->darray[index] = *val;
                    ++hdarray->count;

                    return index;
                }

                size_t remove_darray(HDARRAY hdarray, size_t index)
                {
                    if (index >= hdarray->count)
                        return DARRAY_FAILED;
                        
                    memmove(hdarray->darray + index, hdarray->darray + index + 1, (hdarray->count - index - 1) * sizeof(DATATYPE));
                    --hdarray->count;

                    return index;
                }

                size_t reserve_darray(HDARRAY hdarray, size_t newcapacity)
                {
                    if (newcapacity <= hdarray->capacity)
                        return 0;
                    
                    if (reallocate(hdarray, newcapacity) == -1)
                        return 0;

                    return newcapacity;
                }

                static int reallocate(HDARRAY hdarray, size_t newcapacity)
                {
                    DATATYPE *new_darray;

                    if ((new_darray = (DATATYPE *)realloc(hdarray->darray, sizeof(DATATYPE) * newcapacity)) == NULL)
                        return -1;

                    hdarray->darray = new_darray;
                    hdarray->capacity = newcapacity;

                    return 0;
                }

    >> Aralarında öncelik-sonralık ilişkisi olan veri yapılarına "liste (list)" de denilemektedir. Örneğin bu tanıma göre diziler de "liste tarzı" veri yapılarıdır. Liste tarzı veri yapılarının en yaygın kullanılanlarında biri "bağlı liste (linkes list)" denilen veri
    yapısıdır. Önceki elemanının sonraki elemanın yerini gösterdiği dolayısıyla elemanların ardışıl olma zorunluluğunun ortadan kaldırıldığı dizilere "bağlı liste" denilmektedir. Dizi elemanlarının bellekte fiziklsel olarak ardışıl biçimde bulunduğunu anımsayınız. Bağlı
    listeler adeta "elemanları bellekte ardışıl olmayan diziler" gibidir. Bağlı listelerin her elemanına "düğüm (node)" denilmektedir. Biz kursumuzda bağlı liste elemanlarına "düğüm" ya da "eleman" diyeceğiz. Bağlı listelerde her düğüm sonraki düğümün yerini tutarsa ve ilk
    elemanın yeri de biliniyorsa liste elemanlarının hepsine erişilebilmektedir. Örneğin:

	    head ----> node ---> node ---> node ----> node (NULL)

	Bağlı listelerde her düğüm hem elemanın değerini hem de sonraki elemanın adresini tutmaktadır. Bunun için bağlı liste deüğümleri bir yapı ile ifade edilmektedir. Örneğin:

        typedef struct tagNODE {
            DATATYPE val;
            struct tagNODE *next;
        } NODE;

	Bağlı listelerde ilk elemanın yeri bir biçimde bir gösterici tutulmalıdır. Genellikle ilk elemanın yerini tutan göstericiye "head göstericisi" denilmektdir. Örneğin:

	    NODE *head;  /* ilk elemanın yeri */

	Bağlı listenin sonuna elemanın hızla eklenebilmesi için genellikle son elemanın yeri de tutulmaktadır. Son elemanın yerini tutan göstericiye de "tail göstericisi" denilmektedir.
	
	    NODE *tail;  /* son elemanın yeri */

	Tipik olarak bağlı listenin son elemanın (düğümünün) next göstericisinde NULL adres bulunur. Bu durum listenin sonuna gelindiğini belirtmektedir. Bağlı listenin tüm elemanlarını gözden geçirmek basit döngüyle yapılabilir:

        NODE *node;
        ...

        node = head;
        while (node != NULL) {
            ...
            node = node->next;
        }

	Tabii bu dolaşımı for döngüsüyle daha kolay da ifade edebiliriz:

        for (NODE *node = head; node != NULL; node = node->next) {
            ...
        }

	Her düğümün yalnızca sonraki düğümün değil aynı zamanda önceki düğümün de yerini tuttuğu bağlı listelere "çift bağlı listeler (double linked list)" denilmektedir. Çift bağlı listeler belli bir düğümün adresini biliyorsak yalnızca ileriye doğru değil, geriye doğru
	da gidebiliriz. Çift bağlı listelerin düğümleri de aşağıdaki gibi bir yapıyla temsil edilebilir:

        typedef struct tagNODE {
            DATATYPE val;
            struct tagNODE *next;
            struct tagNODE *prev;
        } NODE;

	Çift bağlı listelerin bir düğümünün bellekte daha fazla yer kaplayacağına dikkat ediniz. Çift bağlı listelerin tek bağlı listelere göre en önemli özelliği "adresi bilinen bir düğümün" silinebilmesidir. Tek bağlı listelerde bu durum mümkün değildir. Uygulamalarda buna
    çok sık gereksinim duyulmaktadır. Eğer bir bağlı listede son eleman ilk elemanı gösteriyorsa bu tür bağlı listelere de "döngüsel bağlı listeler (circular linkes lists)" denilmektedir. Pekiyi bağlı listelere neden gereksinim duyulmaktadır? Diziler varken bağlı listelere
    gerek var mıdır? Dizilerle bağlı listeler arasındaki farklılkları, benzerlikleri ve bağlı listelere neden gereksinim duyulduğunu birkaç maddede açıklayabiliriz:

        -> Diziler ardışıl alana gereksinim duymaktadır. Ancak belleğin bölündüğü (fragmente olduğu) durumlarda bellekte yeteri kadar küçük boş alanlar olduğu halde bunlar ardışıl olmadığı için dizi tahsisatı mümkün olamamaktadır. Bu tür durumlarda ardışıllık gereksinimi
        olmayan bağlı listeler kullanılabilir. Özellikle heap gibi bir alanda çok sayıda dinamik diziler bellek kullanımı açısından verimsizliğe yol açabilmektedir. Bu dinamik diziler zamanla büyüdükçe birbirini engeller hale gelebilmektedir. İşte uzunluğu baştan belli
        olmayan çok sayıda dizinin oluşturulacağı durumlarda dinamik dizi yerine bağlı listeler toplamda daha iyi performans gösterebilmektedir. Dinamik dizilerde dinamik dizinin büyütülmesi yavaş bir işlemdir. Çünkü büyütme sırasında bloklar yer değiştirebilmektedir. 

        -> Dizilerde araya eleman ekleme (insert etme) ve aradaki bir elemanı silme dizinin kaydırılmasına (expand ve shrink edilmesine) yol açacağından yavaş bir işlemdir. Teknik olarak dizilerde eleman isert etme ve eleman silme O(N) karmaşıklıkta bir işlemdir. Halbuki
        bağlı listelerde eğer düğümün yerini biliyorsak bu işlem O(1) karmaşıklıkta (yani döngü olmadan tekil işlemlerle) yapılabilmektedir. O halde araya eleman eklemenin ve aradan eleman silmenin çok yapıldığı sistemlerde bağlı diziler yerine bağlı listeler tercih
        edilebilmektedir. 

        -> Bağlı listelerde belli bir indeksteki elemana erişmek O(N) karmaşıklıkta bir işlemdir. Halbuki dizilerde elemana erişim O(1) karmaşıklıkta yani çok hızlıdır. O halde belli bir indeks değeri ile elemana erişimin yoğun yapıldığı durumlarda bağlı listeler yerine
        diziler tercih edilmelidir. 

        -> Bağlı listeler toplamda bellekte daha fazla yer kaplama eğilimindedir. Çünkü bağlı listenin her düğümü sonraki (ve duruma göre önceki) elemanın yerini de tutmaktadır. 

    O halde bağlı listeler tipik şu durumlarda dizilere tercih edilmelidir:

        -> Eleman insert etmenin ve eleman silmenin çok yapıldığı durumlarda
        -> Uzunluğu baştan belli olmayan çok sayıda dizinin kullanıldığı durumda
        -> İndeks yoluyla erişimin az yapıldığı durumda
        -> Bellek miktarının yeteri kadar fazla olduğu sistemlerde

    Soyut bir veri türü (abstract data type) olarak bağlı listeler üzerinde şu işlemlerin yapılması beklenmektedir:

        -> Bağlı listenin başına ve sonuna eleman eklenmesi
        -> Bağlı listenin dolaşılması ve belli bir indeksteki elemanın elde edilmesi
        -> Adresi bilinen bir düğümün önüne ya da arkasına eleman insert edilmesi
        -> Adresi bilinen bir düğümün silinmesi

	Aşağıda çift bağlı listelerin gerçekleştirilmesine ilişkin bir örnek verilmiştir.
        * Örnek 1,
            /* llist.h */
                #ifndef LLIST_H_
                #define LLIST_H_

                #include <stddef.h>
                #include <stdbool.h>

                /* Type Declarations  */

                typedef int DATATYPE;

                typedef struct tagNODE {
                    DATATYPE val;
                    struct tagNODE *next;
                    struct tagNODE *prev;
                } NODE;

                typedef struct tagLLIST {
                    NODE *head;
                    NODE *tail;
                    size_t count;
                } LLIST, *HLLIST;

                /* Function Prototypes */

                HLLIST create_llist(void);
                NODE *add_tail(HLLIST hllist, DATATYPE val);
                NODE *addp_tail(HLLIST hllist, const DATATYPE *val);
                NODE *add_head(HLLIST hllist, DATATYPE val);
                NODE *addp_head(HLLIST hllist, const DATATYPE *val);
                NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val);
                NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val);
                NODE *insert_prev(HLLIST hllist, NODE *node, DATATYPE val);
                NODE *insertp_prev(HLLIST hllist, NODE *node, const DATATYPE *val);
                void remove_node(HLLIST hllist, NODE *node);
                DATATYPE *getp_item(HLLIST hllist, size_t index);
                bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *));
                bool walk_llist_rev(HLLIST hllist, bool (*proc)(DATATYPE *));
                void clear_llist(HLLIST hllist);
                void destroy_llist(HLLIST hllist);

                /* inline Function Definitions */

                static inline size_t count_llist(HLLIST hllist)
                {
                    return hllist->count;
                }

                #endif

            /* llist.c */
                #include <stdio.h>
                #include <stdlib.h>
                #include "llist.h"

                /* static Functions Prototypes */

                static bool disp(DATATYPE *val);

                /* Function Definitions */

                HLLIST create_llist(void)
                {
                    HLLIST hllist;

                    if ((hllist = (HLLIST)malloc(sizeof(LLIST))) == NULL)
                        return NULL;

                    hllist->head = hllist->tail = NULL;
                    hllist->count = 0;

                    return hllist;
                }

                NODE *add_tail(HLLIST hllist, DATATYPE val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = val;

                    if (hllist->head != NULL) 					/* is list is empty? */
                        hllist->tail->next = new_node;
                    else
                        hllist->head = new_node;

                    new_node->prev = hllist->tail;
                    new_node->next = NULL;

                    hllist->tail = new_node;
                    ++hllist->count;

                    return new_node;
                }

                NODE *addp_tail(HLLIST hllist, const DATATYPE *val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = *val;

                    if (hllist->head != NULL) 					/* is list is empty? */
                        hllist->tail->next = new_node;
                    else
                        hllist->head = new_node;

                    new_node->prev = hllist->tail;
                    new_node->next = NULL;

                    hllist->tail = new_node;
                    ++hllist->count;

                    return new_node;
                }

                NODE *add_head(HLLIST hllist, DATATYPE val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = val;

                    new_node->next = hllist->head;
                    new_node->prev = NULL;

                    if (hllist->head == NULL)
                        hllist->tail = new_node;
                    else
                        hllist->head->prev = new_node;

                    hllist->head = new_node;
                    ++hllist->count;

                    return new_node;
                }

                NODE *addp_head(HLLIST hllist, const DATATYPE *val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = *val;

                    new_node->next = hllist->head;
                    new_node->prev = NULL;

                    if (hllist->head == NULL)
                        hllist->tail = new_node;
                    else
                        hllist->head->prev = new_node;

                    hllist->head = new_node;
                    ++hllist->count;

                    return new_node;
                }

                NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = val;

                    if (node != hllist->tail)
                        node->next->prev = new_node;
                    else
                        hllist->tail = new_node;

                    new_node->next = node->next;
                    node->next = new_node;
                    new_node->prev = node;

                    ++hllist->count;

                    return new_node;
                }

                NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = *val;

                    if (node != hllist->tail)
                        node->next->prev = new_node;
                    else
                        hllist->tail = new_node;

                    new_node->next = node->next;
                    node->next = new_node;
                    new_node->prev = node;

                    ++hllist->count;

                    return new_node;
                }

                NODE *insert_prev(HLLIST hllist, NODE *node, DATATYPE val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = val;

                    if (node != hllist->head)
                        node->prev->next = new_node;
                    else
                        hllist->head = new_node;

                    new_node->next = node;
                    new_node->prev = node->prev;
                    node->prev = new_node;

                    ++hllist->count;

                    return new_node;
                }

                NODE *insertp_prev(HLLIST hllist, NODE *node, const DATATYPE *val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = *val;

                    if (node != hllist->head)
                        node->prev->next = new_node;
                    else
                        hllist->head = new_node;

                    new_node->next = node;
                    new_node->prev = node->prev;
                    node->prev = new_node;

                    ++hllist->count;

                    return new_node;
                }

                void remove_node(HLLIST hllist, NODE *node)
                {
                    if (node == hllist->head)
                        hllist->head = node->next;
                    else
                        node->prev->next = node->next;


                    if (node == hllist->tail)
                        hllist->tail = node->prev;
                    else
                        node->next->prev = node->prev;

                    --hllist->count;

                    free(node);
                }

                DATATYPE *getp_item(HLLIST hllist, size_t index)
                {
                    NODE *node;

                    if (index >= hllist->count)
                        return NULL;

                    node = hllist->head;
                    for (size_t i = 0; i < index; ++i)
                        node = node->next;

                    return &node->val;
                }

                bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *))
                {
                    bool retval = true;
                    bool def_flag = false;

                    if (proc == NULL) {
                        proc = disp;
                        def_flag = true;
                    }

                    for (NODE *node = hllist->head; node != NULL; node = node->next)
                        if (!proc(&node->val)) {
                            retval = false;
                            break;
                        }

                    if (def_flag)
                        putchar('\n');

                    return retval;
                }

                bool walk_llist_rev(HLLIST hllist, bool (*proc)(DATATYPE *))
                {
                    bool retval = true;
                    bool def_flag = false;

                    if (proc == NULL) {
                        proc = disp;
                        def_flag = true;
                    }

                    for (NODE *node = hllist->tail; node != NULL; node = node->prev)
                        if (!proc(&node->val)) {
                            retval = false;
                            break;
                        }

                    if (def_flag)
                        putchar('\n');

                    return retval;
                }

                void clear_llist(HLLIST hllist)
                {
                    NODE *node, *temp_node;

                    node = hllist->head;

                    while (node != NULL) {
                        temp_node = node->next;
                        free(node);
                        node = temp_node;
                    }

                    hllist->head = hllist->tail = NULL;
                    hllist->count = 0;
                }

                void destroy_llist(HLLIST hllist)
                {
                    NODE *node, *temp_node;

                    node = hllist->head;

                    while (node != NULL) {
                        temp_node = node->next;
                        free(node);
                        node = temp_node;
                    }

                    free(hllist);
                }

                static bool disp(DATATYPE *val)
                {
                    printf("%d ", *val);
                    fflush(stdout);

                    return true;
                }

            /* app.c */
                #include <stdio.h>
                #include <stdlib.h>
                #include "llist.h"

                int main(void)
                {
                    HLLIST hllist;
                    NODE *node, *pos_node;
                    DATATYPE *val;

                    if ((hllist = create_llist()) == NULL) {
                        fprintf(stderr, "cannot create linked list...\n");
                        exit(EXIT_FAILURE);
                    }

                    for (int i = 0; i < 10; ++i) {
                        if ((node = add_tail(hllist, i)) == NULL) {
                            fprintf(stderr, "cannot add item!..\n");
                            exit(EXIT_FAILURE);
                        }
                        if (i == 9)
                            pos_node = node;
                    }

                    walk_llist(hllist, NULL);

                    remove_node(hllist, pos_node);

                    walk_llist(hllist, NULL);

                    if ((val = getp_item(hllist, 5)) == NULL) {
                        fprintf(stderr, "invalid index!..\n");
                        exit(EXIT_FAILURE);
                    }

                    printf("%d\n", *val);

                    clear_llist(hllist);

                    for (int i = 0; i < 10; ++i) 
                        if (add_tail(hllist, i) == NULL) {
                            fprintf(stderr, "cannot add item!..\n");
                            exit(EXIT_FAILURE);
                        }

                    walk_llist(hllist, NULL);

                    destroy_llist(hllist);

                    return 0;
                }

        * Örnek 2, Çift bağlı liste gerçekleştiriminde handle alanında head ve tail göstericilerini ayrı ayrı tutmak yerine NODE nesnesi tutulursa özel durumlar ortadan kaldırılabilir ve gerçekleştirim daha sade hale getirilebilir. Bu tasarımda ilk düğümün prev göstericisi
        ve son düğümün next göstericisi handle alanındaki düğümü göstermelidir. Benzer biçimde handle alanındaki düğümün next göstericisi ilk düğümün yerini prev göstericisi ise son düğümün yerini göstermelidir. Tabii bu durumda handle alanında tutulan NODE nesnesinin val
        elemanı aslında listeye dahil olmadığı için kullanılmayacaktır. Dolayısıyla bu eleman boşa yer kaplayacaktır. Ancak genellikle bu durum öncemsizdir. Bu tarzda gerçekleştirim programcılar tarafından daha fazla tercih edilmektedir. Bu biçimdeki tasarımda handle alanı
        aşağıdaki gibi olacaktır:

            typedef struct tagNODE {
                DATATYPE val;
                struct tagNODE *next;
                struct tagNODE *prev;
            } NODE;

            typedef struct tagLLIST {
                NODE head;
                size_t count;
            } LLIST, *HLLIST;

        Başlangıç durumunda handle alanı içerisindeki düğümün next ve prev göstericilerinin kendisini göstermesi gerekir. Tabii dolaşım yapılırken artık dolaşımın biteceği son düğümdeki NULL adresinden değil next göstericisinin handle alanı içerisindeki düğümün adresine
        eşit olmaması ile tespit edilebilecektir. Aşağıda çift bağlı listelerde handle alanında düğüm tutma yoluyla özel durumların elimine edilmesine bir örnek verilmiştir. Aşağıda ilgili programın kodları paylaşılmıştır:
            /* llist.h */
                #ifndef LLIST_H_
                #define LLIST_H_

                #include <stddef.h>
                #include <stdbool.h>

                /* Type Declarations  */

                typedef int DATATYPE;

                typedef struct tagNODE {
                    DATATYPE val;
                    struct tagNODE *next;
                    struct tagNODE *prev;
                } NODE;

                typedef struct tagLLIST {
                    NODE head;
                    size_t count;
                } LLIST, *HLLIST;

                /* Function Prototypes */

                HLLIST create_llist(void);
                NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val);
                NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val);
                NODE *insert_prev(HLLIST hllist, NODE *node, DATATYPE val);
                NODE *insertp_prev(HLLIST hllist, NODE *node, const DATATYPE *val);
                NODE *add_tail(HLLIST hllist, DATATYPE val);
                NODE *addp_tail(HLLIST hllist, const DATATYPE *val);
                NODE *add_head(HLLIST hllist, DATATYPE val);
                NODE *addp_head(HLLIST hllist, const DATATYPE *val);
                void remove_node(HLLIST hllist, NODE *node);
                DATATYPE *getp_item(HLLIST hllist, size_t index);
                bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *));
                bool walk_llist_rev(HLLIST hllist, bool (*proc)(DATATYPE *));
                void clear_llist(HLLIST hllist);
                void destroy_llist(HLLIST hllist);

                /* inline Function Definitions */

                static inline size_t count_llist(HLLIST hllist)
                {
                    return hllist->count;
                }

                #endif

            /* llist.c */
                #include <stdio.h>
                #include <stdlib.h>
                #include "llist.h"

                /* static Functions Prototypes */

                static bool disp(DATATYPE *node);

                /* Function Definitions */

                HLLIST create_llist(void)
                {
                    HLLIST hllist;

                    if ((hllist = (HLLIST)malloc(sizeof(LLIST))) == NULL)
                        return NULL;

                    hllist->head.next = &hllist->head;
                    hllist->head.prev = &hllist->head;
                    hllist->count = 0;

                    return hllist;
                }

                NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = val;

                    node->next->prev = new_node;
                    new_node->next = node->next;
                    node->next = new_node;
                    new_node->prev = node;

                    ++hllist->count;

                    return new_node;
                }

                NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = *val;

                    node->next->prev = new_node;
                    new_node->next = node->next;
                    node->next = new_node;
                    new_node->prev = node;

                    ++hllist->count;

                    return new_node;
                }

                NODE *insert_prev(HLLIST hllist, NODE *node, DATATYPE val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = val;

                    node->prev->next = new_node;
                    new_node->next = node;
                    new_node->prev = node->prev;
                    node->prev = new_node;

                    ++hllist->count;

                    return new_node;
                }

                NODE *insertp_prev(HLLIST hllist, NODE *node, const DATATYPE *val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = *val;

                    node->prev->next = new_node;
                    new_node->next = node;
                    new_node->prev = node->prev;
                    node->prev = new_node;

                    ++hllist->count;

                    return new_node;
                }

                NODE *add_tail(HLLIST hllist, DATATYPE val)
                {
                    return insert_prev(hllist, &hllist->head, val);
                }

                NODE *addp_tail(HLLIST hllist, const DATATYPE *val)
                {
                    return insertp_prev(hllist, &hllist->head, val);
                }

                NODE *add_head(HLLIST hllist, DATATYPE val)
                {
                    return insert_next(hllist, &hllist->head, val);
                }

                NODE *addp_head(HLLIST hllist, const DATATYPE *val)
                {
                    return insertp_next(hllist, &hllist->head, val);
                }

                void remove_node(HLLIST hllist, NODE *node)
                {
                    node->prev->next = node->next;
                    node->next->prev = node->prev;

                    --hllist->count;

                    free(node);
                }

                DATATYPE *getp_item(HLLIST hllist, size_t index)
                {
                    NODE *node;

                    if (index >= hllist->count)
                        return NULL;

                    node = hllist->head.next;
                    for (size_t i = 0; i < index; ++i)
                        node = node->next;

                    return &node->val;
                }

                bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *))
                {
                    bool retval = true;
                    bool def_flag = false;

                    if (proc == NULL) {
                        proc = disp;
                        def_flag = true;
                    }

                    for (NODE *node = hllist->head.next; node != &hllist->head; node = node->next)
                        if (!proc(&node->val)) {
                            retval = false;
                            break;
                        }

                    if (def_flag)
                        putchar('\n');

                    return retval;
                }

                bool walk_llist_rev(HLLIST hllist, bool (*proc)(DATATYPE *))
                {
                    bool retval = true;
                    bool def_flag = false;

                    if (proc == NULL) {
                        proc = disp;
                        def_flag = true;
                    }

                    for (NODE *node = hllist->head.prev; node != &hllist->head; node = node->prev)
                        if (!proc(&node->val)) {
                            retval = false;
                            break;
                        }

                    if (def_flag)
                        putchar('\n');

                    return retval;
                }

                void clear_llist(HLLIST hllist)
                {
                    NODE *node, *temp_node;

                    node = hllist->head.next;

                    while (node != &hllist->head) {
                        temp_node = node->next;
                        free(node);
                        node = temp_node;
                    }

                    hllist->head.next = &hllist->head;
                    hllist->head.prev = &hllist->head;

                    hllist->count = 0;
                }

                void destroy_llist(HLLIST hllist)
                {
                    NODE *node, *temp_node;

                    node = hllist->head.next;

                    while (node != &hllist->head) {
                        temp_node = node->next;
                        free(node);
                        node = temp_node;
                    }

                    free(hllist);
                }

                static bool disp(DATATYPE *val)
                {
                    printf("%d ", *val);
                    fflush(stdout);

                    return true;
                }

            /* app.c */
                #include <stdio.h>
                #include <stdlib.h>
                #include "llist.h"

                int main(void)
                {
                    HLLIST hllist;
                    NODE *node, *pos_node;
                    DATATYPE *val;

                    if ((hllist = create_llist()) == NULL) {
                        fprintf(stderr, "cannot create linked list...\n");
                        exit(EXIT_FAILURE);
                    }

                    for (int i = 0; i < 10; ++i) {
                        if ((node = add_tail(hllist, i)) == NULL) {
                            fprintf(stderr, "cannot add item!..\n");
                            exit(EXIT_FAILURE);
                        }
                        if (i == 0)
                            pos_node = node;
                    }

                    walk_llist(hllist, NULL);

                    remove_node(hllist, pos_node);

                    walk_llist(hllist, NULL);

                    if ((val = getp_item(hllist, 5)) == NULL) {
                        fprintf(stderr, "invalid index!..\n");
                        exit(EXIT_FAILURE);
                    }

                    printf("%d\n", *val);

                    clear_llist(hllist);

                    for (int i = 0; i < 10; ++i) 
                        if (add_tail(hllist, i) == NULL) {
                            fprintf(stderr, "cannot add item!..\n");
                            exit(EXIT_FAILURE);
                        }

                    walk_llist(hllist, NULL);
                    
                    destroy_llist(hllist);
                    
                    return 0;
                }

        * Örnek 3, Tek bağlı listelerde her düğüm yalnızca sonraki düğümün adresini tutmaktadır. Dolayısıyla geriye doğru ilerleme mümkün olmaz. Tak bağlı listelerde adresini bildiğimiz düğümün yalnızca önüne eleman insert edebiliriz. Benzer biçimde adresini bildiğimiz
        düğümü silemeyiz. Ancak adresini bildiğimiz düğümün önündeki düğümü silebiliriz. Bunun için oluşturulacak handle alanı şöyle olabilir:

            typedef struct tagNODE {
                DATATYPE val;
                struct tagNODE *next;
            } NODE;

            typedef struct tagLLIST {
                NODE *head;
                NODE *tail;
                size_t count;
            } LLIST, *HLLIST;

        Soyut bir veri türü olarak tek baalı listelerde gerçekleştirilebilecek işlemler şunlar olabilir:

            -> Listenin başına ve sonuna eleman eklenmesi
            -> Listenin dolaşılması ve belli bir indeksteki elemanın elde edilmesi
            -> Adresi bilinen bir düğümün önüne eleman insert edilmesi
            -> Adresi bilinen bir düğümün önündeki elemanın silinmesi

	    Aşağıdaki örnekte bir tek bağlı liste gerçekleştirimi verilmiştir.
            /* llist.h */
                #ifndef LLIST_H_
                #define LLIST_H_

                #include <stddef.h>
                #include <stdbool.h>

                /* Type Declarations  */

                typedef int DATATYPE;

                typedef struct tagNODE {
                    DATATYPE val;
                    struct tagNODE *next;
                } NODE;

                typedef struct tagLLIST {
                    NODE *head;
                    NODE *tail;
                    size_t count;
                } LLIST, *HLLIST;

                /* Function Prototypes */

                HLLIST create_llist(void);
                NODE *add_tail(HLLIST hllist, DATATYPE val);
                NODE *addp_tail(HLLIST hllist, const DATATYPE *val);
                NODE *add_head(HLLIST hllist, DATATYPE val);
                NODE *addp_head(HLLIST hllist, const DATATYPE *val);
                NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val);
                NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val);
                void remove_next(HLLIST hllist, NODE *node);
                DATATYPE *getp_item(HLLIST hllist, size_t index);
                bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *));
                void clear_llist(HLLIST hllist);
                void destroy_llist(HLLIST hllist);

                /* inline Function Definitions */

                static inline size_t count_llist(HLLIST hllist)
                {
                    return hllist->count;
                }

                #endif

            /* llist.c */
                #include <stdio.h>
                #include <stdlib.h>
                #include "llist.h"

                /* static Functions Prototypes */

                static bool disp(DATATYPE *val);

                /* Function Definitions */

                HLLIST create_llist(void)
                {
                    HLLIST hllist;

                    if ((hllist = (HLLIST)malloc(sizeof(LLIST))) == NULL)
                        return NULL;

                    hllist->head = hllist->tail = NULL;
                    hllist->count = 0;

                    return hllist;
                }

                NODE *add_tail(HLLIST hllist, DATATYPE val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = val;

                    if (hllist->tail != NULL)
                        hllist->tail->next = new_node;
                    else
                        hllist->head = new_node;

                    hllist->tail = new_node;
                    new_node->next = NULL;

                    ++hllist->count;

                    return new_node;
                }

                NODE *addp_tail(HLLIST hllist, const DATATYPE *val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = *val;

                    if (hllist->tail != NULL)
                        hllist->tail->next = new_node;
                    else
                        hllist->head = new_node;

                    hllist->tail = new_node;
                    new_node->next = NULL;

                    ++hllist->count;

                    return new_node;
                }

                NODE *add_head(HLLIST hllist, DATATYPE val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = val;

                    new_node->next = hllist->head;
                    if (hllist->head == NULL)
                        hllist->tail = new_node;
                    hllist->head = new_node;

                    ++hllist->count;

                    return new_node;
                }

                NODE *addp_head(HLLIST hllist, const DATATYPE *val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = *val;

                    new_node->next = hllist->head;
                    if (hllist->head == NULL)
                        hllist->tail = new_node;
                    hllist->head = new_node;

                    ++hllist->count;

                    return new_node;
                }
                NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = val;

                    if (node == hllist->tail)
                        hllist->tail = new_node;

                    new_node->next = node->next;
                    node->next = new_node;

                    ++hllist->count;

                    return new_node;
                }

                NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = *val;

                    if (node == hllist->tail)
                        hllist->tail = new_node;

                    new_node->next = node->next;
                    node->next = new_node;

                    ++hllist->count;

                    return new_node;
                }

                void remove_next(HLLIST hllist, NODE *node)
                {
                    NODE *next_node;

                    if (node == hllist->tail)
                        return;

                    if (node->next == hllist->tail)
                        hllist->tail = node;

                    next_node = node->next;
                    node->next = next_node->next;

                    --hllist->count;

                    free(next_node);
                }

                bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *))
                {
                    bool retval = true;
                    bool def_flag = false;

                    if (proc == NULL) {
                        proc = disp;
                        def_flag = true;
                    }

                    for (NODE *node = hllist->head; node != NULL; node = node->next)
                        if (!proc(&node->val)) {
                            retval = false;
                            break;
                        }

                    if (def_flag)
                        putchar('\n');

                    return retval;
                }

                DATATYPE *getp_item(HLLIST hllist, size_t index)
                {
                    NODE *node;

                    if (index >= hllist->count)
                        return NULL;

                    node = hllist->head;
                    for (size_t i = 0; i < index; ++i)
                        node = node->next;

                    return &node->val;
                }
                void clear_llist(HLLIST hllist)
                {
                    NODE *node, *temp_node;

                    node = hllist->head;
                    while (node != NULL) {
                        temp_node = node->next;
                        free(node);
                        node = temp_node;
                    }

                    hllist->head = hllist->tail = NULL;
                    hllist->count = 0;
                }

                void destroy_llist(HLLIST hllist)
                {
                    NODE *node, *temp_node;

                    node = hllist->head;
                    while (node != NULL) {
                        temp_node = node->next;
                        free(node);
                        node = temp_node;
                    }

                    free(hllist);
                }

                static bool disp(DATATYPE *val)
                {
                    printf("%d ", *val);
                    fflush(stdout);

                    return true;
                }

            /* app.c */
                #include <stdio.h>
                #include <stdlib.h>
                #include "llist.h"

                int main(void)
                {
                    HLLIST hllist;
                    NODE *node, *pos_node;
                    int *val;

                    if ((hllist = create_llist()) == NULL) {
                        fprintf(stderr, "cannot create linked list...\n");
                        exit(EXIT_FAILURE);
                    }

                    for (int i = 0; i < 10; ++i) {
                        if ((node = add_tail(hllist, i)) == NULL) {
                            fprintf(stderr, "cannot add item!..\n");
                            exit(EXIT_FAILURE);
                        }
                        if (i == 8)
                            pos_node = node;
                    }

                    walk_llist(hllist, NULL);

                    if ((val = getp_item(hllist, 5)) == NULL) {
                        fprintf(stderr, "invalid index!..\n");
                        exit(EXIT_FAILURE);
                    }

                    printf("%d\n", *val);

                    remove_next(hllist, pos_node);
                        
                    walk_llist(hllist, NULL);

                    clear_llist(hllist);

                    for (int i = 0; i < 10; ++i) 
                        if ((node = add_tail(hllist, i)) == NULL) {
                            fprintf(stderr, "cannot add item!..\n");
                            exit(EXIT_FAILURE);
                        }
                    walk_llist(hllist, NULL);

                    destroy_llist(hllist);

                    return 0;
                }

        * Örnek 4, Tek bağlı listelerde de handle alanı içerisinde bir düğüm tutulursa özel durumlar elimine edilebilir. Ancak bunun sağlayacağı fayda çift bağlı listelerdeki gibi olmayacaktır. Çünkü tek bağlı listelerde düğüm içerisinde yalnızca next göstericisi bulunduğu
        için tail göstericisinin ayrıca handle alanında tutulması gerekecektir. Burada da son düğümün next göstericisinin artık NULL adresi değil handle alanındaki düğümü göstermesi gerekir. Tabii işin başında hem handle alanındaki düğümün next göstericisi hem de tail
        göstericisi handle alanındaki düğümün kendisini göstermlidir. Bu tasarımda handla alanı aşağıdaki gibi oluşturuabilir:

            typedef struct tagNODE {
                DATATYPE val;
                struct tagNODE *next;
            } NODE;

            typedef struct tagLLIST {
                NODE head;
                NODE *tail;
                size_t count;
            } LLIST, *HLLIST;

        Yapının head elemanının bir gösterici olmadığına NODE nesnesi olduğuna dikkat ediniz. Aşağıda bu tasarıma ilişkin bir örnek verilmiştir. 
            /* llist.h */
                #ifndef LLIST_H_
                #define LLIST_H_

                #include <stddef.h>
                #include <stdbool.h>

                /* Type Declarations  */

                typedef int DATATYPE;

                typedef struct tagNODE {
                    DATATYPE val;
                    struct tagNODE *next;
                } NODE;

                typedef struct tagLLIST {
                    NODE head;
                    NODE *tail;
                    size_t count;
                } LLIST, *HLLIST;

                /* Function Prototypes */

                HLLIST create_llist(void);
                NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val);
                NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val);
                NODE *add_tail(HLLIST hllist, DATATYPE val);
                NODE *addp_tail(HLLIST hllist, const DATATYPE *val);
                NODE *add_head(HLLIST hllist, DATATYPE val);
                NODE *addp_head(HLLIST hllist, const DATATYPE *val);
                void remove_next(HLLIST hllist, NODE *node);
                void remove_head(HLLIST hllist);
                DATATYPE *getp_item(HLLIST hllist, size_t index);
                bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *));
                void clear_llist(HLLIST hllist);
                void destroy_llist(HLLIST hllist);

                /* inline Function Definitions */

                static inline size_t count_llist(HLLIST hllist)
                {
                    return hllist->count;
                }

                #endif

            /* llist.c */
                #include <stdio.h>
                #include <stdlib.h>
                #include "llist.h"

                /* static Functions Prototypes */

                static bool disp(DATATYPE *val);

                /* Function Definitions */

                HLLIST create_llist(void)
                {
                    HLLIST hllist;

                    if ((hllist = (HLLIST)malloc(sizeof(LLIST))) == NULL)
                        return NULL;

                    hllist->head.next = &hllist->head;
                    hllist->tail = &hllist->head;
                    hllist->count = 0;

                    return hllist;
                }

                NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = val;

                    if (node == hllist->tail)
                        hllist->tail = new_node;
                    new_node->next = node->next;
                    node->next = new_node;

                    ++hllist->count;

                    return new_node;
                }

                NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = *val;

                    if (node == hllist->tail)
                        hllist->tail = new_node;
                    new_node->next = node->next;
                    node->next = new_node;

                    ++hllist->count;

                    return new_node;

                }

                NODE *add_tail(HLLIST hllist, DATATYPE val)
                {
                    return insert_next(hllist, hllist->tail, val);
                }

                NODE *addp_tail(HLLIST hllist, const DATATYPE *val)
                {
                    return insertp_next(hllist, hllist->tail, val);
                }

                NODE *add_head(HLLIST hllist, DATATYPE val)
                {
                    return insert_next(hllist, &hllist->head, val);
                }

                NODE *addp_head(HLLIST hllist, const DATATYPE *val)
                {
                    return insertp_next(hllist, &hllist->head, val);
                }

                void remove_next(HLLIST hllist, NODE *node)
                {
                    NODE *next_node;

                    if (node == hllist->tail)
                        return;

                    if (node->next == hllist->tail)
                        hllist->tail = node;

                    next_node = node->next;
                    node->next = next_node->next;

                    --hllist->count;

                    free(next_node);
                }

                void remove_head(HLLIST hllist)
                {
                    remove_next(hllist, &hllist->head);
                }

                DATATYPE *getp_item(HLLIST hllist, size_t index)
                {
                    NODE *node;

                    if (index >= hllist->count)
                        return NULL;

                    node = hllist->head.next;
                    for (size_t i = 0; i < index; ++i)
                        node = node->next;

                    return &node->val;
                }

                bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *))
                {
                    bool retval = true;
                    bool def_flag = false;

                    if (proc == NULL) {
                        proc = disp;
                        def_flag = true;
                    }

                    for (NODE *node = hllist->head.next; node != &hllist->head; node = node->next)
                        if (!proc(&node->val)) {
                            retval = false;
                            break;
                        }

                    if (def_flag)
                        putchar('\n');

                    return retval;
                }

                void clear_llist(HLLIST hllist)
                {
                    NODE *node, *temp_node;

                    node = hllist->head.next;
                    while (node != &hllist->head) {
                        temp_node = node->next;
                        free(node);
                        node = temp_node;
                    }

                    hllist->head.next = &hllist->head;
                    hllist->tail = &hllist->head;
                    hllist->count = 0;
                }

                void destroy_llist(HLLIST hllist)
                {
                    NODE *node, *temp_node;

                    node = hllist->head.next;
                    while (node != &hllist->head) {
                        temp_node = node->next;
                        free(node);
                        node = temp_node;
                    }

                    free(hllist);
                }

                static bool disp(DATATYPE *val)
                {
                    printf("%d ", *val);
                    fflush(stdout);

                    return true;
                }

            /* app.c */
                #include <stdio.h>
                #include <stdlib.h>
                #include "llist.h"

                int main(void)
                {
                    HLLIST hllist;
                    NODE *node, *pos_node;
                    int *val;

                    if ((hllist = create_llist()) == NULL) {
                        fprintf(stderr, "cannot create linked list...\n");
                        exit(EXIT_FAILURE);
                    }

                    for (int i = 0; i < 10; ++i) {
                        if ((node = add_tail(hllist, i)) == NULL) {
                            fprintf(stderr, "cannot add item!..\n");
                            exit(EXIT_FAILURE);
                        }
                        if (i == 5)
                            pos_node = node;
                    }

                    walk_llist(hllist, NULL);

                    if ((val = getp_item(hllist, 5)) == NULL) {
                        fprintf(stderr, "invalid index!..\n");
                        exit(EXIT_FAILURE);
                    }

                    printf("%d\n", *val);

                    remove_next(hllist, pos_node);

                    walk_llist(hllist, NULL);

                    remove_head(hllist);

                    walk_llist(hllist, NULL);

                    clear_llist(hllist);

                    for (int i = 0; i < 10; ++i) 
                        if ((node = add_tail(hllist, i)) == NULL) {
                            fprintf(stderr, "cannot add item!..\n");
                            exit(EXIT_FAILURE);
                        }
                    walk_llist(hllist, NULL);

                    destroy_llist(hllist);
                    
                    return 0;
                }

        * Örnek 5, Tabii bağlı listenin tuttuğu elemanlar (yani DATATYPE türü) int yerine başka türlerden de olabilir. Eğer DATATYPE türü bir yapı ise fonksiyonların p'li versiyonlarını kullanmak daha uygun olacaktır. Aşağıdaki tek bağlı liste örneğinde DATATYPE bir yapı
        biçiminde oluşturulmuştur. 
            /* llist.h */
                #ifndef LLIST_H_
                #define LLIST_H_

                #include <stddef.h>
                #include <stdbool.h>

                /* Type Declarations  */

                typedef struct tagPERSON {
                    char name[32];
                    int no;
                } PERSON;

                typedef PERSON DATATYPE;

                typedef struct tagNODE {
                    DATATYPE val;
                    struct tagNODE *next;
                } NODE;

                typedef struct tagLLIST {
                    NODE head;
                    NODE *tail;
                    size_t count;
                } LLIST, *HLLIST;

                /* Function Prototypes */

                HLLIST create_llist(void);
                NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val);
                NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val);
                NODE *add_tail(HLLIST hllist, DATATYPE val);
                NODE *addp_tail(HLLIST hllist, const DATATYPE *val);
                NODE *add_head(HLLIST hllist, DATATYPE val);
                NODE *addp_head(HLLIST hllist, const DATATYPE *val);
                void remove_next(HLLIST hllist, NODE *node);
                void remove_head(HLLIST hllist);
                DATATYPE *getp_item(HLLIST hllist, size_t index);
                bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *));
                void clear_llist(HLLIST hllist);
                void destroy_llist(HLLIST hllist);

                /* inline Function Definitions */

                static inline size_t count_llist(HLLIST hllist)
                {
                    return hllist->count;
                }

                #endif

            /* llist.c */
                #include <stdio.h>
                #include <stdlib.h>
                #include "llist.h"

                /* static Functions Prototypes */

                static bool disp(DATATYPE *node);

                /* Function Definitions */

                HLLIST create_llist(void)
                {
                    HLLIST hllist;

                    if ((hllist = (HLLIST)malloc(sizeof(LLIST))) == NULL)
                        return NULL;

                    hllist->head.next = &hllist->head;
                    hllist->tail = &hllist->head;
                    hllist->count = 0;

                    return hllist;
                }

                NODE *insert_next(HLLIST hllist, NODE *node, DATATYPE val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = val;

                    if (node == hllist->tail)
                        hllist->tail = new_node;
                    new_node->next = node->next;
                    node->next = new_node;

                    ++hllist->count;

                    return new_node;
                }

                NODE *insertp_next(HLLIST hllist, NODE *node, const DATATYPE *val)
                {
                    NODE *new_node;

                    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                        return NULL;
                    new_node->val = *val;

                    if (node == hllist->tail)
                        hllist->tail = new_node;
                    new_node->next = node->next;
                    node->next = new_node;

                    ++hllist->count;

                    return new_node;

                }

                NODE *add_tail(HLLIST hllist, DATATYPE val)
                {
                    return insert_next(hllist, hllist->tail, val);
                }

                NODE *addp_tail(HLLIST hllist, const DATATYPE *val)
                {
                    return insertp_next(hllist, hllist->tail, val);
                }

                NODE *add_head(HLLIST hllist, DATATYPE val)
                {
                    return insert_next(hllist, &hllist->head, val);
                }

                NODE *addp_head(HLLIST hllist, const DATATYPE *val)
                {
                    return insertp_next(hllist, &hllist->head, val);
                }

                void remove_next(HLLIST hllist, NODE *node)
                {
                    NODE *next_node;

                    if (node == hllist->tail)
                        return;

                    if (node->next == hllist->tail)
                        hllist->tail = node;

                    next_node = node->next;
                    node->next = next_node->next;

                    --hllist->count;

                    free(next_node);
                }

                void remove_head(HLLIST hllist)
                {
                    remove_next(hllist, &hllist->head);
                }

                DATATYPE *getp_item(HLLIST hllist, size_t index)
                {
                    NODE *node;

                    if (index >= hllist->count)
                        return NULL;

                    node = hllist->head.next;
                    for (size_t i = 0; i < index; ++i)
                        node = node->next;

                    return &node->val;
                }

                bool walk_llist(HLLIST hllist, bool (*proc)(DATATYPE *))
                {
                    bool retval = true;
                    bool def_flag = false;

                    if (proc == NULL) {
                        proc = disp;
                        def_flag = true;
                    }

                    for (NODE *node = hllist->head.next; node != &hllist->head; node = node->next)
                        if (!proc(&node->val)) {
                            retval = false;
                            break;
                        }

                    if (def_flag)
                        putchar('\n');

                    return retval;
                }

                void clear_llist(HLLIST hllist)
                {
                    NODE *node, *temp_node;

                    node = hllist->head.next;
                    while (node != &hllist->head) {
                        temp_node = node->next;
                        free(node);
                        node = temp_node;
                    }

                    hllist->head.next = &hllist->head;
                    hllist->tail = &hllist->head;
                    hllist->count = 0;
                }

                void destroy_llist(HLLIST hllist)
                {
                    NODE *node, *temp_node;

                    node = hllist->head.next;
                    while (node != &hllist->head) {
                        temp_node = node->next;
                        free(node);
                        node = temp_node;
                    }
                    
                    free(hllist);
                }

                static bool disp(DATATYPE *val)
                {
                    printf("%s, %d\n", val->name, val->no);
                    fflush(stdout);

                    return true;
                }

            /* app.c */
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <stdbool.h>
                #include "llist.h"

                bool disp_person(PERSON *per);
                void clear_stdin(void);

                int main(void)
                {
                    HLLIST hllist;
                    PERSON per;
                    char *str;
                    
                    if ((hllist = create_llist()) == NULL) {
                        fprintf(stderr, "cannot create linked list...\n");
                        exit(EXIT_FAILURE);
                    }

                    for (;;) {
                        printf("Adi soyadi:");
                        if (fgets(per.name, 32, stdin) == NULL)
                            continue;
                        if ((str = strchr(per.name, '\n')) != NULL)
                            *str = '\0';
                        if (!strcmp(per.name, "quit"))
                            break;
                        printf("No:");
                        scanf("%d", &per.no);
                        clear_stdin();

                        addp_tail(hllist, &per);
                    }

                    walk_llist(hllist, disp_person);
                    
                    destroy_llist(hllist);

                    return 0;
                }
                bool disp_person(PERSON *per)
                {
                    printf("%s, %d\n", per->name, per->no);

                    return true;
                }


                void clear_stdin(void)
                {
                    int ch;

                    while ((ch = getchar()) != '\n' && ch != EOF)
                        ;
                }

    >> Çok karşılaşılan diğer bir veri yapısı da "kuyruk (queue)" veri yapısıdır. Kuyruklar FIFO ve LIFO olmak üzere ikiye ayrılmaktadır.
        >>> Ancak kuyruk denildiğinde default olarak FIFO kuyruklar anlaşılmaktadır. Kuyruk veri yapısında iki eylem vardır: Kuyruğua eleman yerleştirmek ve kuyruktan eleman almak. Kuyruğun arasına eleman insert etmenin bir anlamı yoktur. Aradan eleman silmenin de bir
        anlamı yoktur. Kuyruklara yalnızca eleman yerleştirilip kuyruklardan yalnızca eleman alınmaktadır. FIFO kuyruk sistemine eleman yerleştirileceği zaman eleman her zaman sona yerleştirilmektedir. Bu kuyruk sisteminden eleman alınacağı zaman eleman baştan alınmaktadır.
        FIFO kuyruk sistemleri gerçek hayatta çokça karşımıza çıkmaktadır. Örneğin gerçek hayattaki kuyrukların çoğu bir FIFO kuyruk sistemidir. Yemekhanede kuyruğun sonuna gireriz. Kuyruğun başındaki kişiye yemek verilir. Bu yönüyle FIFO kuyruk sistemi adil bir kuyruk
        sistemidir. FIFO kuyruk sistemleri "bilgilerin sırası bozulmadan geçici olarak bekletileceği" durumlarda kullanılmaktadır. Yani tampon sistemleri genellikle FIFO kuyruk sistemi biçiminde oluşturulmaktadır. Örneğin bir yerden bilgi geliyor olsun. Bu bilgiyi o anda
        işleyemiyor olalım. O zaman gelen bilgiyi geçici süre bir FIFO kuyruk sisteminde tutabiliriz. Daha sonra oradan alarak geldiği sırada işleyebiliriz. Aslında daha önce görmüş olduğumuz borularda bir FIFO kuyruk sistemi ile gerçekleştirilmektedir. Örneğin boruya bir
        şey yazıldığında bu şeyler borunun sonuna yazılır. Biz de boruyu okuduğumuzda başındakileri alırız. Kuyruk sistemine eleman yerleştirmeye İngilizce genellikle "put" ya da "enqueue" işlemi denilmektedir. Kuyruktan eleman alamaya da İngilizce genellikle "get" ya da
        "dequeue" işlemi denilmektedir. Kuyruk sistemlerinin bir uzunlukları olabilir. Kuyruk dolduğunda artık kuyruğa put yapılamamaktadır. Benzer biçimde kuruk tamamen boşaldığında artık "get" yapılamamaktadır. FIFO kuyruk sistemlerinin gerçekleştirilmesi için üç
        yöntem kullanılmaktadır:

            -> Dizi Kaydırması Yöntemi: Bu yöntem ilk akla gelen yöntemdir. Ancak diğer yöntemlerden bariz kötü olduğu için tercih edilmemektedir. Bu yöntemde kuyruk için bir dizi yaratılır. Dizinin sonu (elemanların bittiği yer dizinin gerçek sonu değil) bir indeksle
            ya da gösterici ile tutulur. Örneğin:

                abcdexxxxxxxxxxxxx
                    ^ 

            Burada a, b, c, d, e kuruktaki elemanları x'ler ise dizide henüz kullanılmayan boşi alanları belirtmektedir. Bu yöntemde kuyuğa eleman ekleneceği zaman sona ekleme yapılır. Örneğin:

                abcdefxxxxxxxxxxxx
                    ^ 

            Kuyruktan eleman alınacağı zaman eleman kuruğun başından alınır ve kuyruktaki elemanlar bir kaydırılır. Örneğin;

                bcdefxxxxxxxxxxxx
                    ^ 

            Bu tasarımda kuyuğa eleman yerleştirmek O(1) karmaşıklıktayken kuyruktan eleman almak O(N) karmaşıklıktadır. 

            -> İndeks Kaydırması Yöntemi: En çok kullanılan yöntemlerden biridir. Bu yöntemde kuyruğun başı ve sonu iki indeks ya da gösterici ile tutturulur. Kuruğun bgaşını gösteren indeks ya da göstericiye genellikle İngilizce "head" göstericisi, kuyrun sonunu gösteren
            indeks ya da göstericiye de "tail" göstericisi denilmektedir. Örneğin:

                xxxxabcdefgxxxxxx
                    ^(h)   ^(t)

            Eleman tail göstericisinin gösterdeiği yere yerleştirilir ve tail göstericisi 1 artırılır. Ancak eğer tail göstericisi dizinin sonuna gelmişse yeniden başa geçirilir. Örneğin:

                xxxxabcdefghxxxxxxx
                    ^(h)    ^(t)

            Eleman head göstericisinin gösteridği yerden alınır ve head göstericisi 1 artırılır. Tabii yine head göstericisi kuyruğun sonuna geldiğinde yeniden başa geçirilir. Bu yöntemde head ve tail göstericileri aynı yeri gösteriyorsa ya kuyruk tamamen doludur ya da
            kuyruk tamamen boştur. Genellikle kuyruktaki eleman sayısı da bir değişkenle tutulmaktadır. Kuyruğun tam dolu ya da tam boş olduğuna bu değişkene bakılarak karar verilir. Bu yöntemde eleman ekleme de eleman alma da O(1) karmaşıklıkta yapılabilmektedir. İndeks
            kaydırma yönteminde kuyruk dolduğunda tıpkı dinamik dizilerde olduğu gibi kuyruk büyütülebilir. Ancak kuyruğun büyütülüp büyütülmeyeceği uygulamadan uygulamaya değişebilmektedir. 
                * Örnek 1, Aşağda indeks kaydırma yöntemiyle bir kuyruk sistemi oluşturulmuştur. Kuyruk bilgileri aşağdaki yapıyla temsil edilmiştir:
	
                    typedef struct tagQUEUE {
                        DATATYPE *queue;
                        size_t head;
                        size_t tail;
                        size_t size;
                        size_t count;
                    } QUEUE, *HQUEUE;

                Handle alanı içerisinde kuyruk verilerinin bulunduğu dizi, head ve tail indeksleri, kuyruğun toplam uzunluğu ve kuyruktaki dolu elemanların sayısının tutulduuna dikkat ediniz. 
                    /* queue.h */
                        #ifndef QUEUE_H_
                        #define QUEUE_H_

                        #include <stddef.h>
                        #include <stdbool.h>

                        typedef int DATATYPE;

                        typedef struct tagQUEUE {
                            DATATYPE *queue;
                            size_t head;
                            size_t tail;
                            size_t size;
                            size_t count;
                        } QUEUE, *HQUEUE;

                        /* Function Prototypes */

                        HQUEUE create_queue(size_t size);
                        bool put_queue(HQUEUE hqueue, DATATYPE val);
                        bool putp_queue(HQUEUE hqueue, const DATATYPE *val);
                        bool get_queue(HQUEUE hqueue, DATATYPE *val);
                        bool resize_queue(HQUEUE hqueue, size_t newsize);
                        void clear_queue(HQUEUE hqueue);
                        void destroy_queue(HQUEUE hqueue);

                        /* inline Function Definitions */

                        static inline bool isempty_queue(HQUEUE hqueue)
                        {
                            return hqueue->count == 0;
                        }

                        static inline bool count_queue(HQUEUE hqueue)
                        {
                            return hqueue->count;
                        }

                        #endif

                    /* queue.c */
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include "queue.h"

                        HQUEUE create_queue(size_t size)
                        {
                            HQUEUE hqueue;

                            if ((hqueue = (HQUEUE)malloc(sizeof(QUEUE))) == NULL)
                                return NULL;

                            if ((hqueue->queue = (DATATYPE *)malloc(sizeof(DATATYPE) * size)) == NULL) {
                                free(hqueue);
                                return NULL;
                            }

                            hqueue->head = hqueue->tail = 0;
                            hqueue->size = size;
                            hqueue->count = 0;

                            return hqueue;
                        }

                        bool put_queue(HQUEUE hqueue, DATATYPE val)
                        {
                            if (hqueue->count == hqueue->size)
                                return false;

                            hqueue->queue[hqueue->tail++] = val;
                            hqueue->tail %= hqueue->size;
                            ++hqueue->count;

                            return true;
                        }

                        bool putp_queue(HQUEUE hqueue, const DATATYPE *val)
                        {
                            if (hqueue->count == hqueue->size)
                                return false;

                            hqueue->queue[hqueue->tail++] = *val;
                            hqueue->tail %= hqueue->size;
                            ++hqueue->count;

                            return true;
                        }

                        bool get_queue(HQUEUE hqueue, DATATYPE *val)
                        {
                            if (hqueue->count == 0)
                                return false;

                            *val = hqueue->queue[hqueue->head++];
                            hqueue->head %= hqueue->size;
                            --hqueue->count;

                            return true;
                        }

                        bool resize_queue(HQUEUE hqueue, size_t newsize)
                        {
                            DATATYPE *new_queue;
                            
                            if (newsize <= hqueue->size)
                                return false;

                            if ((new_queue = (DATATYPE *)malloc(newsize * sizeof(DATATYPE))) == NULL)
                                return false;

                            for (size_t i = 0, head = hqueue->head; i < hqueue->size; ++i) {
                                new_queue[i] = hqueue->queue[head++];
                                head %= hqueue->size;
                            }

                            hqueue->head = 0;
                            hqueue->tail = hqueue->count;
                            hqueue->size = newsize;

                            free(hqueue->queue);

                            hqueue->queue = new_queue;

                            return true;
                        }

                        void clear_queue(HQUEUE hqueue)
                        {
                            hqueue->count = 0;
                            hqueue->head = 0;
                            hqueue->tail = 0;
                        }

                        void destroy_queue(HQUEUE hqueue)
                        {
                            free(hqueue->queue);
                            free(hqueue);
                        }

                    /* app.c */
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include "queue.h"

                        int main(void)
                        {
                            HQUEUE hqueue;
                            DATATYPE val;

                            if ((hqueue = create_queue(10)) == NULL) {
                                fprintf(stderr, "cannot create queue!..\n");
                                exit(EXIT_FAILURE);
                            }

                            for (int i = 0; i < 8; ++i)
                                if (!put_queue(hqueue, i)) {
                                    fprintf(stderr, "cannot put queue!..\n");
                                    exit(EXIT_FAILURE);
                                }

                            for (int i = 0; i < 5; ++i)
                                get_queue(hqueue, &val);

                            if (!resize_queue(hqueue, 20)) {
                                fprintf(stderr, "cannot resize queue!..\n");
                                exit(EXIT_FAILURE);
                            }

                            for (int i = 0; i < 15; ++i)
                                if (!put_queue(hqueue, i)) {
                                    fprintf(stderr, "cannot put queue!..\n");
                                    exit(EXIT_FAILURE);
                                }

                            while (!isempty_queue(hqueue)) {
                                get_queue(hqueue, &val);
                                printf("%d ", val);
                                fflush(stdout);
                            }

                            destroy_queue(hqueue);
                                    
                            return 0;
                        }

            -> Bağlı Liste Yöntemi: Bu yöntemde bir bağlı liste oluşturulur. Eleman bağlı listenin sonuna eklenir ve başından alınır. Bağlı liste tek bağlı liste biçiminde oluşturulabilir. Bu yöntemde sanki eleman ekleme ve alma O(1) karmaşıklıkta yapılıyormuş gibi gözükse
            de eğer elemanlar dinamik olarak tahsis edilip free edeilecekse genellikle bu işlemler O(N) karmaşıklıkta yapılmaktadır. (Tabii O(1) karmaşıklıkta çalışan tahsisat algoritmaları da vardır. Ancak Windows ve UNIX/Linux sistemlerindeki malloc ve free algoritmaları
            O(N) karmaşıklıkta gerçekleştirilmiştir. Bu yöntemin avantajı baştan kuyruk uzunluğunun belirli olmasına gerek kalmamasıdır.) 
                * Örnek 1, Aşağıdaki örnekte FIFO kuyruk bağlı liste yöntemi gerçekleştirilmiştir. Bu örnekte handle alanı aşağıdaki gibi bir yapı ile temsil edilmiştir:

                    typedef struct tagNODE {
                        DATATYPE val;
                        struct tagNODE *next;
                    } NODE;

                    typedef struct tagQUEUE {
                        NODE *head;
                        NODE *tail;
                        size_t count;
                    } QUEUE, *HQUEUE;

                Handle alanı içerisinde tek bağlı listenin head ve tail düğümleri ve kuyruktaki eleman sayısı tutulmuştur. Örneğimizde kuyruğa eleman yerleştirirken bağlı listenin sonuna elemanı ekledik. Kuyruktan eleman alınırken de bağlı listenin başından elemanı aldık.
                    /* queue.h */
                        #ifndef QUEUE_H_
                        #define QUEUE_H_

                        #include <stddef.h>
                        #include <stdbool.h>

                        typedef int DATATYPE;

                        typedef struct tagNODE {
                            DATATYPE val;
                            struct tagNODE *next;
                        } NODE;

                        typedef struct tagQUEUE {
                            NODE *head;
                            NODE *tail;
                            size_t count;
                        } QUEUE, *HQUEUE;

                        /* Function Prototypes */

                        HQUEUE create_queue(voids);
                        bool put_queue(HQUEUE hqueue, DATATYPE val);
                        bool putp_queue(HQUEUE hqueue, const DATATYPE *val);
                        bool get_queue(HQUEUE hqueue, DATATYPE *val);
                        void clear_queue(HQUEUE hqueue);
                        void destroy_queue(HQUEUE hqueue);

                        /* inline Function Definitions */

                        static inline bool isempty_queue(HQUEUE hqueue)
                        {
                            return hqueue->count == 0;
                        }

                        static inline bool count_queue(HQUEUE hqueue)
                        {
                            return hqueue->count;
                        }

                        #endif

                    /* queue.c */
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include "queue.h"

                        HQUEUE create_queue(void)
                        {
                            HQUEUE hqueue;

                            if ((hqueue = (HQUEUE)malloc(sizeof(QUEUE))) == NULL)
                                return NULL;

                            hqueue->head = hqueue->tail = NULL;
                            hqueue->count = 0;

                            return hqueue;
                        }

                        bool put_queue(HQUEUE hqueue, DATATYPE val)
                        {
                            NODE *new_node;

                            if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                                return false;
                            new_node->val = val;
                            new_node->next = NULL;

                            if (hqueue->tail != NULL)
                                hqueue->tail->next = new_node;
                            else
                                hqueue->head = new_node;

                            hqueue->tail = new_node;
                            ++hqueue->count;

                            return true;
                        }

                        bool putp_queue(HQUEUE hqueue, const DATATYPE *val)
                        {
                            NODE *new_node;

                            if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                                return false;
                            new_node->val = *val;
                            new_node->next = NULL;

                            if (hqueue->tail != NULL)
                                hqueue->tail->next = new_node;
                            else
                                hqueue->head = new_node;

                            hqueue->tail = new_node;
                            ++hqueue->count;

                            return true;
                        }
                        
                        bool get_queue(HQUEUE hqueue, DATATYPE *val)
                        {
                            NODE *node;

                            if (hqueue->head == NULL)
                                return false;

                            node = hqueue->head;
                            *val = node->val;

                            if (node->next == NULL)
                                hqueue->tail = NULL;

                            hqueue->head = node->next;

                            --hqueue->count;

                            free(node);

                            return true;
                        }

                        void clear_queue(HQUEUE hqueue)
                        {
                            NODE *node, *temp_node;

                            node = hqueue->head;

                            while (node != NULL) {
                                temp_node = node->next;
                                free(node);
                                node = temp_node;
                            }

                            hqueue->head = hqueue->tail = NULL;
                            hqueue->count = 0;
                        }

                        void destroy_queue(HQUEUE hqueue)
                        {
                            NODE *node, *temp_node;

                            node = hqueue->head;

                            while (node != NULL) {
                                temp_node = node->next;
                                free(node);
                                node = temp_node;
                            }

                            free(hqueue);
                        }

                    /* app.c */
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include "queue.h"

                        int main(void)
                        {
                            HQUEUE hqueue;
                            DATATYPE val;

                            if ((hqueue = create_queue(10)) == NULL) {
                                fprintf(stderr, "cannot create queue!..\n");
                                exit(EXIT_FAILURE);
                            }

                            for (int i = 0; i < 8; ++i)
                                if (!put_queue(hqueue, i)) {
                                    fprintf(stderr, "cannot put queue!..\n");
                                    exit(EXIT_FAILURE);
                                }

                            for (int i = 0; i < 15; ++i)
                                if (!put_queue(hqueue, i)) {
                                    fprintf(stderr, "cannot put queue!..\n");
                                    exit(EXIT_FAILURE);
                                }

                            while (!isempty_queue(hqueue)) {
                                get_queue(hqueue, &val);
                                printf("%d ", val);
                                fflush(stdout);
                            }

                            destroy_queue(hqueue);
                                    
                            return 0;
                        }

        >>> LIFO (Last In First Out) kuyruk sistemlerine "Stack Veri Yapısı" da denilmektedir. Stack veri yapısında yine iki eylem vardır. Stack'e eleman eklemek ve stack'ten eleman almak. Geleneksel olarak stack'e eleman yerleştirmeye "push" işlemi, stack'ten eleman
        almaya da "pop" işlemi denilmektedir. LIFO kuyruk sistemleri FIFO kuyruk sistemlerine göre daha seyrek kullanılmaktadır. Dış dünyada seyrek de olsa stack sistemleriyle karşılaşılmaktadır. Örneğin:

            -> Tabaklar üst üste konulduğunda en üsttek ilk alınmaktadır.
            -> Asansöre son binen çoğu kez ilk inmektedir.
            -> Bazı oyun programlarında oyun kağıtları üst üste yere atıldığında oyuncular son atılan kağıdı yerden alabilmektedir. 

        Bilgisayar dünyasında da stack sistemleriyle karşılaşılmaktadır. Örneğin "undo mekanizması" stack veri yapısıyla gerçekleştirilmektedir. Yani örneğin biz bir editörde birtakım şeyler yaptıktan sonra "Ctrl+Z" tuşlarına basarsak son yapılandna ilk yapılana doğru
        eylemler geri alınmaktadır. Mikroişlemciler de stack sistemini fonksiyon çağrılarında ve yerel değişkenleri depolamada kullanmaktadır. Örneğin birkaç fonksiyon peşi sıra çağrıldığında geri dönüşler son çağırmadan ilk çağırmaya doğru yapılmaktadır. Parsing
        algoritmalarında stack veri yapısı yoğun olarak kullanılmaktadır. Örneğin RPN (Rverse Polish Notation) hesap makineleri stack veri yapısı kullanmaktadır. Stack bir bilgiyi ters yüz etmek için kullanılabilir. Stack veri yapısı yine "dizi yoluyla" ya da "bağlı
        liste yoluyla" gerçekleştirilebilmektedir. Dizi gerçekleştiriminde belli uzunlukta bir dizi yaratılır. Stack'in aktif noktası bir göstericiyle (ya da indeksle) belirlenir. Stack'in aktif noktasını tutan bu göstericiye geleneksel olarak "stack göstericisi
        (stack pointer)" denilmektedir. Başlangıçta stack boştur. Stack göstericisi dizinin soununu göstermektedir. Örneğin:

                    x
                    x
                    x
                    x
                    x
            SP -->

        Push işleminde stack göstericisi önce bir azaltılır. Sonra push edilecek değer göstericisinin gösterdiği yere yerleştirilir. Örneğin, a değerini yukarıdaki stack'e yerleştirelim:

                    x
                    x
                    x
                    x
                    x
            SP ---> a
        
        Şimdi de b değerine stack'e push edelim:

                    x
                    x
                    x
                    x
            SP --->	b
                    a
        
        Şmdi de c değerini push edelim:

                    x
                    x
                    x
            SP --->	c
                    b
                    a
        
        Pop işleminde tam tersi yapılır. Yani Stack göstericisinin gösterdiği yerdne bilgi alınır ve stack göstericisi 1 ilerletilir. Örneğin yukarıdaki durumda pop işlemi yapalım:

                    x
                    x
                    x
                    c
            SP --->	b
                    a
        
        Şimdi bir daha pop yapalım:

                    x
                    x
                    x
                    c
                    b
            SP --->	a
        
        Eğer stack uzunluğundan daha fazla psuh işlemi yapılırsa (yani stack doluyken push işlemi yapılırsa) stack için ayrılan alanı yukarından taşırmış oluruz. Bu duruma geleneksel olarak "stack'in yukarıdan taşması (stack overflow)" denilmektedir. eğer çok fazla pop
        işlemi yaparsak (yani boş bir stack'ta pop işlemi yaparsak) bu durumda stack için ayrılan diziyi aşağıdan taşırmış oluruz. Buna da geleneksel olarak "stack underflow" denilmektedir. Stack sistemleri tek bağlı listelerle de gerçekleştirilebilir. Bir bağlı listenin
        elemanlar önünne eklenip öününden alınırsa zaten bu stack olur. 
            * Örnek 1, Aşağıda stack veri yapısının dizi kullanılarak gerçekleştirimine bir örnek verilmiştir. Bu örnekte stack veri yapısı (handle alanı) STACK isimli bir yapı ile temsil edilmiştir:

                typedef struct tagSTACK {
                    DATATYPE *stack;
                    DATATYPE *sp;
                    size_t size;
                    size_t count;
                } STACK, *HSTACK;

            Yapı içerisinde stack için kullanılacak dizinin başlangıç adresi, stack göstericinin durumu, stack dizinin uzunluğu ve stack'teki eleman sayısı tutulmuştur.
                /* stack.h */
                    #ifndef STACK_H_
                    #define STACK_H_

                    #include <stddef.h>
                    #include <stdbool.h>

                    typedef int DATATYPE;

                    typedef struct tagSTACK {
                        DATATYPE *stack;
                        DATATYPE *sp;
                        size_t size;
                        size_t count;
                    } STACK, *HSTACK;

                    /* Function Prototypes */

                    HSTACK create_stack(size_t size);
                    bool push_stack(HSTACK hstack, DATATYPE val);
                    bool pushp_stack(HSTACK hstack, const DATATYPE *val);
                    bool pop_stack(HSTACK hstack, DATATYPE *val);
                    void clear_stack(HSTACK hstack);
                    void destroy_stack(HSTACK hstack);

                    /* inline Function Definitions */

                    static inline size_t count_stack(HSTACK hstack)
                    {
                        return hstack->count;
                    }

                    static inline bool isempty_stack(HSTACK hstack)
                    {
                        return hstack->count == 0;
                    }

                    #endif

                /* stack.c */
                    #include <stdio.h>
                    #include <stdlib.h>
                    #include "stack.h"

                    HSTACK create_stack(size_t size)
                    {
                        HSTACK hstack;

                        if ((hstack = (HSTACK)malloc(sizeof(STACK))) == NULL)
                            return NULL;

                        if ((hstack->stack = (DATATYPE *)malloc(sizeof(DATATYPE) * size)) == NULL) {
                            free(hstack);
                            return NULL;
                        }

                        hstack->sp = hstack->stack + size;
                        hstack->size = size;
                        hstack->count = 0;

                        return hstack;
                    }

                    bool push_stack(HSTACK hstack, DATATYPE val)
                    {
                        if (hstack->count >= hstack->size)
                            return false;

                        *--hstack->sp = val;
                        ++hstack->count;

                        return true;
                    }

                    bool pushp_stack(HSTACK hstack,const DATATYPE *val)
                    {
                        if (hstack->count >= hstack->size)
                            return false;

                        *--hstack->sp = *val;
                        ++hstack->count;

                        return true;
                    }

                    bool pop_stack(HSTACK hstack, DATATYPE *val)
                    {
                        if (hstack->count == 0)
                            return false;

                        *val = *hstack->sp++;
                        --hstack->count;

                        return true;
                    }

                    void clear_stack(HSTACK hstack)
                    {
                        hstack->sp = hstack->stack + hstack->size;
                        hstack->count = 0;
                    }

                    void destroy_stack(HSTACK hstack)
                    {
                        free(hstack->stack);
                        free(hstack);
                    }

                /* app.c */
                    #include <stdio.h>
                    #include <stdlib.h>
                    #include "stack.h"

                    int main(void)
                    {
                        HSTACK hstack;
                        DATATYPE val;

                        if ((hstack = create_stack(10)) == NULL) {
                            fprintf(stderr, "cannot create stack!..\n");
                            exit(EXIT_FAILURE);
                        }

                        for (int i = 0; i < 10; ++i)
                            if (!push_stack(hstack, i)) {
                                fprintf(stderr, "cannot push stack!..\n");
                                exit(EXIT_FAILURE);
                            }

                        while (!isempty_stack(hstack)) {
                            pop_stack(hstack, &val);
                            printf("%d ", val);
                            fflush(stdout);
                        }
                        printf("\n");

                        destroy_stack(hstack);

                        return 0;
                    }

            * Örnek 2, Aşağıda stack veri yapısının tek bağlı liste ile gerçekleştirime ilişkin bir örnek verilmiştir. Burada NODE yapısı ve handle alanını temsil eden STACK yapısı aşağıdaki gibi bildirilmiştir:

                typedef struct tagNODE {
                    DATATYPE val;
                    struct tagNODE *next;
                } NODE;

                typedef struct tagSTACK {
                    NODE *head;
                    size_t count;
                } STACK, *HSTACK;

            Bu gerçekleştirimde düğüm bağlı listenin önüne eklenip önünden alınmaktadır. Handle alanında tail göstericisinin tutulmasına gerek olmadığına dikkat ediniz. 
                /* stack.h */
                    #ifndef STACK_H_
                    #define STACK_H_

                    #include <stddef.h>
                    #include <stdbool.h>

                    typedef int DATATYPE;

                    typedef struct tagNODE {
                        DATATYPE val;
                        struct tagNODE *next;
                    } NODE;

                    typedef struct tagSTACK {
                        NODE *head;
                        size_t count;
                    } STACK, *HSTACK;

                    /* Function Prototypes */

                    HSTACK create_stack(void);
                    bool push_stack(HSTACK hstack, DATATYPE val);
                    bool pushp_stack(HSTACK hstack, const DATATYPE *val);
                    bool pop_stack(HSTACK hstack, DATATYPE *val);
                    void clear_stack(HSTACK hstack);
                    void destroy_stack(HSTACK hstack);

                    /* inline Function Definitions */

                    static inline size_t count_stack(HSTACK hstack)
                    {
                        return hstack->count;
                    }

                    static inline bool isempty_stack(HSTACK hstack)
                    {
                        return hstack->count == 0;
                    }

                    #endif

                /* stack.c */
                    #include <stdio.h>
                    #include <stdlib.h>
                    #include "stack.h"

                    HSTACK create_stack(void)
                    {
                        HSTACK hstack;

                        if ((hstack = (HSTACK)malloc(sizeof(STACK))) == NULL)
                            return NULL;

                        hstack->head = NULL;
                        hstack->count = 0;

                        return hstack;
                    }

                    bool push_stack(HSTACK hstack, DATATYPE val)
                    {
                        NODE *new_node;

                        if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                            return false;
                        new_node->val = val;

                        new_node->next = hstack->head;
                        hstack->head = new_node;
                        
                        ++hstack->count;

                        return true;
                    }

                    bool pushp_stack(HSTACK hstack,const DATATYPE *val)
                    {
                        NODE *new_node;

                        if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                            return false;
                        new_node->val = *val;

                        new_node->next = hstack->head;
                        hstack->head = new_node;

                        ++hstack->count;

                        return true;
                    }

                    bool pop_stack(HSTACK hstack, DATATYPE *val)
                    {
                        NODE *node;

                        if (hstack->head == NULL)
                            return false;

                        node = hstack->head;
                        hstack->head = node->next;
                        *val = node->val;
                        free(node);

                        --hstack->count;

                        return true;
                    }

                    void clear_stack(HSTACK hstack)
                    {
                        NODE *node, *temp_node;

                        node = hstack->head;
                        while (node != NULL) {
                            temp_node = node->next;
                            free(node);
                            node = temp_node;
                        }

                        hstack->head = NULL;
                        hstack->count = 0;
                    }

                    void destroy_stack(HSTACK hstack)
                    {
                        NODE *node, *temp_node;

                        node = hstack->head;
                        while (node != NULL) {
                            temp_node = node->next;
                            free(node);
                            node = temp_node;
                        }

                        free(hstack);
                    }

                /* app.c */
                    #include <stdio.h>
                    #include <stdlib.h>
                    #include "stack.h"

                    int main(void)
                    {
                        HSTACK hstack;
                        DATATYPE val;

                        if ((hstack = create_stack()) == NULL) {
                            fprintf(stderr, "cannot create stack!..\n");
                            exit(EXIT_FAILURE);
                        }

                        for (int i = 0; i < 10; ++i)
                            if (!push_stack(hstack, i)) {
                                fprintf(stderr, "cannot push stack!..\n");
                                exit(EXIT_FAILURE);
                            }

                        while (!isempty_stack(hstack)) {
                            pop_stack(hstack, &val);
                            printf("%d ", val);
                            fflush(stdout);
                        }
                        printf("\n");

                        for (int i = 0; i < 10; ++i)
                            if (!push_stack(hstack, i)) {
                                fprintf(stderr, "cannot push stack!..\n");
                                exit(EXIT_FAILURE);
                            }

                        while (!isempty_stack(hstack)) {
                            pop_stack(hstack, &val);
                            printf("%d ", val);
                            fflush(stdout);
                        }
                        printf("\n");

                        destroy_stack(hstack);

                        return 0;
                    }

    >> Çift Yönlü Dinamik Diziler: Diğer önemli bir veri yapısı da "çift yönlü dinamik diziler (double-ended queue)" denilen veri yapılarıdır. Çift yönlü dinamik diziler normal dinamik dizilere benzemekle birlikte bunların başına ve sonuna eleman eklenmesi, baştan ve
    sondan eleman silinmesi O(1) karmaşıklıktadır. (Halbuki normal dinamik dizilerde başa eleman eklenmesi ve baştaki elemanın silinmesi dizinin tümden kaydırılmasını gerektirdiği için O(N) karmaşlıklıktadır.) Çift yönlü dizmaik dizilere kısaca İngilizce "deque" de
    denilmektedir. Bu sözcük "deck" gibi okunmaktadır. Bazı yazarlar bu veri yapısının kısa ismi için "dequeue" ismini kullanıyorsa da bu isim "kuyruktan veri almak" anlamına gelen sözcükle aynı olduğu karışıklığa yol açmaktadır. Bu veri yaısının yaygın kısa ismi "deque"
    biçimindedir. Çift yönlü dinamik dizilerde elemana erişim yine sabit karmaşıklıkta yapılmaktadır. Araya eleman insert edilmesi ve aradan eleman silinmesi O(N) karmaşıklıktadır. O halde bu veri yapısının en önemli özelliği başa eleman eklemenin ve baştaki elemanı
    silmenin çok hızlı olmasıdır. Çift yönlü dinamik diziler pek çok kütüphanede (örneğin C++'ın Standart Kütüphanesinde) "kuyruk" ve "stack" veri yapısının gerçekleştiriminde temel bir veri yapısı olarak kullanılmaktadır. Örneğin C++ Standart Kütüphanesinde FIFO kuyruk
    sistemi "bir deque'in sonuna eleman insert edip başındaki elemanı almak" biçiminde gerçekleştirilmiştir. Bnezer biçimde "stack" veri yapısı da "deque'in başına eleman yerleştirip başından, eleman almakla gerçekleştirilmiştir. Çift yönlü dinamik diziler tipik olarak
    üç biçimde gerçekleştirilmektedir. Bu gerçekleştirimlerin etkinliği birbirine yakındır. Özel durumlar dikkat alınarak hangi gerçekleştirimin tercih edileceğine karar verilebilir. Bu gerçekleştirimler şunlardır:
        >>> İndeks Kaydırma Yöntemi ile Gerçekleştirim: Burada bir kuyruk sistemi oluşturulur. Yine kuyruğun başı ve sonu birer gösterici ya da indeks ile tutulur. Sona ekleme tail göstericisinin gösteriği yere, başa ekleme head göstericisinin gösterdiği yere yapılır.
        Diğer işlemler kuyruk sistemlerindeki gerçekleştirim ile benzerdir. Kuyruk dolduğunda yine normal dinamik dizilerde olduğu gibi iki kat artırım yoluna gidilir. Başa ve sona eleman ekleme, baştaki ve sondaki elemanın silinmesi O(1) karmaşıklıkta gerçekleştirilebilir.
        Elemana O(1) karmaşıklıkta erişilebilir. 

        >>> Dinamik Dizi Yoluyla Gerçekleştirim: Bu gerçekleştirimde bir dinamik dizi oluşturulur. Başlangıçta head ve tail göstericileri bu dinamik dizinin ortasında bir yeri gösterir. Sona eklemeler yine tail göstericisinin bulunduğu yere, başa eklemeler ise head
        göstericisinin bulunduğu yere yapılır. Yani eklemelerde tail sağa doğru, head sola doğru ilerler. Baştan eleman silinmesinde ise head sağa doğru, sondan eleman silinmesinde ise tail sola doğru ilerleyecektir. head ve tail göstericileri iki uçtan herhangi birine
        eriştiğinde dizi büyütülecektir. Bu gerçekleştirimde kullanılmayan boş alanların bulunma olasılığı artmaktadır. Bazen çift yönlü dinamik dizi yalnızca bir yöne ilerleyebilir. Yani sona ekleme ve baştan silme işlemleri yoğun olabilir. Bu durumda head ve tail
        göstericileri dizinin sonlarına yakın bölgelerde konumlanabilirler. Ancak yeniden tahsisat yapıldığında bunlar yeni uygun konumlarına taşınabilirler. 

        >>> Birden Fazla Dizinin Kullanılması Yöntemi: Bu gerçekleştirimde tek bir dizi değil belli uzunluklarda birden fazla dizi kullanılır. Örneğin her biri 64 byte uzunluğunda dizilerin kullanıldığını varsayalım. Bir dizi yetmeyince yeni bir 64 byte'lık dizi tahsis
        edilecektir. Tabii bu dizilerin adreslerinin de bir yerde saklanması gerekir. Tipik olarak bu dizilerin adresleri dinamik bir gösterici dizisinde saklanmaktadır. Tabii bu durumda bu dinamik gösterici dizisinin kaydırılması gerekecektir. Ancak bu dizi çok bütük
        olmazsa bu kaydırma önemli bir zamana yol açmayabilir. Bu gerçekleştirimde yine elemana erişim O(1) karmaşıklıkta tutulabilir. Başa ve sona eleman ekleme, baştan ve sondan eleman silme yine O(1) karmaşıkıkta yapılabilir. Ancak eleman ekleme sırasında dizilerin
        adreslerini tutan dizide kaydırmalar söz konusu olabilecektir. Bu nedenle eleman ekleme ve silme işlemi aslında tam O(1) karmaşıklıkta değil "amortized O(1)" karmaşıklıktadır. 

    Aşağıda, bir deque gerçekleştirimine örnek verilmiştir: 
        * Örnek 1, Bu gerçekleştirimde deque bir juruk sistemi gibi oluturulmuştur. Veri yaosının bilgilerini tutan handle alanı şöyledir:

            typedef int DATATYPE;

            typedef struct tagDEQUE {
                DATATYPE *deque;
                size_t capacity;
                size_t count;
                size_t head;
                size_t tail;
            } DEQUE, *HDEQUE;

        Bu gerçekleştirimde deque için başlangıçta DEQUE_DEF_CAPACITY (8) elemanlık yer ayrılmaktadır. Deque dolunca öncekinin iki katı uzunluğunda yeni bir aalan tahsis edilmiş ve eski alandan yeni alana kopyalama yapılmıştır. Deque veri yapısında başa ve sona eleman
        eklemek, baştan ve sondan eleman silmek O(1) karmaşıklıktadır. Ancak araya eleman insert etmek ya da aradan eleman silmek O(N) karmaşıklıktadır. Biz aşağıdaki gerçekleştirimde araya eleman ekleme ve aradan eleman işlemini kuyruğun sonunu referans alarak kaydırma
        yoluyla yaptık. Aslında insert ve remove pozisyonları hangi uca daha yakınsa kaydırma ona göre de yapılabilirdi. 
            /* deque.h */
                #ifndef DEQUE_H_
                #define DEQUE_H_

                #include <stddef.h>
                #include <stdbool.h>

                /* Symbolic Constants */

                #define DEQUE_DEF_CAPACITY		8
                #define DEQUE_FAILED			((size_t)-1)
                #define MIN(a, b)				((a) < (b) ? (a) : (b))

                /* Type Declerations */

                typedef int DATATYPE;

                typedef struct tagDEQUE {
                    DATATYPE *deque;
                    size_t capacity;
                    size_t count;
                    size_t head;
                    size_t tail;
                } DEQUE, *HDEQUE;

                /* Function Prototypes */

                HDEQUE create_deque(void);
                size_t add_back_deque(HDEQUE hdeque, DATATYPE val);
                size_t add_backp_deque(HDEQUE hdeque, const DATATYPE *val);
                size_t add_front_deque(HDEQUE hdeque, DATATYPE val);
                size_t add_frontp_deque(HDEQUE hdeque, const DATATYPE *val);
                DATATYPE at_deque(HDEQUE hdeque, size_t index);
                void atp_deque(HDEQUE hdeque, size_t index, DATATYPE *val);
                DATATYPE pop_front_deque(HDEQUE hdeque);
                void pop_frontp_deque(HDEQUE hdeque, DATATYPE *val);
                size_t insert_deque(HDEQUE hdeque, size_t index, DATATYPE val);
                size_t remove_deque(HDEQUE hdeque, size_t index);
                DATATYPE *set_capacity_deque(HDEQUE hdeque, size_t new_capacity);
                void clear_deque(HDEQUE hdeque);
                void destroy_deque(HDEQUE hdeque);

                /* inline Function Definitions */

                static inline size_t count_deque(HDEQUE hdeque)
                {
                    return hdeque->count;
                }

                static inline size_t capacity_deque(HDEQUE hdeque)
                {
                    return hdeque->capacity;
                }

                #endif

            /* deque.c */
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include "deque.h"

                HDEQUE create_deque(void)
                {
                    HDEQUE hdeque;

                    if ((hdeque = (HDEQUE)malloc(sizeof(DEQUE))) == NULL)
                        return NULL;

                    if ((hdeque->deque = (DATATYPE *)malloc(DEQUE_DEF_CAPACITY * sizeof(DATATYPE))) == NULL) {
                        free(hdeque);
                        return NULL;
                    }

                    hdeque->count = 0;
                    hdeque->capacity = DEQUE_DEF_CAPACITY;

                    hdeque->head = hdeque->tail = 0;

                    return hdeque;
                }

                size_t add_back_deque(HDEQUE hdeque, DATATYPE val)
                {
                    if (hdeque->count == hdeque->capacity && set_capacity_deque(hdeque, hdeque->capacity * 2) == NULL)
                        return DEQUE_FAILED;

                    hdeque->deque[hdeque->tail++] = val;
                    hdeque->tail %= hdeque->capacity;
                    ++hdeque->count;

                    return hdeque->count - 1;
                }

                size_t add_backp_deque(HDEQUE hdeque, const DATATYPE *val)
                {
                    if (hdeque->count == hdeque->capacity && set_capacity_deque(hdeque, hdeque->capacity * 2) == NULL)
                        return DEQUE_FAILED;

                    hdeque->deque[hdeque->tail++] = *val;
                    hdeque->tail %= hdeque->capacity;
                    ++hdeque->count;

                    return hdeque->count - 1;
                }

                size_t add_front_deque(HDEQUE hdeque, DATATYPE val)
                {
                    if (hdeque->count == hdeque->capacity && set_capacity_deque(hdeque, hdeque->capacity * 2) == NULL)
                        return DEQUE_FAILED;

                    if (hdeque->head == 0)
                        hdeque->head = hdeque->capacity - 1;
                    else
                        --hdeque->head;

                    hdeque->deque[hdeque->head] = val;
                    ++hdeque->count;

                    return 0;
                }

                size_t add_frontp_deque(HDEQUE hdeque, const DATATYPE *val)
                {
                    if (hdeque->count == hdeque->capacity && set_capacity_deque(hdeque, hdeque->capacity * 2) == NULL)
                        return DEQUE_FAILED;

                    if (hdeque->head == 0)
                        hdeque->head = hdeque->capacity - 1;
                    else
                        --hdeque->head;

                    hdeque->deque[hdeque->head] = *val;
                    ++hdeque->count;

                    return 0;
                }

                DATATYPE *set_capacity_deque(HDEQUE hdeque, size_t new_capacity)
                {
                    size_t size1, size2;
                    DATATYPE *new_deque;
                    
                    if ((new_deque = (DATATYPE *)malloc(new_capacity * sizeof(DATATYPE))) == NULL)
                        return NULL;

                    size1 = MIN(hdeque->capacity - hdeque->head, hdeque->count);
                    size2 = hdeque->count - size1;

                    memcpy(new_deque, &hdeque->deque[hdeque->head], size1 * sizeof(DATATYPE));
                    if (size2 != 0)
                        memcpy(new_deque + size1, hdeque->deque, size2 * sizeof(DATATYPE));

                    free(hdeque->deque);
                    hdeque->deque = new_deque;
                    hdeque->capacity = new_capacity;
                    hdeque->head = 0;
                    hdeque->tail = hdeque->count;
                    
                    return new_deque;
                }

                DATATYPE at_deque(HDEQUE hdeque, size_t index)
                {
                    return hdeque->deque[(hdeque->head + index) % hdeque->capacity];
                }

                void atp_deque(HDEQUE hdeque, size_t index, DATATYPE *val)
                {
                    *val = hdeque->deque[(hdeque->head + index) % hdeque->capacity];
                }

                DATATYPE pop_front_deque(HDEQUE hdeque)
                {
                    size_t head;

                    head = hdeque->head++;
                    hdeque->head %= hdeque->capacity;

                    return hdeque->deque[head];
                }

                void pop_frontp_deque(HDEQUE hdeque, DATATYPE *val)
                {
                    *val = hdeque->deque[hdeque->head++];
                    hdeque->head %= hdeque->capacity;
                }

                size_t insert_deque(HDEQUE hdeque, size_t index, DATATYPE val)
                {
                    size_t k;

                    if (index > hdeque->count)
                        return DEQUE_FAILED;

                    if (hdeque->count == hdeque->capacity && set_capacity_deque(hdeque, hdeque->capacity * 2) == NULL)
                        return DEQUE_FAILED;

                    k = hdeque->tail;
                    for (size_t i = 0; i < hdeque->count - index; ++i) {
                        if (k == 0) {
                            k = hdeque->capacity - 1;
                            hdeque->deque[0] = hdeque->deque[k];	
                        }
                        else { 
                            hdeque->deque[k] = hdeque->deque[k - 1];
                            --k;
                        }
                    }

                    hdeque->deque[k] = val;
                    hdeque->tail = (hdeque->tail + 1) % hdeque->capacity;

                    ++hdeque->count;
                    
                    return index;
                }

                size_t remove_deque(HDEQUE hdeque, size_t index)
                {
                    size_t k;

                    if (index >= hdeque->count)
                        return DEQUE_FAILED;

                    k = (hdeque->head + index) % hdeque->capacity;
                    for (size_t i = 0; i < hdeque->count - index - 1; ++i) {
                        if (k == hdeque->capacity - 1) {
                            hdeque->deque[k] = hdeque->deque[0];
                            k = 0;
                        }
                        else {
                            hdeque->deque[k] = hdeque->deque[k + 1];
                            ++k;
                        }
                    }

                    hdeque->tail = (hdeque->tail + hdeque->capacity - 1) % hdeque->capacity;

                    --hdeque->count;

                    return index;
                }

                void clear_deque(HDEQUE hdeque)
                {
                    hdeque->head = hdeque->tail = 0;
                    hdeque->count = 0;
                }

                void destroy_deque(HDEQUE hdeque)
                {
                    free(hdeque->deque);
                    free(hdeque);
                }

            /* app.c */
                #include <stdio.h>
                #include <stdlib.h>
                #include "deque.h"

                void disp_deque(HDEQUE hdeque);

                int main(void)
                {
                    HDEQUE hdeque;
                    
                    if ((hdeque = create_deque()) == NULL) {
                        fprintf(stderr, "cannot create deque!..\n");
                        exit(EXIT_FAILURE);
                    }

                    for (int i = 0; i < 10; ++i)
                        add_back_deque(hdeque, i);

                    disp_deque(hdeque);

                    remove_deque(hdeque, 1);
                    
                    disp_deque(hdeque);

                    destroy_deque(hdeque);

                    return 0;

                }

                void disp_deque(HDEQUE hdeque)
                {
                    DATATYPE val;

                    for (int i = 0; i < count_deque(hdeque); ++i) {
                        val = at_deque(hdeque, i);
                        printf("%d ", val);
                        fflush(stdout);
                    }
                    printf("\n");
                    printf("head: %zd, tail: %zd, count: %zd, capacity: %zd\n", hdeque->head, hdeque->tail, count_deque(hdeque), capacity_deque(hdeque));
                }

    >> Arama İşlemleri (Search Algorithms) : Algoritmalar ve veri yapıları konusunun en önemli alt konularından biri "arama (searching)" işlemleridir. Bir öğenin hızlı bir biçimde bulunması bazı uygulamaların performasını önemli ölçüde etkileyebilmektedir. Arama işlemleri
    doğrudan ana bellek (RAM) üzerinde ya da diskteki dosyalar üzerinde yapılabilir. Ana belek üzeirndeki aramalara "içsel aramalar (internal searches)" işlemleri denilmektedir. Diskteki dosyalar üzerinde yapılan aramalara ise "dışsal arama (external searches)" işlemleri
	denilmektedir. Örneğin bir dizideki elemanın aranması içsel aramaya örnektir. Ancak bir dosya üzerinde yapılan arama dışsal aramaya örnektir. Veritabanı işlemlerini gerçekleştiren araçlar dışsal aramayı etkin bir biçimde yapmaya çalışırlar. Dışsal arama yöntemlerinde
    içsel arama yöntemlerinden farklı algoritmalar kullanılabilmektedir. Biz bu kurusumuzda "içsel arama yöntemleri" üzerinde duracağız. Dışsal arama yöntemleri "Sistem Programlama ve İleri C Uygulamarı II" kursunda ele alınmaktadır. 
        >>> Elimizde liste tarzı bir veri yapısı varsa ilk akla gelen arama yöntemi "sıralı arama (sequential search)" denilen yöntemdir. Eğer listenin elemanları arasında hiçbir ilişki yoksa (yani elemanlar gelişi güzel biçimde sıralanmışsa) sıralı aramadan başka bir yol
        yoktur. Sıralı aramda listenin başından
        itibaren her elemana ilgili bulunana kadar bakılır. Eğer aranacak eleman liste içerisinde varsa buna "başarılı arama successful search" denilmektedir. Eğer aranacak eleman listede yoksa buna da "başrısız arama (unsuccessful search)" denilmektedir. Başarılı sıralı
        aramada dizinin uzunluğu N olmak üzere ortalama (N + 1) / 2 karşılaştırma yapılmaktadır. Tabii en kötü durum senaryosunda bu değer N olacaktır. Big O notasyonuna göre arama işlemi O(N) karmaşıklıktadır. O(N) karmaşıklık arama işlemleri için kötü bir karmaşıklıktır. 
        Örneğin 1000000 elamanın bulunduğu bir listede elemanın bulunması için ortalama 500000 karşılaştırma gerekmektedir. Ancak eleman sayısının çok az olduğu listelerde (örneğin eleman sayısının 20'den az olduğu listelerde) en hızlı arama yöntemi yine de sıralı aramadır. 	
            * Örnek 1, Aşağıda tipik bir sıralı arama işlemini yapan fonksiyon örneği verilmiştir.
                #include <stdio.h>
                #include <stdlib.h>

                typedef int DATATYPE;

                DATATYPE *linear_search(const DATATYPE *array, size_t size, DATATYPE val)
                {
                    for (size_t i = 0; i < size; ++i)
                        if (array[i] == val)
                            return (DATATYPE *)&array[i];

                    return NULL;
                }

                int main(void)
                {
                    DATATYPE array[10] = {4, 67, 34, 12, 45, 32, 98, 11, 9, 85};
                    DATATYPE *val;

                    if ((val = linear_search(array, 10, 98)) == NULL) {
                        fprintf(stderr, "cannot find!..\n");
                        exit(EXIT_FAILURE);
                    }
                    printf("%d\n", *val);

                    return 0;
                }

        Aslında Knuth "The Art of Computer Programming" kitabının "The Sorting and Searching" isimli üçüncü cildinde sıralı arama sırasında her defasında "dizi bitti mi karşılaştırmasını" elimine etmek için bir yöntem önermiştir. Bu yönteme göre aranacak değer
        önce dizinin sonuna yerleştirilir. Sonra gereksiz biçimde her yinelemede bu kontrol yapılmaz. Çünkü eleman en kötü olasılıkla dizinin sonuna gelindiğinde bulunmuş olacaktır. Tabii bunun için dizinin bir fazl uzunlukta açılmış olması gerekir. Aşağıda bu yöntem
        uygulanmıştır.
            * Örnek 1,
                #include <stdio.h>
                #include <stdlib.h>

                typedef int DATATYPE;

                DATATYPE *linear_search(DATATYPE *array, size_t size, DATATYPE val)
                {
                    size_t i;

                    array[size] = val;

                    for (i = 0;; ++i)
                        if (array[i] == val)
                            break;

                    return i != size ? &array[i] : NULL;
                }

                int main(void)
                {
                    DATATYPE array[10 + 1] = {4, 67, 34, 12, 45, 32, 98, 11, 9, 85};
                    DATATYPE *val;

                    if ((val = linear_search(array, 10, 98)) == NULL) {
                        fprintf(stderr, "cannot find!..\n");
                        exit(EXIT_FAILURE);
                    }
                    printf("%d\n", *val);

                    return 0;
                }

        Eğer aramanın yapılacağı liste sıraya diziliyse ve O(1) karmaşıklıktakli erişime izin veriyorsa (yani başka bir deyişle arama sıralı bir dizi üzerinde yapılacaksa) bu durumda "ikili arama (binary search)" denilen yöntem tercih edilmelidir. İkili arama yönteminde
        aralık sürekli bir biçimde ikiye bölünerek daraltılır. İkili aramanın en kötü durumdaki karşılaştırma sayısı log2 N kadardır. (Yani örneğin 1 milyon eleman için 20 karşılaştırma). Big O notasyonuna göre en kötü durumdaki algoritma karçalıklığı O(log N) biçimindedir. 
        Bir diziyi önce sıraya dizip onun üzerinde ikili arama uygulamak çoğu kez uygun bir yöntem değildir. Çünkü sıraya dizmenin maliyeti sıralı aramadan daha yüksektir. En iyi sıraya dizme algoritmaları O(N log N) karmaşıklıktadır. Tabii eğer dizi güncellenmeyecekse ve
        çok sayıda arama yaapılacaksa bir kez O(N log N) maliyeti karşılanıp diğer aramalar O(log N) karmaşıklıkta yürütülebilir. İkili arama yapılırken tipik olarak left ve right biçiminde iki çubuk alınır. Bunun orta noktası bulunur. Orat noktasındaki dizi elemanı aranacak
        elemanla karşılaştırılır. Eğer aranacak eleman orat noktadaki elemandan büyükse soldaki çubuk, küçükse sağdaki çubuk orta noktanın yanına çekilir. Başarısız aramda sağ çubuk sol çubuğun soluna gelmektedir. Burada çubukların ora noktasının şöyle bulunduğuna dikkat
        ediniz:

            mid = (left + right) / 2;

        Bu işlem aslında aşağıdakiyle eşdeğerdir:

            mid = left + (right - left) / 2;

        Aşağıda bu konuya ilişkin bir örnek verilmiştir:
            * Örnek 1, 
                #include <stdio.h>
                #include <stdlib.h>

                typedef int DATATYPE;

                DATATYPE *binary_search(const DATATYPE *array, size_t size, DATATYPE val)
                {
                    size_t left, right, mid;

                    left = 0, right = size - 1;

                    while (left <= right) {
                        mid = (right + left) / 2;
                        if (val > array[mid])
                            left = mid + 1;
                        else if (val < array[mid])
                            right = mid - 1;
                        else
                            return (DATATYPE *)&array[mid];
                    }

                    return NULL;
                }

                int main(void)
                {
                    DATATYPE array[10] = {4, 11, 18, 24, 38, 43, 52, 68, 74, 89};
                    DATATYPE *val;

                    if ((val = binary_search(array, 10, 100)) == NULL) {
                        fprintf(stderr, "cannot find!..\n");
                        exit(EXIT_FAILURE);
                    }
                    printf("%d\n", *val);

                    return 0;
                }

        Eğer sıralı dizinin eleman sayısı bilinmiyorse (unbounded array) bu durumda önce elemanın bulunduğu bölge üstel bir biçimde (2 ile çarpılarak) belirlenir. Sonra o bölgede ikili arama uygulanabilir. Bu yönteme literatürde "üstel arama(exponential serach)" de
        denilmektedir. Yukarıda da belirttiğimiz gibi üstel arama üst sınıfın bilinmediği sıralı dizilerde özellikle uygulanmaktadır. Sınırın bilindiği durumlarda doğrudan ikili aramaya geçilebilir. Örneğin:

            1 3 6 9 11 17 23 28 36 41 48 54 61 67 72 78 82 86 90 92 .....

        Böyle bir dizide bir sınır olmadığı için ikili armanın sağ çubuğunun yerini de eblirleyemeyiz. İşte onu belirleyebilmek için önce 1'den başlatılan bir index sürekli iki ile çarpılarak ilerlenir. Örneğin:

            right = 1;
            while (array[right] < val && right < size)
                right *= 2;
            left = right / 2;

        Burada artık döngüden çıkıldığında aranacak eleman left ile right arasındadır. Bu noktada klasik ikili arama uygulaanabilir. Örneğin yukarıdaki örnek dizide aranacak eleman 78 olsun. Önce 1'inci indeksteki elemana bakılır (3). Sonra 2'inci indeksteki elemana
        bakılır (6) Ondan sonra 4'üncü indeksteki sonra 8'inci (36) sonra 16'ıncı indeksteki (82) elemanlara bakılır. 16'ıncı indeksteki eleman artık aranan eleman olan 78'den büyüktür. Döngü çıkılır ve dizinin 8'inci ve 16'ıncı indeksi arasında ikili arama uygulanır.
        Aşağıda üstel aramaya bir örnek verilmiştir. Her ne kadar bu arama yöntemi aslında sınırı bilinmeyen bir dizi için tercih ediliyorsa da sıralı normal dizilerde de kullanılabilir. (Normal sıralı ve sınırlı dizilerde bu algoritmanın kullanılması gerçek anlamda bir
        fayda sağlamamaktadır.)
            * Örnek 1,
                #include <stdio.h>
                #include <stdlib.h>

                typedef int DATATYPE;

                DATATYPE *binary_search(const DATATYPE *array, size_t size, DATATYPE val)
                {
                    size_t left, right, mid;

                    left = 0, right = size - 1;

                    while (left <= right) {
                        mid = (right + left) / 2;
                        if (val > array[mid])
                            left = mid + 1;
                        else if (val < array[mid])
                            right = mid - 1;
                        else
                            return (DATATYPE *)&array[mid];
                    }

                    return NULL;
                }

                DATATYPE *exponential_search(const DATATYPE *array, size_t size, DATATYPE val)
                {
                    size_t left, right;

                    if (array[0] == val)
                        return (DATATYPE *)&array[0];

                    right = 1;
                    while (right < size && val > array[right])
                        right *= 2;

                    if (right >= size)
                        right = size - 1;

                    left = right / 2;

                    return binary_search(array + left, right - left + 1, val);
                }

                int main(void)
                {
                    DATATYPE array[] = {1, 3, 6, 9, 11, 17, 23, 28, 36, 41, 48, 54, 61, 67, 72, 78, 82, 86, 90, 92};
                    DATATYPE *val;

                    if ((val = exponential_search(array, sizeof(array) / sizeof(*array), 61)) == NULL) {
                        fprintf(stderr, "cannot find!..\n");
                        exit(EXIT_FAILURE);
                    }
                    printf("%d\n", *val);

                    return 0;
                }

        Sıralı dizilerde arama yapmak için kullanılan diğer bir yöntem de "enterpolasyon araması (interpolation search)" denilen yöntemdir. Bu yöntem ikili arama gibidir ancak aralık orta noktadan değil daha uygun yerden daraltılmaya çalışılır. Örneğin elimizde bir sözlük
        olsun. Bu sözlükte y harfi ile başlayan biz sözcüğü aramak isteyelim. Aramayı sözlüğün ortasından mı yoksa sonlarına doğru bir noktadan mı başlatırız? İşte ikili aramada arama orta noktalar temelinde yapılır. Ancak enterpolasyon aramasında arama orta nokta temelinde
        değil aranack anahtarla oranlı bir biçimde yapılmaktadır. Bu yöntemde de yine left ve right biçiminde iki çubuk alınır. Bu yöntemin ikili aramadan farkı orta noktalar yerine otantılı npktalara bakılmasıdır. Örneğin aranacak değer val olsun. Aranak ye şu orantıyla
        tespit edilir:

            mid = left + ((right - left) /(array[right] - array[left]) * (val - array[left]))

        İfadedeki şu kısma dikkat ediniz:

            (right - left) / (array[right] - array[left])

        Burada yapılmak istenen şey dizi elemanlarındaki bir birim artımın kaç indeks artırımına karşı geldiğinin tespit edilmesidir. Bu tespit edildikten sonra bu değer (val - array[left]) değeri ile çarpılmıştır. Böylece orta nokta değil orantılı bir nokta elde edilmiştir. 
        Pekiyi bu yöntem ikili aramadan daha mı iyidir? Eğer dizideki elemanların arasındaki artırım miktarı n,speten stabil ise yani düzgün bir artırım söz konusu ise bu yöntem ikili aramadan daha hızlı bir aramaya yol açar. Ancak uç değerlerin olduğu durumda bu yöntemin
        performansı çok düşmektedir. Örneğin:

            1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1000000

        Bu gibi durumlarda enterpolasyon araması O(N) karmaşıklığa kadar gerilemektedir. O halde sıralı dizinin elemanlarının genel artırımı hakkında bir bilgi sahibi değilsek ikili aramayı tercih etmeliyiz. Ancak dizideki elemanlar nispeten birbirine yakın artırımlarla 
        ilerliyorsa ve dizide uç değerler yoksa bu ymntem daha iyi performans gösterebilmektedir. 
            * Örnek 1,
                #include <stdio.h>
                #include <stdlib.h>

                typedef int DATATYPE;

                DATATYPE *interpolation_search(const DATATYPE *array, size_t size, DATATYPE val)
                {
                    size_t left, right, mid;

                    left = 0, right = size;

                    while (left <= right) {
                        mid = left + ((right - left) / (array[right] - array[left]) * (val - array[left]));
                        if (val > array[mid])
                            left = mid + 1;
                        else if (val < array[mid])
                            right = mid - 1;
                        else
                            return (DATATYPE *)&array[mid];
                    }

                    return NULL;
                }

                int main(void)
                {
                    DATATYPE array[] = {1, 3, 6, 9, 11, 17, 23, 28, 36, 41, 48, 54, 61, 67, 72, 78, 82, 86, 90, 92};
                    DATATYPE *val;

                    if ((val = interpolation_search(array, sizeof(array) / sizeof(*array), 12)) == NULL) {
                        fprintf(stderr, "cannot find!..\n");
                        exit(EXIT_FAILURE);
                    }
                    printf("%d\n", *val);

                    return 0;
                }

        >>> Aramalar aslında anahtara göre yapılıp aramanın sonucunda o anahtara ilişkin değer elde edilir. Biz yukarıdaki örneklerde yalnızca anahtarların bulunduğu dizide anahtar aradık. Dolayısıyla yukarıdaki örneklerde elde edebileceğimiz tek bilgi "anahtarın dizide var
        olup olmadığı" bilgisidir. Halbuki aramalarda önce anahtar-değer çiftleri veri yapısına yerleştirilir. Sonra anahtar verildiğinde onun değeri elde edilir. Örneğin öğrencilerin bilgileri numaralarına göre aranabilir. Böylece aramayı yapacak kişi öğrencinin numarasını
        verir. Arama sonucunda o numaralı öğrencinin bilgileri elde edilir. Veri yapıları dünyasında "bir anahtar verildiğinde ona iliştirilmiş olan değerin elde edilmesini" sağlayan veri yapılarına "sözlük (dictionary)" tarzı veri yapıları denilmektedir. Sözlük tarzı veri
        yapılarının en önemli özelliği anahtar verildiğinde değeri çok hızlı bir biçimde bulmasıdır. Anahtar ve değerlerin bir dizide tutulması ve onların sıralı bir biçimde aranması çok yavaş bir yöntemdir. Bu tür durumlarda hızlı aramalar için "algoritmik arama yöntemleri"
        kullanılmaktadır. Algoritmik arama yötemlerinin en çok kullanılanları "hash tabloları (hash tables)" ve "arama ağaçları (search trees)" denilen yöntemlerdir. İdeal bir anahtar-değer araması nasıl olabilir? Şüphesiz ideal durumda aramın O(1) karmaşıklıkta yapılması
        istenir. Anahtarın bir int değer olduğunu ve kişinin numarasını belirttiğini düşünelim. Biz de numara verildiğinde o kişinin bilgilerini elde etmek isteyelim. Kişilerin bilgilerini PERSON isimli bir yapıyla temesil edebiliriz:

            struct PERSON {
                ....
            };

        Sonra da PERSON türünden büyük bir dizi açabiliriz:

            struct PERSON people[MAX_SIZE];

        Sonra da kişilerin numaralarını indeks yaparak bu diziye yerleştirebiliriz. Örneğin numarası 123 olan kişinin bilgileri diziye şöyle yerleştirilebilir:

            people[123] = person_info;

        Numarası 123 olan kişinin bilgilerini O(1) karmaşıklıkta çok hızlı bir biçimde aşağıdaki gibi elde edebiliriz:

            person_info = people[123];

        Bu yöntem ilk bakışta çok iyi bir yöntem gibi gözükse de genellikle kullanılabilir bir yöntem değildir. Çünkü burada anahtar int türdendir. Ancak anahtarlar farklı tür olabilir. Örneğin anahtar kişinin adı soyadı olabilir. Yazısal bir bilgi indeks belirtmemektedir.
        Bu yöntemin diğer bir sakıncası örneğin kişi numaralarının yüksek basamaklardan oluştuğu durumda o kadar büyük bir dizinin açılması gerekliliğidir. Örrneğin kişinin TC numarasına göre onun bilgilerinin elde edileceği durumda TC numarası 11 digit bir sayıdır. Yani
        skalası 100 milyar sınırındadır. 100 milyarlık bir yapı dizisini bu amaçla oluşturmak ya mümkün değildir, mümkün olsa da etkin değildir. Bu yönteme "indeskli arama index search" denilmektedir. Ancak çok özel durumlarda bu yöntem kullanılabilmektedir. 

        >>> Algoritmik aramalarda en çok kullanılan yöntemlerden biri "hash tabloları (hash tables)" denilen yöntemdir. Hash tabloları aslında yukarıda belirttiğimiz indeksli arama ile sıralı aramanın hibrit bir biçimidir. Yöntemde ismine "hash tablosu (hash table)" makul
        bir uzunlukta dizi oluşturulur. Sonra anahtarlar ismine "hash fonksiyonu (hash function)" denilem bir fonksiyona sokularak dizi indeksine dönüştürülür. Sonra da dizinin o indeksteki elemanına başvurulur. Örneğinkişinin bilgilerini TC numaralarına göre saklayıp geri
        almak isteyelim. Hash tablomuzun uzunluğu da 1000 olsun. Hash fonksiyonunun "1000'e bölümden elde edilen kalan" değerini veren fonksiyon olduğunu varsayalım. Bu durumda örneğin 2566198712 TC kimlik numarasına sahip kişinin bilgileri hash tablosunun 712'inci
        indeksteki elemanında saklanabilir. 72484926820 TC kimlik numarasına sahip kişinin belgileri de dizinin 820'inci indeksteki elemanında saklanacktır. Ancak farklı kişilerin TC numaraları hash fonksiyonuna sokuldupunda aynı değer elde edilebilir. Örneğin 6238517712
        TC numarasına sahip kişi de dizinin 712'inci indeskteki elemanına yerleşmek isteyecektir. İşte tablosu yönteminde bu duruma "çakışma durumu (collison)" denilmektedir. Hash tablosu yöntemi çakışma durumunda izlenecek stratejiye göre değişik varyasyonlara sahiptir.
        Hash tabloları yönteminde çakışma durumunda bu sorunu çözmek için iki ana yöntem grubu kullanılmaktadır: Ayrı zincir oluşturma yöntemi (separate chaining) ve açık adresleme (open addresiing) yöntemi. Açık adresleme yöntemi de kendi aralarında "doğrusal yoklama
        (linear probing)", "karesel yoklama (quadratic probing)", "çift hash'leme (double hasing)" gibi alternatif alt yöntemlere ayrılmaktadır. Ayrı zincir oluşturma ve açık adresleme yöntemlerinin dışında başka çakışma çözümleme stratejileri de vardır. Ancak ağırlıklı
        olarak bu ikisi tercih edilmektedir. Ayrı zincir oluşturma yönteminde (separate chaining) hash tablosu aslında bir bağlıntı liste dizisi gibi oluşturulur. Yani hash tablosunun her elemanı bağlı listenin ilk elemanını (head pointer) göstermektedir. Eklenecek anahtar
        hash fonksiyonuna sokulur ve bağlı listenin hemen önüne (ya da duruma göre arkasına) eklenir. Eleman aranırken yine anahtar hash fonksiyonuna sokulur ve dizinin ilgili indeksindeki bağlı listede sıralı arama yapılır. Hash tablolarına eleman insert etmek O(1)
        karmaşıklıktadır. Tabii burada kullanılacak hash fonksiyonu da önemlidir. Küçük dönüler içeren hash fonksiyonları O(1) karmaşıklığı yükseltmemektedir. elemanın silinmesi de benzer biçimdedir. Eleman aramanın O(1) karmaşıklıkta olabilmesi için bağlı listelerdeki
        zincir uzunluklarının kısa olması gerekir. 10 kadar eleman için en hızlı arama yöntemi sıralı aramdır. Bu koşulda sıralı aramanın O(1) karmaşıkta oludğu söylenebilir. O halde eğer zincirlerdeki oratalama eleman 10 civarında makul bir düzeyde tutulursa arama
        işleminin de O(1) karmaşıklıkta yapılabileceği söylenebilir. Sözlük tarzı veri yapılarında genel olarak aynı anahtara ilişkin birden fazla anahtar-değer çifti veri yapısına yerleştirilememektedir. Bazı kütüphanelerde buna izin verilebilmektedir. Eğer aynı anahtara
        ilişkin yeni bir değer insert edilmeye çalışılırsa eski değer yeni değerle yer değiştirmektedir. Yani başka bir deyişle anahtarın değeri değişitirilmektedir. Bazı tasarımlar ise aynı anahtara ilişkin insert yapmayı engellemektedir. Yani bu tasarımlarda yalnızca
        olmayan elemanı insert edebiliriz. Pekiyi hash tablolarında kullanılacak iyi bir hash fonksiyonu nasıl olmalıdır? İyi bir hash fonksiyonunun "hızlı" olması gerekir. Çünkü her türlü insert gibi arama gibi işlemlerde hash fonksiyonu kullanılacaktır. İyi bir hash
        fonksiyonunun "anahtarlar yanlı bile olsa" tabloya onları iyi bir biçimde yaydırması gerekir. Örneğin aslında sayısal anahtarlar için "bölümden elde edilen kalan" iyi bir hash fonksiyonu değildir. Hash tablolarında tablonun asal sayı uzunluğunda olması hash
        fonksiyonlarının daha iyi yaydırmasına yardımcı olmaktadır. (Örneğin tablo uzunluğu için 100 yerine 101 değeri tercih edilmelidir.) Hash fonksiyonları "sayıyı indekse dönüştüren" ve "yazıyı indekse" dönüştüren fonksiyonlar biçiminde oluşturulabilir. 	Hash
        tablolarının büyütülmesi önemli bir zaman kaybına yol açabilmektedir. Çünkü tablodaki tüm elemanların yeni tablo uzunluğuna göre yeniden hash'lenip yeni tablodaki uygun slotlara yerleştirilmesi gerekmektedir. Pekiyi büyütme ne zaman yapılamalıdır? Tablodaki
        toplam eleman sayısının tablo büyüklüğüne oranına "yükleme faktörü (load factor)" denilmektedir. Genellikle yükleme faktörü 0.75 gibi çok küçük bir değerde tutulur. Ancak yukarıda da belirttiğimiz gibi zincirlerdeki ortalama eleman sayısı 10 civarında olduğunda
        hash tabloları yine çok hızlı çalışmaktadır. Aşağıda ayrı zincir oluşturma yöntemi (separate chaining) için bir örnek verilmiştir. Bu örnekte çift bağlı liste kullanılmıtır. Aslında çift bağlı liste kullanılmasının bu örnekte bize bir faydası yoktur. Daha önceden
        de belirttiğimiz gibi çift bağlı listeler özellike düğüm adresi verildiğinde hızlı silme yapmak için tercih edilmektedir. Örneğimizde düğüme dayalı silme yapılamamaktadır. Çünkü silinecek düğüm eğer ilk düğümse tablonun güncellenmesi gerekir. Onun için de anahtarın
        bilinmesi gerekir. Tabii biz tabloda bağlı listelerin ilk düğümlerinin adreslerini tutmak yerine doğrudan bir düğüm de tutabilirdik. Bu durumda düğüme dayalı silmeyi yapabilirdik. Örneğimizde hash tablosunu eleman sayısı yükleme faktörüne eriştiğinde büyüttük.
        Default yükleme faktörünü 0.75 aldık. Yani örneğin tablonun uzunluğu 100 olsun. Tablodaki eleman sayısı 75'e geldiğinde iki kat büyütme sağlanmaktadır. Tabii aslında yükleme faktörünü bu kadar düşük tutmayabiliriz. 
            * Örnek 1,
                /* htable.h */
                    #ifndef HTABLE_H_
                    #define HTABLE_H_

                    #include <stddef.h>
                    #include <stdbool.h>

                    /* Type Decalarations */

                    typedef struct tagPERSON {
                        char name[32];
                        int city;
                        int no;
                    } PERSON;

                    typedef struct tagNODE {
                        char key[32];			
                        PERSON value;
                        struct tagNODE *next;
                        struct tagNODE *prev;
                    } NODE;

                    typedef struct tagHTABLE {
                        NODE **table;
                        size_t tsize;
                        size_t count;
                        double lf;
                    } HTABLE, *HHTABLE;

                    /* Function Prototypes */

                    HHTABLE create_lf_ht(size_t tsize, double lf);
                    NODE *insert_ht(HHTABLE hhtable, const char *key, const PERSON *value);
                    NODE *update_ht(HHTABLE hhtable, const char *key, const PERSON *value);
                    PERSON *find_ht(HHTABLE hhtable, const char *key);
                    bool remove_ht(HHTABLE hhtable, const char *key);
                    bool resize_ht(HHTABLE hhtable, size_t new_size);
                    void clear_ht(HHTABLE hhtable);
                    void destroy_ht(HHTABLE hhtable);

                    /* inline Function Definitions */

                    static inline size_t count_ht(HHTABLE hhtable)
                    {
                        return hhtable->count;
                    }

                    static inline size_t tsize_ht(HHTABLE hhtable)
                    {
                        return hhtable->tsize;
                    }

                    static inline HHTABLE create_ht(size_t tsize)
                    {
                        return create_lf_ht(tsize, 0.75);
                    }

                    #endif

                /* htable.c */
                    #include <stdio.h>
                    #include <stdlib.h>
                    #include <string.h>
                    #include "htable.h"

                    static size_t hash_func(const char *str, size_t tsize);

                    HHTABLE create_lf_ht(size_t tsize, double lf)
                    {
                        HHTABLE hhtable;

                        if ((hhtable = (HHTABLE)malloc(sizeof(HTABLE))) == NULL)
                            return NULL;

                        if ((hhtable->table = (NODE **)malloc(tsize * sizeof(NODE *))) == NULL) {
                            free(hhtable);
                            return NULL;
                        }
                        for (size_t i = 0; i < tsize; ++i)
                            hhtable->table[i] = NULL;

                        hhtable->tsize = tsize;
                        hhtable->count = 0 ;
                        hhtable->lf = lf;

                        return hhtable;
                    }

                    NODE *insert_ht(HHTABLE hhtable, const char *key, const PERSON *value)
                    {
                        NODE *new_node;
                        size_t hash;
                        
                        hash = hash_func(key, hhtable->tsize);

                        for (NODE *node = hhtable->table[hash]; node != NULL; node = node->next)
                            if (!strcmp(key, node->key)) 
                                return NULL;

                        if (((double)hhtable->count / hhtable->tsize) >= hhtable->lf)
                            if (!resize_ht(hhtable, hhtable->tsize * 2))
                                return NULL;

                        if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                            return NULL;
                        
                        strcpy(new_node->key, key);
                        new_node->value = *value;

                        new_node->next = hhtable->table[hash];
                        hhtable->table[hash] = new_node;

                        ++hhtable->count;

                        return new_node;
                    }

                    NODE *update_ht(HHTABLE hhtable, const char *key, const PERSON *value)
                    {
                        NODE *new_node;
                        size_t hash;

                        hash = hash_func(key, hhtable->tsize);

                        for (NODE *node = hhtable->table[hash]; node != NULL; node = node->next)
                            if (!strcmp(key, node->key)) {
                                node->value = *value;
                                return node;
                            }

                        if (((double)hhtable->count / hhtable->tsize) >= hhtable->lf)
                            if (!resize_ht(hhtable, hhtable->tsize * 2))
                                return NULL;

                        if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                            return NULL;

                        strcpy(new_node->key, key);
                        new_node->value = *value;

                        new_node->next = hhtable->table[hash];
                        hhtable->table[hash] = new_node;

                        ++hhtable->count;

                        return new_node;
                    }

                    PERSON *find_ht(HHTABLE hhtable, const char *key)
                    {
                        size_t hash;

                        hash = hash_func(key, hhtable->tsize);
                        
                        for (NODE *node = hhtable->table[hash]; node != NULL; node = node->next)
                            if (!strcmp(key, node->key))
                                return &node->value;

                        return NULL;
                    }

                    bool remove_ht(HHTABLE hhtable, const char *key)
                    {
                        size_t hash;
                        NODE *node, *prev_node;

                        hash = hash_func(key, hhtable->tsize);

                        prev_node = NULL;
                        node = hhtable->table[hash];
                        while (node != NULL) {
                            if (!strcmp(key, node->key)) {
                                if (hhtable->table[hash] == node) 
                                    hhtable->table[hash] = node->next;
                                else
                                    prev_node->next = node->next;
                                free(node);
                                --hhtable->count;
                                
                                return true;
                            }

                            prev_node = node;
                            node = node->next;
                        }

                        return false;
                    }

                    bool resize_ht(HHTABLE hhtable, size_t new_size)
                    {
                        NODE **new_table;
                        NODE *node, *temp_node;
                        size_t hash;

                        if (new_size <= hhtable->tsize)
                            return false;

                        if ((new_table = (NODE **)malloc(new_size * sizeof(NODE *))) == NULL)
                            return false;

                        for (size_t i = 0; i < new_size; ++i)
                            new_table[i] = NULL;

                        for (size_t i = 0; i < hhtable->tsize; ++i) {
                            node = hhtable->table[i];
                            while (node != NULL) {
                                temp_node = node->next;
                                hash = hash_func(node->key, new_size);
                                node->next = new_table[hash];
                                new_table[hash] = node;
                                node = temp_node;
                            }
                        }

                        free(hhtable->table);
                        hhtable->table = new_table;
                        hhtable->tsize = new_size;

                        return true;
                    }

                    void clear_ht(HHTABLE hhtable)
                    {
                        NODE *node, *temp_node;
                        
                        for (size_t i = 0; i < hhtable->tsize; ++i) {
                            node = hhtable->table[i];
                            while (node != NULL) {
                                temp_node = node->next;
                                free(node);
                                node = temp_node;
                            }
                            hhtable->table[i] = NULL;
                        }
                        hhtable->count = 0;
                    }

                    void destroy_ht(HHTABLE hhtable)
                    {
                        NODE *node, *temp_node;

                        for (size_t i = 0; i < hhtable->tsize; ++i) {
                            node = hhtable->table[i];
                            while (node != NULL) {
                                temp_node = node->next;
                                free(node);
                                node = temp_node;
                            }
                        }

                        free(hhtable);
                    }

                    static size_t hash_func(const char *str, size_t tsize)
                    {
                        size_t hash = 0;

                        while (*str != '\0') {
                            hash = (13 * hash + *str) % tsize;
                            ++str;
                        }

                        return hash;
                    }

                /* app.c */
                    #include <stdio.h>
                    #include <stdlib.h>
                    #include <string.h>
                    #include <time.h>
                    #include "htable.h"

                    void get_random_record(char *key, PERSON *per);

                    int main(void)
                    {
                        HHTABLE hhtable;
                        char name[32];
                        PERSON per;
                        PERSON specific_per = {"Kaan Aslan", 34, 123456};
                        PERSON *retper;

                        srand((unsigned)time(NULL));

                        if ((hhtable = create_ht(10)) == NULL) {
                            fprintf(stderr, "cannot allocate memory!..\n");
                            exit(EXIT_FAILURE);
                        }

                        for (int i = 0; i < 1000; ++i) {

                            if (i == 500) {
                                if (insert_ht(hhtable, "Kaan Aslan", &specific_per) == NULL) {
                                    fprintf(stderr, "cannot insert item!..\n");
                                    exit(EXIT_FAILURE);
                                }
                            }
                            else  {
                                get_random_record(name, &per);
                                
                                if (insert_ht(hhtable, name, &per) == NULL) {
                                    fprintf(stderr, "cannot insert item!..\n");
                                    exit(EXIT_FAILURE);
                                }
                            }
                        }
                        
                        if ((retper = find_ht(hhtable, "Kaan Aslan")) != NULL)
                            printf("Found: %s, %d, %d\n", retper->name, retper->city, retper->no);
                        else
                            printf("cannot find key!..\n");
                            
                        strcpy(per.name, "Kaan Aslan");
                        per.city = 35;
                        per.no = 1000;

                        if (update_ht(hhtable, "Kaan Aslan", &per) == NULL)
                            printf("Update failed!..\n");

                        if ((retper = find_ht(hhtable, "Kaan Aslan")) != NULL)
                            printf("Found: %s, %d, %d\n", retper->name, retper->city, retper->no);
                        else
                            printf("cannot find key!..\n");

                        printf("count: %zd\n", count_ht(hhtable));
                        printf("tsize: %zd\n", tsize_ht(hhtable));

                        destroy_ht(hhtable);

                        return 0;
                    }

                    void get_random_record(char *key, PERSON *per)
                    {
                        int i;

                        for (i = 0; i < 31; ++i) 
                            key[i] = per->name[i] = rand() % 26 + 'A';
                        per->name[i] = key[i] = '\0';

                        per->city = rand() % 81;
                        per->no = rand() % 1000000;
                    }

            * Örnek 2, Yukarıdaki örneği tek bağlı liste kullanarak aşağıdaki gibi yeniden yazabiliriz. 
                /* htable.h */
                    #ifndef HTABLE_H_
                    #define HTABLE_H_

                    #include <stddef.h>
                    #include <stdbool.h>

                    #define HT_DEF_LOAD_FACTOR		0.75

                    /* Type Decalarations */

                    typedef struct tagPERSON {
                        char name[32];
                        int city;
                        int no;
                    } PERSON;

                    typedef struct tagNODE {
                        char key[32];			
                        PERSON value;
                        struct tagNODE *next;
                    } NODE;

                    typedef struct tagHTABLE {
                        NODE **table;
                        size_t tsize;
                        size_t count;
                        double lf;
                    } HTABLE, *HHTABLE;

                    /* Function Prototypes */

                    HHTABLE create_lf_ht(size_t tsize, double lf);
                    NODE *insert_ht(HHTABLE hhtable, const char *key, const PERSON *value);
                    NODE *update_ht(HHTABLE hhtable, const char *key, const PERSON *value);
                    PERSON *find_ht(HHTABLE hhtable, const char *key);
                    bool remove_ht(HHTABLE hhtable, const char *key);
                    bool resize_ht(HHTABLE hhtable, size_t new_size);
                    void clear_ht(HHTABLE hhtable);
                    void destroy_ht(HHTABLE hhtable);

                    /* inline Function Definitions */

                    static inline size_t count_ht(HHTABLE hhtable)
                    {
                        return hhtable->count;
                    }

                    static inline size_t tsize_ht(HHTABLE hhtable)
                    {
                        return hhtable->tsize;
                    }

                    static inline HHTABLE create_ht(size_t tsize)
                    {
                        return create_lf_ht(tsize, HT_DEF_LOAD_FACTOR);
                    }

                    #endif

                /* htable.c */
                    #include <stdio.h>
                    #include <stdlib.h>
                    #include <string.h>
                    #include "htable.h"

                    static size_t hash_func(const char *str, size_t tsize);

                    HHTABLE create_lf_ht(size_t tsize, double lf)
                    {
                        HHTABLE hhtable;

                        if ((hhtable = (HHTABLE)malloc(sizeof(HTABLE))) == NULL)
                            return NULL;

                        if ((hhtable->table = (NODE **)malloc(tsize * sizeof(NODE *))) == NULL) {
                            free(hhtable);
                            return NULL;
                        }
                        for (size_t i = 0; i < tsize; ++i)
                            hhtable->table[i] = NULL;

                        hhtable->tsize = tsize;
                        hhtable->count = 0 ;
                        hhtable->lf = lf;

                        return hhtable;
                    }

                    NODE *insert_ht(HHTABLE hhtable, const char *key, const PERSON *value)
                    {
                        NODE *new_node;
                        size_t hash;
                        
                        hash = hash_func(key, hhtable->tsize);

                        for (NODE *node = hhtable->table[hash]; node != NULL; node = node->next)
                            if (!strcmp(key, node->key)) 
                                return NULL;

                        if ((hhtable->count / hhtable->tsize) >= hhtable->lf)
                            if (!resize_ht(hhtable, hhtable->tsize * 2))
                                return NULL;

                        if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                            return NULL;
                        
                        strcpy(new_node->key, key);
                        new_node->value = *value;

                        new_node->next = hhtable->table[hash];
                        hhtable->table[hash] = new_node;

                        ++hhtable->count;

                        return new_node;
                    }

                    NODE *update_ht(HHTABLE hhtable, const char *key, const PERSON *value)
                    {
                        NODE *new_node;
                        size_t hash;

                        hash = hash_func(key, hhtable->tsize);

                        for (NODE *node = hhtable->table[hash]; node != NULL; node = node->next)
                            if (!strcmp(key, node->key)) {
                                node->value = *value;
                                return node;
                            }

                        if ((hhtable->count / hhtable->tsize) >= hhtable->lf)
                            if (!resize_ht(hhtable, hhtable->tsize * 2))
                                return NULL;

                        if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                            return NULL;

                        strcpy(new_node->key, key);
                        new_node->value = *value;

                        new_node->next = hhtable->table[hash];
                        hhtable->table[hash] = new_node;

                        ++hhtable->count;

                        return new_node;
                    }

                    PERSON *find_ht(HHTABLE hhtable, const char *key)
                    {
                        size_t hash;

                        hash = hash_func(key, hhtable->tsize);
                        
                        for (NODE *node = hhtable->table[hash]; node != NULL; node = node->next)
                            if (!strcmp(key, node->key))
                                return &node->value;

                        return NULL;
                    }

                    bool remove_ht(HHTABLE hhtable, const char *key)
                    {
                        size_t hash;
                        NODE *node, *prev_node;

                        hash = hash_func(key, hhtable->tsize);

                        prev_node = NULL;
                        node = hhtable->table[hash];
                        while (node != NULL) {
                            if (!strcmp(key, node->key)) {
                                if (hhtable->table[hash] == node) 
                                    hhtable->table[hash] = node->next;
                                else
                                    prev_node->next = node->next;
                                free(node);
                                --hhtable->count;
                                
                                return true;
                            }

                            prev_node = node;
                            node = node->next;
                        }

                        return false;
                    }

                    bool resize_ht(HHTABLE hhtable, size_t new_size)
                    {
                        NODE **new_table;
                        NODE *node, *temp_node;
                        size_t hash;

                        if (new_size <= hhtable->tsize)
                            return false;

                        if ((new_table = (NODE **)malloc(new_size * sizeof(NODE *))) == NULL)
                            return false;

                        for (size_t i = 0; i < new_size; ++i)
                            new_table[i] = NULL;

                        for (size_t i = 0; i < hhtable->tsize; ++i) {
                            node = hhtable->table[i];
                            while (node != NULL) {
                                temp_node = node->next;
                                hash = hash_func(node->key, new_size);
                                node->next = new_table[hash];
                                new_table[hash] = node;
                                node = temp_node;
                            }
                        }

                        free(hhtable->table);
                        hhtable->table = new_table;
                        hhtable->tsize = new_size;

                        return true;
                    }

                    void clear_ht(HHTABLE hhtable)
                    {
                        NODE *node, *temp_node;
                        
                        for (size_t i = 0; i < hhtable->tsize; ++i) {
                            node = hhtable->table[i];
                            while (node != NULL) {
                                temp_node = node->next;
                                free(node);
                                node = temp_node;
                            }
                            hhtable->table[i] = NULL;
                        }
                        hhtable->count = 0;
                    }

                    void destroy_ht(HHTABLE hhtable)
                    {
                        NODE *node, *temp_node;

                        for (size_t i = 0; i < hhtable->tsize; ++i) {
                            node = hhtable->table[i];
                            while (node != NULL) {
                                temp_node = node->next;
                                free(node);
                                node = temp_node;
                            }
                        }

                        free(hhtable);
                    }

                    static size_t hash_func(const char *str, size_t tsize)
                    {
                        size_t hash = 0;

                        while (*str != '\0') {
                            hash = (13 * hash + *str) % tsize;
                            ++str;
                        }

                        return hash;
                    }

                /* app.c */
                    #include <stdio.h>
                    #include <stdlib.h>
                    #include <string.h>
                    #include <time.h>
                    #include "htable.h"

                    void get_random_record(char *key, PERSON *per);

                    int main(void)
                    {
                        HHTABLE hhtable;
                        char name[32];
                        PERSON per;
                        PERSON specific_per = {"Kaan Aslan", 34, 123456};
                        PERSON *retper;

                        srand((unsigned)time(NULL));

                        if ((hhtable = create_ht(10)) == NULL) {
                            fprintf(stderr, "cannot allocate memory!..\n");
                            exit(EXIT_FAILURE);
                        }

                        for (int i = 0; i < 1000; ++i) {

                            if (i == 500) {
                                if (insert_ht(hhtable, "Kaan Aslan", &specific_per) == NULL) {
                                    fprintf(stderr, "cannot insert item!..\n");
                                    exit(EXIT_FAILURE);
                                }
                            }
                            else  {
                                get_random_record(name, &per);
                                
                                if (insert_ht(hhtable, name, &per) == NULL) {
                                    fprintf(stderr, "cannot insert item!..\n");
                                    exit(EXIT_FAILURE);
                                }
                            }
                        }
                        
                        if ((retper = find_ht(hhtable, "Kaan Aslan")) != NULL)
                            printf("Found: %s, %d, %d\n", retper->name, retper->city, retper->no);
                        else
                            printf("cannot find key!..\n");
                            
                        strcpy(per.name, "Kaan Aslan");
                        per.city = 35;
                        per.no = 1000;

                        if (update_ht(hhtable, "Kaan Aslan", &per) == NULL)
                            printf("Update failed!..\n");

                        if ((retper = find_ht(hhtable, "Kaan Aslan")) != NULL)
                            printf("Found: %s, %d, %d\n", retper->name, retper->city, retper->no);
                        else
                            printf("cannot find key!..\n");

                        printf("count: %zd\n", count_ht(hhtable));
                        printf("tsize: %zd\n", tsize_ht(hhtable));

                        destroy_ht(hhtable);

                        return 0;
                    }

                    void get_random_record(char *key, PERSON *per)
                    {
                        int i;

                        for (i = 0; i < 31; ++i) 
                            key[i] = per->name[i] = rand() % 26 + 'A';
                        per->name[i] = key[i] = '\0';

                        per->city = rand() % 81;
                        per->no = rand() % 1000000;
                    }

        Anımsanacağı gibi hash tablolarının diğer bir gerçekleştirimi de "açık adresleme (open addressing)" denilen yöntem grubuydu. Açık adresleme "yoklama (probing)" biçimine göre çeşitli alt yöntemlere ayrılıyordu. Açık adreslemenin en yaygın ve basit biçimi "doğrusal
        yoklama (linear probing)" denilen biçimidir. Doğrusal yoklama (linear probing) oldukça basit bir fikre dayanmaktadır. Bu yöntemde yine hash tablosu oluşturulur. Ancak hash tablosunda bağlı listelerin adresleri tutulmaz bizzat değerlerin kendisi tutulur. Tabloya
        eleman ekleneceği zaman yine anahtardan bir hash değeri elde edilir. Doğrudan değer tablonun hash ile elde edilen indeksine yerleştirilir. Başka bir anahtar aynı hash değerini verdiğinde (yani çakışma durumu oluştuğunda) o indeksten itibaren boş yer bulunana kadar
        yan yana indekslere sırasıyla bakılır. Örneğin hash olarak 123 değerini elde etmiş olalım. Tablonun 123'üncü elemanın dolu olduğunu düşünelim. Bu durumda 124'üncü elemanına bakarız. O da doluysa 125'inci elemanına bakarız. Ta ki boş bir indeks bulunana kadar. Değeri
        ilk boş indekse yerleştiririz. Tabii bu durumda nasıl başka bir değer bizim indeksimize yerleşmişse biz de aslında başka bir değerin indeksine yerleşmiş oluruz. Ancak bizim yerleştiğimiz indeks için hash'e sahip olan değer de bizim yaptığımız gibi ilk boş yer bulunana
        kadar ilerleyecektir. Bu yöntemde arama işlemi de benzer biçimde yapılmaktadır. Yani aranacak elemanın hash değeri elde edilir. O indekse başvurulur. Değer o indekste değilse değer bulunana kadar ya da boş bir slot (bucket) görülene kadar yan yana diğer indekslere
        bakılır. Anahtara dayalı eleman silme de benzer biçimde yapılmaktadır. Ancak eleman silindiğinde ilgili slotun (bucket) boşaltılması arama işlemlerinde sorunlara yol açabilecektir. Burada yöntemlerden biri silinen elemanın slotunu boş yapmayıp silinmenin özel bir
        değerler belirtilmesidir. Örneğin her slot için bir status bayrağı tutulabilir. Bu status bayrağı ilgili slotun "dolu" olduğunu", "boş" olduğubnu ya da "silinmiş" olduğunu belirtebilir. Böylece arama sırasında "silinmiş" slotlar görüldüğünde durulmaz. İlk boş slot
        görüldüğünde durulur. Tabii silinmiş slotlara yeni elemanlar eklenebilir.
            * Örnek 1, Aşağıda "linear probing" yöntemine bir örnek verilmiştir.
                /* htable.h */
                    #ifndef HASHTABLE_
                    #define HASHTABLE_

                    #include <stddef.h>
                    #include <stdbool.h>

                    /* Symbolic Constants */

                    #define HT_DEF_LOAD_FACTOR		0.75
                    #define HT_STATUS_EMPTY			0
                    #define HT_STATUS_INUSE			1
                    #define HT_STATUS_DELETED		2

                    /* Type Declarations */

                    typedef struct tagPERSON {
                        char name[32];
                        int city;
                        int no;
                    } PERSON;

                    typedef struct tagBUCKET {
                        int status;
                        char key[32];
                        PERSON value;
                    } BUCKET;

                    typedef struct tagHTABLE {
                        BUCKET *ht;
                        size_t tsize;
                        size_t count;
                        double lf;
                    } HTABLE, *HHTABLE;

                    /* Function Prototypes */

                    HHTABLE create_lf_ht(size_t tsize, double lf);
                    bool insert_ht(HHTABLE hhtable, const char *key, const PERSON *value);
                    bool update_ht(HHTABLE hhtable, const char *key, const PERSON *value);
                    bool remove_ht(HHTABLE hhtable, const char *key);
                    void clear_ht(HHTABLE hhtable);
                    void destroy_ht(HHTABLE hhtable);
                    PERSON *find_ht(HHTABLE hhtable, const char *key);


                    bool resize_ht(HHTABLE hhtable, size_t new_size);

                    /* inline Function Definitions */

                    static inline size_t count_ht(HHTABLE hhtable)
                    {
                        return hhtable->count;
                    }

                    static inline size_t tsize_ht(HHTABLE hhtable)
                    {
                        return hhtable->tsize;
                    }

                    static inline HHTABLE create_ht(size_t tsize)
                    {
                        return create_lf_ht(tsize, HT_DEF_LOAD_FACTOR);
                    }

                    #endif

                /* htable.c */
                    #include <stdio.h>
                    #include <stdlib.h>
                    #include <string.h>
                    #include "hashtable.h"

                    static size_t hash_func(const char *str, size_t tsize);

                    HHTABLE create_lf_ht(size_t tsize, double lf)
                    {
                        HHTABLE hhtable;

                        if ((hhtable = (HHTABLE)malloc(sizeof(HTABLE))) == NULL)
                            return NULL;

                        if ((hhtable->ht = (BUCKET *)malloc(tsize * sizeof(BUCKET))) == NULL) {
                            free(hhtable);
                            return NULL;
                        }

                        for (size_t i = 0; i < tsize; ++i)
                            hhtable->ht[i].status = HT_STATUS_EMPTY;

                        hhtable->tsize = tsize;
                        hhtable->lf = lf;
                        hhtable->count = 0;

                        return hhtable;
                    }

                    bool insert_ht(HHTABLE hhtable, const char *key, const PERSON *value)
                    {
                        size_t index;

                        if (hhtable->count >= hhtable->tsize)
                            return false;

                        if (((double)hhtable->count / hhtable->tsize) >= hhtable->lf)
                            if (!resize_ht(hhtable, hhtable->tsize * 2))
                                return false;

                        index = hash_func(key, hhtable->tsize);

                        while (hhtable->ht[index].status != HT_STATUS_EMPTY) {
                            if (!strcmp(hhtable->ht[index].key, key))
                                return false;
                            index = (index + 1) % hhtable->tsize;
                        }

                        strcpy(hhtable->ht[index].key, key);
                        hhtable->ht[index].value = *value;
                        hhtable->ht[index].status = HT_STATUS_INUSE;
                        ++hhtable->count;

                        return true;
                    }

                    bool update_ht(HHTABLE hhtable, const char *key, const PERSON *value)
                    {
                        size_t index;

                        if (hhtable->count >= hhtable->tsize)
                            return false;

                        if (((double)hhtable->count / hhtable->tsize) >= hhtable->lf)
                            if (!resize_ht(hhtable, hhtable->tsize * 2))
                                return false;

                        index = hash_func(key, hhtable->tsize);

                        while (hhtable->ht[index].status != HT_STATUS_EMPTY) {
                            if (!strcmp(hhtable->ht[index].key, key)) {
                                hhtable->ht[index].value = *value;
                                return true;
                            }
                            index = (index + 1) % hhtable->tsize;
                        }

                        strcpy(hhtable->ht[index].key, key);
                        hhtable->ht[index].value = *value;
                        hhtable->ht[index].status = HT_STATUS_INUSE;
                        ++hhtable->count;

                        return true;
                    }

                    bool remove_ht(HHTABLE hhtable, const char *key)
                    {
                        size_t index, hash;

                        hash = index = hash_func(key, hhtable->tsize);

                        do {
                            if (hhtable->ht[index].status == HT_STATUS_EMPTY)
                                break;

                            if (hhtable->ht[index].status == HT_STATUS_INUSE && !strcmp(hhtable->ht[index].key, key)) {
                                hhtable->ht[index].status = HT_STATUS_DELETED;
                                --hhtable->count;
                                return true;
                            }
                                
                            index = (index + 1) % hhtable->tsize;
                        } while (index != hash);

                        return false;
                    }

                    PERSON *find_ht(HHTABLE hhtable, const char *key)
                    {
                        size_t index, hash;

                        hash = index = hash_func(key, hhtable->tsize);

                        do {
                            if (hhtable->ht[index].status == HT_STATUS_EMPTY)
                                break;
                            
                            if (hhtable->ht[index].status == HT_STATUS_INUSE && !strcmp(hhtable->ht[index].key, key))
                                return &hhtable->ht[index].value;

                            index = (index + 1) % hhtable->tsize; 
                        } while (index != hash);

                        return NULL;
                    }

                    bool resize_ht(HHTABLE hhtable, size_t new_size)
                    {
                        BUCKET *new_ht;
                        size_t index;

                        if (new_size <= hhtable->tsize)
                            return false;

                        if ((new_ht = (BUCKET *)malloc(new_size * sizeof(BUCKET))) == NULL)
                            return false;

                        for (size_t i = 0; i < new_size; ++i)
                            new_ht[i].status = HT_STATUS_EMPTY;

                        for (size_t i = 0; i < hhtable->tsize; ++i) {
                            if (hhtable->ht[i].status == HT_STATUS_INUSE) {
                                index = hash_func(hhtable->ht[i].key, new_size);

                                while (new_ht[index].status != HT_STATUS_EMPTY)
                                    index = (index + 1) % new_size;
                                new_ht[index] = hhtable->ht[i];
                            }
                        }

                        free(hhtable->ht);
                        hhtable->ht = new_ht;
                        hhtable->tsize = new_size;

                        return true;
                    }

                    void clear_ht(HHTABLE hhtable)
                    {
                        for (size_t i = 0; i < hhtable->tsize; ++i)
                            hhtable->ht[i].status = HT_STATUS_EMPTY;

                        hhtable->count = 0;
                    }

                    void destroy_ht(HHTABLE hhtable)
                    {
                        free(hhtable->ht);
                        free(hhtable);
                    }

                    static size_t hash_func(const char *str, size_t tsize)
                    {
                        size_t hash = 0;

                        while (*str != '\0') {
                            hash = (13 * hash + *str) % tsize;
                            ++str;
                        }

                        return hash;
                    }

                /* app.c */
                    #include <stdio.h>
                    #include <stdlib.h>
                    #include <time.h>
                    #include "hashtable.h"

                    void get_random_record(char *key, PERSON *per);

                    int main(void)
                    {
                        HHTABLE hhtable;
                        char name[32];
                        PERSON per, *pper;
                        PERSON specific_per = {"Kaan Aslan", 34, 123456};

                        srand((unsigned)time(NULL));

                        if ((hhtable = create_ht(10)) == NULL) {
                            fprintf(stderr, "cannot allocate memory!..\n");
                            exit(EXIT_FAILURE);
                        }

                        for (int i = 0; i < 1000; ++i) {
                            if (i == 500) {
                                if (!insert_ht(hhtable, "Kaan Aslan", &specific_per)) {
                                    fprintf(stderr, "cannot insert item!..\n");
                                    exit(EXIT_FAILURE);
                                }
                            }
                            else  {
                                get_random_record(name, &per);

                                if (!insert_ht(hhtable, name, &per)) {
                                    fprintf(stderr, "cannot insert item!..\n");
                                    exit(EXIT_FAILURE);
                                }
                            }
                        }

                        if (remove_ht(hhtable, "Kaan Aslan"))
                            printf("Item removed...\n");
                        else
                            printf("cannot remove item!..\n");

                        if ((pper = find_ht(hhtable, "Kaan Aslan")) != NULL) 
                            printf("Found: %s %d %d\n", pper->name, pper->city, pper->no);
                        else 
                            printf("cannot find record!..\n");

                        destroy_ht(hhtable);

                        return 0;
                    }

                    void get_random_record(char *key, PERSON *per)
                    {
                        int i;

                        for (i = 0; i < 31; ++i)
                            key[i] = per->name[i] = rand() % 26 + 'A';
                        per->name[i] = key[i] = '\0';

                        per->city = rand() % 81;
                        per->no = rand() % 1000000;
                    }

        Aslında hash tablolarının oluşturulmasında kullanılan "açık adresleme (open addresing)" yönteminde "linear probing" dışında başka yoklama yöntemleri de vardır. Örneğin "quadratic probing" yönteminde çakışma durumunda slotlara sırasıyla bakılmaz. İkinci derece bir
        polinom yoluyla bakılır. Örneğin ekleme yapmaya çalışalım ve anahtara ilişkin hash değeri 20 olsun. 20 numaralı slot'tun dolu olduğunu düşünelim. Biz bu yöntemde 20 + 1, 20 + 2, 20 + 9, 20 + 16 gibi karesel değerlerle yoklama yaparız. Çift hash'leme (double hasing)
        yönteminde ise önce bir hash fonksiyonu ile indeks elde edilir. Eğer çakışma olursa atlanacak miktar ikinci bir hash fonksiyonuna başvurularak belirlenir. Yukarıdaki yöntemlerin en çok tercih edilenleri "ayrı zincir oluşturma "separate chaining" ve "açık adresleme
        linear probing" yöntemleridir.

        >>> Biz tek bağlı listelerde bir önceki düğümün sonraki düğümü göstermesini sağladık. Çift bağlı listelerde de bir düğüm hem önceki hem de sonraki düğümü gösteriyordu. Pekiyi bir düğüm birden fazla düğümü gösterirse bu nasıl veri yapısı olur? İşte düğümlerin birden
        fazla düğümü göstermesi durumunda oluşan veri yapılarına "ağaç (tree)" ve "graf (graph)" denilmektedir. Biz önce ağaçları sonra grafları inceleyeceğiz.
            >>>> "Ağaç (tree)" : Her ağacın bir kökü vardır. Kök kendisine gelinemeyen ancak kendisinden her düğüme erişilebilen özel bir düğümdir. Ağaçlarda kök düğümden her düğüme gitmenin yalnızca tek bir yolu vardır. Eğer bir düğüme birden fazla yoldan gidilebiliyorsa
            bu tür veri yapılarına "ağaç" değil "graf" denilmektedir. Ağaçlar konusunu iyi anlayabilmek için ağaç terminolojisini biliyor olmak gerekir. Ağaçlarda bir düğümden gidel sonraki düğümlere "o düğümün alt düğümleri (child nodes)" denilmektedir. Kök düğüm haricindeki
            her düğümün tek bir "üst düğümü (parent node)" vardır. Zaten kök düğüm "üst düğümü olmayan dolayısıyla kendisine bir yerden gelinemeyen" tek düğümdür. Ağacın en altında artık başka bir düğüme gidilemeyen düğümlere "yaprak (leaf)" düğümler denilmektedir. Bir ağaçta
            bir düğümlerin maksimum sahip olabileceği alt düğüm sayısı belirlenmiş olabilir. Bunun n olduğunu varsayalım. Böyle ağaçlara "'li ağaç" denilmektedir. Örneğin bir ağaçta her düğümün "en fazla düğümü" olabiliyorsa böyle ağaçlara "ikili ağaçlar (binary trees)", en
            fazla üç düğümü olabiliyorsa bunlara "üçlü ağaçlar (ternary tree)", en fazla n düğümü olabiliyorsa bunlara "n'li ağaçlar (n'ary tree)" denilmektedir. Uygulamada en fazla karşılaşılan ağaçlar ikili ağaçardır. İkili ağaçlarda bir düğümün sıfır tane alt düğümü
            olabilir. Zaten bu durumda bu düğüm bir yaprak durumundadır. Bir tane alt düğümü olabilir. Ya da en fazla ki tane alt düğümü olabilir. Ağaçlarda "her düğümün bir yükseliği (height)" vardır. Düğümün yüksekliği kök düğümden o düğüme gelirken kat edilen yol (edge)
            sayısı ile belirlenir. Kök düğüm yüksekliği 0'dır. Ağacın en yüksek düğümünün yüksekliğine "ağacın yüksekliği" de denilmektedir. Bir ağaçta bütün yaprak düğümlerin yükseklikleri arasındaki fark belli bir değerden büyük değilse (bu değer 1, 2, 3 gibi olabilir) bu 
            ağaçlara "dengelenmiş ağaçlar (balanced trees)" denilmektedir. Örneğin bu farklılık 1 olarak tespit edilmişse bu durum yaprakların yükseklikleri arasında en fazla 1 fark olacağı anlamına gelmektedir. Bir N'li ağaçta ağacın en alt kademe dışında tüm kademelerindeki
            düğümlerinin tam olarak N tane alt düğümü varsa ve ağacın tüm yaprakları aynı yüksekliğe sahipse böyle ağaçlara "tam dolu olan ağaçlar (full trees)" denilmektedir. Bir N'li ağaç en son kademe (en alt kademe) dışında tam dolu ise ve son kademedeki düğümler solda
            soldan sağa toplanmışsa böyle ağaçlara "tam ağaçlar (complete tree)" denilmektedir. Uygulamada en fazla kullanılan ağaçlar ikili ağaçlardır. Yukarıda da belirttiğimiz gibi ikili ağaçlarda her düğümün en fazla iki alt düğümü olabilmektedir. Bir ikili ağaca ilişkin
            düğüm aşağıdaki gibi bir yapıyla temsil edilebilir:

                typedef struct tagNODE {
                    DATATYPE val;
                    struct tagNODE *left;
                    struct tagNODE *right;
                } NODE;

            Burada val elemanı düğüme iliştirilen bilgiyi belirtmektedir. left ve right elemanları alt düğümlerin yerlerini tutmaktadır. Eğer düğümün sol ya da sağ alt düğümü yoksa bu left ve right elemanları NULL adres içerebilir. Tabii ağacın kök düğümünün yerini de bir
            biçimde tutmamız gerekir. Bu durumda ağacı temsil eden yapı da şöyle olabilir:

                typedef struct tagBTREE {
                    NODE *root;
                    size_t count;
                } BTREE, *HBTREE;

            Ağaçlar en çok "arama (search)" amaçlı kullanılmaktadır. Arama amacıyla kullanılan ağaçlara "arama ağaçları (search trees)" denilmektedir. Arama ağaçları için en çok kullanılan ağaçlar ikili ağaçlardır. Bunlara "ikili arama ağaçları (binary search trees)" de
            denilmektedir. Arama ağaçları oluşturulurken bilgiler düğümlerin içerisine yerleştirilir. Tabii düğümler belli bir kurala göre ağaca eklenir. Arama işlemi bir anahtara göre yapılacağından arama ağaçlarındaki düğümlerin de "anahtar" ve "değer" çiftlerini tutaması
            gerekir. Örneğin:

                typedef struct tagNODE {
                    KEY key;
                    VALUE value;
                    struct tagNODE *left;
                    struct tagNODE *right;
                } NODE;

            Burada key arama için kullanılan anahtarı value ise arama sonucunda elde edilecek olan değeri belirtmektedir. Örneğin anahtar bir kişinin numarasını belirtiyor olabilir değer de o kişinin bilgilerini belirtiyor olabilir:

                typedef struct tagNODE {
                    int key;
                    PERSON value;
                    struct tagNODE *left;
                    struct tagNODE *right;
                } NODE;

            Bir ikili arama ağacında eleman eklenirken ekleme noktası "küçükler sola büyükler sağa" olacak biçimde yapılmaktadır. Yani kök düğümden girilir. Eklenecek anahtar düğümdeki anahtarla karşılaştırılır. Eklenecek anahtar düğümdeki anahtardan küçükse sola doğru,
            büyükse sağa doğru ilerlenir. Örneğin ağaca sırasıyla 40 60 25 16 52 8 değerleri eklenecek olsun. Ağaöç henüz boş olduğuna göre 40 değeri köke eklenir:

                40

            Sonra 60 değeri 40'dan büyük olduğu için 40'ın sağına eklenir:

                40
                    60

            Sonra 25 değeri 40'tan küçük olduğu için 40'ın soluna eklenir:

                        40
                25        60

            Sonra 16 değeri 40'tan küçük ve 25'ten küçük olduğu için 25'in soluna eklenir:

                            40
                    25        60
                16

            Sonra 52 değeri 40'tan büyük 60'tan küçük olduğuna göre 60'ın soluna eklenir:

                            40
                    25           60
                16           52   

            8 değeri 40'tan küçük, 25'ten küçük ve 16'dan küçük olduğuna göre 16'nın soluna eklenir:

                                40
                        25           60
                    16           52   
                8

            İkili ağaçlarda eleman arama benzer biçimde yapılmaktadır. Kök düğümden girilir aranan anahtar ile düğümdeki anahtar karşılaştırılır. Eğer aranan anahtar düğümdeki anahtardan küçükse sola, büyükse sağa doğru ilerlenir. Yapraklara gelindiğinde yani daha fazla
            sola ya da sağa gidilemediğinde arama sonlandırılır. İkili arama ağacına eleman eklemenin en kötü durumdaki (worst case) karmaşıklığı O(N) biçimindedir. Dengelenmiş ağaçlarda ortalama karmaşıklık O(log N) biçimindedir. Arama işlemleri de en kötü durumda O(N)
            dengelenmiş ağaçlarda O(log N) karmaşıklıktadır. Çünkü arama sırasında aslında tıpkı "ikili aramada (binary search)" olduğu gibi sürekli iki bölme yaaparak ilerlenmektedir. Ağaçların dolaşılması özyinelemeli bir biçimde yapılabilir. İkili ağaçlar dört biçimde
            dolaşılabilmektedir:

                -> In-Order dolaşım
                -> Pre-Order dolaşım
                -> Post-Order dolaşım
                -> Breadt-First Dolaşım

            Buradaki "in", "pre" ve "post" sözcükleri alt düğümlere göre üst düğümün hangi sırada dolaşılacağını belirtmektedir. Bu dolaşımlar soldan-sağa ya da sağdan sola yapılabilmektedir. Bu dolaşımlardan,
                >>>>> "In-order" : soldan sağa dolaşım aşağıdaki temsili koddaki (pseudo code) gibi yapılmaktadır:

                    void inorder_walk_lr(Node *node)
                    {
                        if (node->left != NULL)
                            inorder_walk_lr(node->left);
                        
                        printf(node->val);

                        if (node->right != NULL)
                            inorder_walk_lr(node->right);
                    }

                In-order soldan sağa dolaşım ağacın anahtara göre küçükten büyüğe doğru dolaşımını sağlamaktadır. In-order soldan sağa dolaşımda önce sol koldan ilerlenmeye çalışıldığına sonra ana düğümün ziyaret edildiğine, sonra da sağ koldan ilerlenmeye çalışıldığına
                dikkat ediniz. In-order sağdan sola dolaşımda bunun tersi yapılmaktadır:

                    void inorder_walk_rl(Node *node)
                    {
                        if (node->right != NULL)
                            inorder_walk_rl(node->right);
                            
                        printf(node->val);

                        if (node->left != NULL)
                            inorder_walk_rl(node->left);
                    }

                In-order sağdan sola dolaşım anahtara göre büyükten küçüğe bir dolaşıma yol açmaktadır.

                >>>>> "Post-order" : dolaşımda önce alt düğümler sonra da ana düğün ziyaret edilmektedir. Bu dolaşım da soldan sağa ya da sağdan sola yapılabilmektedir. Temsili kodu aşağıdaki gibidir:

                    void postorder_walk_lr(Node *node)
                    {
                        if (node->left != NULL)
                            postorder_walk_lr(node->left);
                        
                        if (node->right != NULL)
                            postorder_walk_lr(node->right);

                        printf(node->val);
                    }
				
                postoreder dolaşım sağdan sola da yapılabilir. Ancak genel olarak bu ikisi arasında programcıyı ilgilendirecek önemli bir farklılık yoktur. Post-order dolaşım ikili ağaçtaki düğümleri free hale getirmek için gerekmektedir. Çünkü ikili ağaçtaki düğümleri free
                hale getirme işlemi önce alt düğümlerin sonra ana düğümün free hale getirilmesiyle gerçekleştirilmektedir. 

                >>>>> "Pre-order" : dolaşımda ise önce ana düğüm ziyaret edilir. Sonra alt düğümler ziyaret edilir. Tabii bu da soldan sağa ya da sağdan sola yapılabilmektedir. Ancak dolsdan sağa dolaşımla sağdan sola dolaşım arasında programcıyı ilgilendiren önemli bir
                farklılık yoktur. Pre-order soldan sağa dolaşımın temsili kodu şöyledir:

                    void preorder_walk_lr(Node *node)
                    {
                        printf(node->val);
                        
                        if (node->left != NULL)
                            preorder_walk_lr(node->left);
                        
                        if (node->right != NULL)
                            preorder_walk_lr(node->right);
                    }
        
                >>>>> 	"breadth-first" : Kademe Kademe dolaşım denilmektedir. Örneğin:

                                        1
                            2					   3
                        4	         5		    6             7
                    8     9     10    11    12   13       14   15   
	 	
                Buradaki numaralar breadt-first dolaşımın nasıl yapıldığını açıklamaktadır. Breadth-first dolaşım için bir kuyruk sistemine gereksinim vardır. Algoritmada bir düğüm üzerinde işlem yapıldıktan sonra hemen onun alt düğümleri FIFO kuyruk sistemine atılır. İşlem
                yapılacak düğümler kuyruk sisteminden çekilir. Dolaşımın temsili kodu şöyledir:

                    put(root);
                    while ((node = get()) != NULL) {
                        process(node);
                        if (node->left != NULL)
                            put(node->left);
                        if (node->right != NULL)
                            put(node->right);
                    }

            İkili ağaçlarda en karmaşık işlemlerden biri belli bir düğümün silinmesidir. Bu işlemin karmaşık olmasının nedeni birden fazla özel duruma sahip olmasındadır. İkili ağaçta düğüm silerken özel durumlar şunlar olabilir:

                -> Silinecek düğüm bir yaprak düğüm ise tek yapılacak şey onun üst düğümünün ilgili göstericisini NULL yapmaktır.

                -> Silinecek düğümün tek bir alt düğümü varsa işlem yine kolaydır. Silinecek düğümün var olan düğümü silinecek düğümün yerine taşınır. 

                -> Silincek düğümün iki alt düğümünün de olması durumunda işlem biraz karmaşık hale gelmektedir. Bu durumda silinecek düğüm yerine geçecek düğüm "ya sol kolun en büyük düğümü" ya da "sağ kolun en küçük düğümü" olabilir. Fakat bu durumda ağaçta birkaç
                güncellemenin yapılması gerekmektedir. Silinecek düğümünyerine geçecek olan düğümün süt düğümünün ve silinecek düğümün üst düğümünün gencellenmesi gerekmektedir. 
                
                -> Silinecek düğümün kök düğüm olması durumunda ağacın kökünü gösteren göstericinin de güncellenmesi gerekmektedir. 

            Aşağıda ikili arama ağacının gerçekleştirilmesine ilişkin bir örneek verilmiştir.
                * Örnek 1,
                    /* binarytree. h */
                        #ifndef BINARYTREE_H_
                        #define BINARYTREE_H_

                        #include <stddef.h>
                        #include <stdbool.h>

                        /* Type Declararions */

                        typedef struct tagPERSON {
                            char name[32];
                            int city;
                        } PERSON;


                        typedef struct tagNODE {
                            int key;
                            PERSON value;
                            struct tagNODE *left;
                            struct tagNODE *right;
                        } NODE;

                        typedef struct tagQNODE {
                            struct tagQNODE *next;
                            NODE *node;
                        } QNODE;

                        typedef struct tagBTREE {
                            NODE *root;
                            size_t count;
                            QNODE *head;
                            QNODE *tail;
                        } BTREE, *HBTREE;

                        /* Function Prototypes */

                        HBTREE create_bt(void);
                        bool insert_item_bt(HBTREE hbtree, int key, const PERSON *value);
                        bool insert_item_alternative_bt(HBTREE hbtree, int key, const PERSON *value);
                        bool walk_inorder_lr_bt(HBTREE hbtree, bool (*proc)(int, PERSON *));
                        bool walk_inorder_rl_bt(HBTREE hbtree, bool (*proc)(int, PERSON *));
                        bool walk_postorder_lr_bt(HBTREE hbtree, bool (*proc)(int, PERSON *));
                        bool walk_preorder_lr_bt(HBTREE hbtree, bool (*proc)(int, PERSON *));
                        bool walk_breadth_first_bt(HBTREE hbtree, bool (*proc)(int, PERSON *));
                        bool delete_bt(HBTREE hbtree, int key);
                        void clear_bt(HBTREE hbtree);
                        void destroy_bt(HBTREE hbtree);

                        /* inline Function Fefinitions */

                        static inline size_t count_bt(HBTREE hbtree)
                        {
                            return hbtree->count;
                        }

                        #endif

                    /* binarytree.c */
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include "binarytree.h"

                        static bool walk_inorder_lr_recur(NODE *node, bool (*proc)(int, PERSON *));
                        static bool walk_inorder_rl_recur(NODE *node, bool (*proc)(int, PERSON *));
                        static bool walk_postorder_lr_recur(NODE *node, bool (*proc)(int, PERSON *));
                        static bool walk_preorder_lr_recur(NODE *node, bool (*proc)(int, PERSON *));
                        static void clear_recur(NODE *node);
                        static void create_queue(HBTREE hbtree);
                        static NODE *put_queue(HBTREE hbtree, NODE *node);
                        static NODE *get_queue(HBTREE hbtree);
                        static void destroy_queue(HBTREE hbtree);
                        static void subtree_shift(HBTREE hbtree, NODE *node1, NODE *node2, NODE *node3);

                        HBTREE create_bt(void)
                        {
                            HBTREE hbtree;

                            if ((hbtree = (HBTREE)malloc(sizeof(BTREE))) == NULL)
                                return NULL;

                            hbtree->root = NULL;
                            hbtree->count = 0;

                            return hbtree;
                        }

                        bool insert_item_bt(HBTREE hbtree, int key, const PERSON *value)
                        {
                            NODE *new_node, *node, *parent_node;

                            if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                                return false;
                            new_node->key = key;
                            new_node->value = *value;
                            new_node->left = NULL;
                            new_node->right = NULL;
                            
                            if (hbtree->root == NULL) {
                                hbtree->root = new_node;
                                ++hbtree->count;
                                return true;
                            }
                            node = hbtree->root;

                            while (node != NULL) {
                                parent_node = node;
                                if (key < node->key)
                                    node = node->left;
                                else if (key > node->key)
                                    node = node->right;
                                else {
                                    node->value = *value;
                                    return true;
                                }
                            }

                            if (key < parent_node->key)
                                parent_node->left = new_node;
                            else
                                parent_node->right = new_node;

                            ++hbtree->count;

                            return true;
                        }

                        bool insert_item_alternative_bt(HBTREE hbtree, int key, const PERSON *value)
                        {
                            NODE *new_node, *node;

                            if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
                                return false;
                            new_node->key = key;
                            new_node->value = *value;
                            new_node->left = NULL;
                            new_node->right = NULL;

                            if (hbtree->root == NULL) {
                                hbtree->root = new_node;
                                ++hbtree->count;
                                return true;
                            }
                            node = hbtree->root;

                            while (node != NULL) {
                                if (key < node->key)
                                    if (node->left == NULL) {
                                        node->left = new_node;
                                        break;
                                    }
                                    else
                                        node = node->left;
                                else if (key > node->key) 
                                    if (node->right == NULL) {
                                        node->right = new_node;
                                        break;
                                    }
                                    else
                                        node = node->right;
                                else {
                                    node->value = *value;
                                    return true;
                                }
                            }

                            ++hbtree->count;

                            return true;
                        }

                        bool walk_inorder_lr_bt(HBTREE hbtree, bool (*proc)(int, PERSON *))
                        {
                            if (hbtree->root != NULL)
                                return walk_inorder_lr_recur(hbtree->root, proc);

                            return true;
                        }

                        bool walk_inorder_rl_bt(HBTREE hbtree, bool (*proc)(int, PERSON *))
                        {
                            if (hbtree->root != NULL)
                                return walk_inorder_rl_recur(hbtree->root, proc);

                            return true;
                        }

                        bool walk_postorder_lr_bt(HBTREE hbtree, bool (*proc)(int, PERSON *))
                        {
                            if (hbtree->root != NULL)
                                return walk_postorder_lr_recur(hbtree->root, proc);

                            return true;
                        }

                        bool walk_preorder_lr_bt(HBTREE hbtree, bool (*proc)(int, PERSON *))
                        {
                            if (hbtree->root != NULL)
                                return walk_preorder_lr_recur(hbtree->root, proc);

                            return true;
                        }

                        void clear_bt(HBTREE hbtree)
                        {
                            if (hbtree->root != NULL) {
                                clear_recur(hbtree->root);
                                hbtree->root = NULL;
                                hbtree->count = 0;
                            }
                        }

                        void destroy_bt(HBTREE hbtree)
                        {
                            if (hbtree->root != NULL) 
                                clear_recur(hbtree->root);

                            free(hbtree);
                        }

                        bool walk_breadth_first_bt(HBTREE hbtree, bool (*proc)(int, PERSON *))
                        {
                            NODE *node;
                            bool result = true;

                            create_queue(hbtree);
                            put_queue(hbtree, hbtree->root);

                            while ((node = get_queue(hbtree)) != NULL) {
                                if (!proc(node->key, &node->value)) {
                                    result = false;
                                    break;
                                }
                                if (node->left != NULL)
                                    if (put_queue(hbtree, node->left) == NULL) {
                                        fprintf(stderr, "put_queue cannot allocate memory!..\n");
                                        result = false;
                                        break;
                                    }
                                if (node->right != NULL)
                                    if (put_queue(hbtree, node->right) == NULL) {
                                        result = false;
                                        fprintf(stderr, "put_queue cannot allocate memory!..\n");
                                        break;
                                    }
                            }

                            destroy_queue(hbtree);

                            return result;
                        }

                        bool delete_bt(HBTREE hbtree, int key)
                        {
                            NODE *delete_node, *delete_parent_node, *replace_parent_node, *replace_node;

                            delete_node= hbtree->root;
                            delete_parent_node = NULL;

                            while (delete_node != NULL) {
                                if (delete_node->key == key)
                                    break;
                                delete_parent_node = delete_node;
                                if (key < delete_node->key)
                                    delete_node = delete_node->left;
                                else if (key > delete_node->key )
                                    delete_node = delete_node->right;
                            }

                            if (delete_node == NULL)
                                return false;

                            if (delete_node->left == NULL)
                                subtree_shift(hbtree, delete_parent_node, delete_node, delete_node->right);
                            else if (delete_node->right == NULL)
                                subtree_shift(hbtree, delete_parent_node, delete_node, delete_node->left);
                            else {
                                replace_parent_node = delete_node;
                                replace_node = delete_node->right;
                                while (replace_node->left!= NULL) {
                                    replace_parent_node = replace_node;
                                    replace_node= replace_node->left;
                                }
                                if (replace_parent_node != delete_node) {
                                    subtree_shift(hbtree, replace_parent_node, replace_node, replace_node->right);
                                    replace_node->right= delete_node->right;
                                }
                                subtree_shift(hbtree, delete_parent_node, delete_node, replace_node);
                                replace_node->left = delete_node->left;
                            }

                            free(delete_node);
                            --hbtree->count;

                            return true;
                        }

                        static bool walk_inorder_lr_recur(NODE *node, bool (*proc)(int, PERSON *))
                        {
                            if (node->left != NULL)
                                if (!walk_inorder_lr_recur(node->left, proc))
                                    return false;

                            if(!proc(node->key, &node->value))
                                return false;

                            if (node->right != NULL)
                                if (!walk_inorder_lr_recur(node->right, proc))
                                    return false;

                            return true;
                        }

                        static bool walk_inorder_rl_recur(NODE *node, bool (*proc)(int, PERSON *))
                        {
                            if (node->right != NULL)
                                if (!walk_inorder_rl_recur(node->right, proc))
                                    return false;

                            if (!proc(node->key, &node->value))
                                return false;

                            if (node->left != NULL)
                                if (!walk_inorder_rl_recur(node->left, proc))
                                    return false;
                            
                            return true;
                        }

                        static bool walk_postorder_lr_recur(NODE *node, bool (*proc)(int, PERSON *))
                        {
                            if (node->left != NULL)
                                if (!walk_postorder_lr_recur(node->left, proc))
                                    return false;

                            if (node->right != NULL)
                                if (!walk_postorder_lr_recur(node->right, proc))
                                    return false;

                            if (!proc(node->key, &node->value))
                                return false;

                            return true;
                        }

                        static bool walk_preorder_lr_recur(NODE *node, bool (*proc)(int, PERSON *))
                        {
                            if (!proc(node->key, &node->value))
                                return false;

                            if (node->left != NULL)
                                if (!walk_preorder_lr_recur(node->left, proc))
                                    return false;

                            if (node->right != NULL)
                                if (!walk_preorder_lr_recur(node->right, proc))
                                    return false;

                            return true;
                        }

                        static void clear_recur(NODE *node)
                        {
                            if (node->left != NULL)
                                clear_recur(node->left);

                            if (node->right != NULL)
                                clear_recur(node->right);

                            free(node);
                        }

                        static void create_queue(HBTREE hbtree)
                        {
                            hbtree->head = NULL;
                            hbtree->tail = NULL;
                        }

                        static NODE *put_queue(HBTREE hbtree, NODE *node)
                        {
                            QNODE *new_qnode;

                            if ((new_qnode = (QNODE *)malloc(sizeof(QNODE))) == NULL)
                                return NULL;

                            new_qnode->node = node;
                            new_qnode->next = NULL;

                            if (hbtree->tail != NULL)
                                hbtree->tail->next = new_qnode;
                            else
                                hbtree->head = new_qnode;
                            hbtree->tail = new_qnode;

                            return node;
                        }

                        static NODE *get_queue(HBTREE hbtree)
                        {
                            QNODE *qnode;
                            NODE *rnode;

                            if (hbtree->head == NULL)
                                return NULL;
                            qnode = hbtree->head;
                            hbtree->head = qnode->next;
                            if (hbtree->head == NULL)
                                hbtree->tail = NULL;

                            rnode = qnode->node;
                            free(qnode);

                            return rnode;
                        }

                        static void destroy_queue(HBTREE hbtree)
                        {
                            QNODE *qnode, *temp_qnode;

                            qnode = hbtree->head;

                            while (qnode != NULL) {
                                temp_qnode = qnode->next;
                                free(qnode);
                                qnode = temp_qnode;
                            }
                        }

                        static void subtree_shift(HBTREE hbtree, NODE *node1, NODE *node2, NODE *node3)
                        {
                            if (node1 == NULL)
                                hbtree->root = node3;
                            else if (node1->left == node2)
                                node1->left = node3;
                            else
                                node1->right = node3;
                        }

                    /* app.c */
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include "binarytree.h"

                        bool disp_node(int key, PERSON *value);

                        int main(void)
                        {
                            HBTREE hbtree;
                            PERSON per = {"Noname", 0};
                            int keys[] = {70, 50, 34, 56, 19, 80, 67, 43, 27, 76, 79, 105, 82, 65, 0};

                            if ((hbtree = create_bt()) == NULL) {
                                fprintf(stderr, "cannot create binary tree!..\n");
                                exit(EXIT_FAILURE);
                            }

                            for (int i = 0; keys[i] != 0; ++i)
                                if (!insert_item_alternative_bt(hbtree, keys[i], &per)) {
                                    fprintf(stderr, "cannot insert item: %d\n", keys[i]);
                                    exit(EXIT_FAILURE);
                                }

                            walk_inorder_lr_bt(hbtree, disp_node);
                            printf("\n------------------------------\n");
                            walk_inorder_rl_bt(hbtree, disp_node);
                            printf("\n------------------------------\n");
                            walk_postorder_lr_bt(hbtree, disp_node);
                            printf("\n------------------------------\n");
                            walk_inorder_lr_bt(hbtree, disp_node);
                            printf("\n------------------------------\n");
                            walk_preorder_lr_bt(hbtree, disp_node);
                            printf("\n------------------------------\n");
                            walk_breadth_first_bt(hbtree, disp_node);
                            printf("\n------------------------------\n");
                            if (!delete_bt(hbtree, 70)) {
                                fprintf(stderr, "cannot find item!...\n");
                                exit(EXIT_FAILURE);
                            }
                            
                            walk_breadth_first_bt(hbtree, disp_node);
                            printf("\n------------------------------\n");

                            printf("total item: %jd\n", count_bt(hbtree));

                            destroy_bt(hbtree);

                            return 0;
                        }

                        bool disp_node(int key, PERSON *value)
                        {
                            printf("%d ", key);
                            fflush(stdout);

                            return true;;
                        }

            Biz yukarıdaki örnekte "dengelenmemiş (unbalanced)"	arama ağacı oluşturduk. Dengelenmemiş ağaçlar bir arama performansını düşürebilmektedir. Dengelenmemiş ikili ağaçlarda eleman eklemenin ve aramanın "en kötü durum senaryosu (worst case)" O(N) karmaşıklığa
            kadar kötüleşmektedir. Örneğin ağaca aşağıdaki gibi sıralı bilgilerin geldiğini düşünelim: 
            
                10, 20, 30, 40, 50, 60, 70, ...

            Bu durumda ikili arama ağacının bağlı listeden bir farkı kalmamaktadır. Bu nedenle uygulamalarda "dengelenmiş (balanced)" ağaçlar tercih edilmektedir. Dengelenmiş ağaçlarda ağaca her eleman eklendiğinde ve eleman silindiğinde ağacın dengede kalması sağlanmaktadır. 
            Pekiyi dengelenmiş ağaçlar nasıl oluşturulmaktadır? Dengeleme işlemi her eleman eklendiğinde ve silindiğinde O(1) karmaşıklıkta ya da O(log N) karmaşıklıkta yapılan bir işlemdir. Böylece ağacın bir yandan uzamaıs engellenir. Ağacın tüm yapraklarının benzer
            yükseklikte kalması sağlanır. Bunun sonucunda arama işlemi de en kütü durum senaryosunda O(log N) olacaktır. Dengeleme için çeşitli algoritmalar önerilmiştir. En önemli iki dengeleme algoritmasına AVL (Adelson-Velsky-Landis) ve "Red Black Tree" algoritması
            denilmektedir. Bu iki algoritma arasında özel durumlara göre birinin lehine farlılıklar oluşabilmektedir. Uyglamada en çok kullanılan dengeleme algoritması AVL algoritmasıdır. Bu dengeleme algoritmasının kullanıldığı arama ağaçlarına "AVL ağacı (AVL tree)" da
            denilmektedir. Biz kursumunda ikili ağaçların dengelenmesi üzerinde durmayacağız. Bu konu ve diğer ağaç algoritmaları "Sistem Programalama ve İleri C Uygulamaları-II" kursunun konusu içerisindedir. Pekiyi 3'lü, 4'lü 5'li gibi arama ağaçları nasıl
            oluşturulmaktadır? Bu tür arama ağaçlarına "B-Tree" denilmektedir. 2'den daha fazla alt düğüme sahip olan ağaçlar bellek üzerindeki aramalarda (internal search) tercih edilmemektedir. Bunlar tipik olarak veritabanı yönetim sistemleri (DBMS) tarafından disk
            üzerindeki aramalarda (external search) kullanılmaktadır. Pekiyi örneğin 3'lü bir arama ağacı nasıl organize edilmektedir. İşte bu tür durumlarda düğüm üzerinde tek değer değil birden fazla değer tutulur. Örneğin 3'lü bir amarama ağacında göstericilerden biri
            a değerinden küçük olan düğümü, diğeri a ile b arasında olan düğümü diğeri de b'den büyük olan düğümü gösterir. Böylece ağacın yükseklüği azaltılmış olur. Disk işlemlerinde her bir düğümden diğerine geçiş için bir disk okuması gerektiği için bu durum ilgili
            kayda daha hızlı erişilmesine olanak sağlamaktadır. Çok kullanılan diğer bir ağaç türüne de "heap ağacı" ya da kısaca "heap" denilmektedir. Buradaki "heap" teriminin dinamik bellek yönetiminde geçen "heap" terimi ile bir ilgisi yoktur. Heap ağaçları "öncelik
            kuyruklarını (priority queues)" oluşturmak için kullanılmaktadır. Öncelik kuyruklarında kuyruğa yerleştirilen her elemanın bir öncelik derecesi (numarası) vardır. Kuyruktan eleman alınacağı zaman baştaki ya da sondaki eleman değil öncelik numarası en yüksek
            olan eleman alınmaktadır. Örneğin kuyrukta şu elemanlar olsun:

                4  10  7  2  14  6  5

            Kuyruğun başının sol taraf olduğunu düşünelim. Yani kuyruğa son eklenen eleman 5, ilk eklenen eleman ise 4 olsun. Eğer bu kuyruk sistemi FIFO olsaydı biz 4'ü alırdık. Kuyruk sistemi LIFO (stack) olsaydı biz kuyruktan 5'i alırdık. İşte eğer bir öncelik kuyruğu
            söz konusu ise biz kuyruktan 14'ü alırız. Çünkü en öncelikli eleman 14'tür. Bundan sonra yeniden kuyruktan eleman almak istesek bu kez 10'u alırız. Öncelik kuyruklarından eleman alma bu haliyle O(N) karmaşıklıkta bir işlemdir. İşte heap ağaçları bu işlemi
            O(log N) karmaşıklığa düşürmek için kullanılmaktadır. Heap ağaçları "heap sort" denilen sıraya dizme algortimesının gerçekleştirilmesinde de kullanılmaktadır. Heap ağaçları tipik olarak ikili ağaç biçiminde karşımıza çıkmaktadır. Her ne kadar heap ağaçları
            2'den fazla düğüme sahip olabilirse de uygulamada 2'li heap ağaçları tercih edilmektedir. İkili heap ağaçlarına İngilizce "binary heap" de denilmektedir. Biz bu bağlamda "heap ağacı" ya da "heap" dediğimizde "ikili heap ağaçları" anlaşılmalıdır. Bir heap
            ağacının iki önemli karaktersitiği vardır:

                -> Heap ağaçları her zaman "tam ağaç (complete tree)" biçimindedir. Tam ağaçlarda yaprak düğümlerin dışında tüm düğümlerin 2 alt düğüme sahip olduğunu yaprakların ise en alt kademede soldan sağa bulunduğunu anımsayınız. 

                -> Heap ağacında bir düğümün tüm alt düğümleri o düğümden düşük ya da yüksek değerleri sahip olmak zorundadır. Eğer bir düğüm alt düğümlerinden daha yüksek değere sahipse böyle heap ağaçlarına "max-heap", eğer bir düğüm alt düğümlerinden daha düşük değere
                sahipse böyle heap ağaçlarına "min-heap" denilmektedir. Örneğin:

                                        100
                                50			      70
                        30          40      60     35
                    17       24   32 

                Bu örnekteki ağaç yukarıdaki iki kuralı karşıladığı için bir "max-heap" ağacıdır. 

            Heap ağacına eleman eklenirken eleman önce "tam ağacı (complete tree)" bozmayacak biçimde en alta en soldaki boş yere eklenir. Sonra eklenen eleman kuralı bozabileceği için üst düğümle karşılaştırılarak yer değiştirilir. Bu işlem kural bozulmayana kadar devam
            ettirilir. Bu işleme İngilizce "heapify" da denilmektedir. Örneğin yukarıdaki ağaca 75 eklemek isteyelim. Önce eklemeyi en altta en sol boş pozisyona yaparız:

                                    100
                            50			      70
                    30          40      60     35
                17       24   32    75

            Sonra bu 75 değeri üst düğümle karşılatırılıp duruma yer göre yer değiştirilir:

                                    100
                            50			      70
                    30          75      60     35
                17       24   32    40

            Bu işlem devam ettirlir:

                                    100
                            75			      70
                    30          50      60     35
                17       24   32    40

            Artık kural korunmuştur ve ekleme süreci bitirilir. Heap ağacından eleman alınacağı zaman her zaman kökten eleman alınır. Örneğin yukarıdaki ağaçtan eleman alacaksak 100'ü alırız. Bu durumda 100'ün yerine geçecek eleman onun alt düğümlerinin büyük olanıdır:

                                    75
                            75			      70
                    30          50      60     35
                17       24   32    40

            Tabii alt düğümün yerine onun alt düğümlerinden en büyük olan getirilir:

                                    75
                            75			      70
                    30          50      60     35
                17       24   32    40

            Böyle devam edilir:

                                    75
                            50			      70
                    30          75      60     35
                17       24   32    40

            Ta ki yapraklara iniline kadar:

                                    75
                            50			      70
                    30          40      60     35
                17       24   32    75

            Alınan değer en aşağı indiğinde işleme son verilir ve tam ağaç bozulmayacak biçimde o eleman silinir. Heap ağacına eleman eklemek en kötü durumda O(log N) karmaşıklıktadır. Eleman almak da aynı biçimdedir. Aslında heap ağaçlarında gerçekte ağaç
            oluşturulmamaktadır. Çünkü tam ağaçlar her zaman diziye dönüştürülebilmektedir. Bir heap ağacını diziye dönüştürürken dizinin 0'ıncı indisli elemanını kolaylık olsun diye boş bırakabiliriz. Diziye dönüştürme şu kurala göre yapımaktadır:
                
                -> Her zaman üst düğümün alt düğümleri üzet düğümün indeksinin iki katı ve iki katından bir fazla yerde bulunur. Aşağıdaki heap ağacına bakınız:

                                        100
                                50			      70
                        30          40      60     35
                    17       24   32    75

                Bu heap ağacının diziye dönüştürülmesi şöyle yapılacaktır:

                    0   1    2   3   4    5   6    7   8   9  10  11 
                    x  100  50  70   30  40   60  35  17  26  32  75 
                
                Burada örneğin 70 numaralı elemanın indeksi 3'tür. Bu durumda bu elemanın alt düğümleri 6 ve 7'inci indekstedir. İşte aslında heap ağaçlarında hiç ağaç oluşturulmaz. Sanki ağaç oluşturulmuş gibi her şey dizi üzerinde yukarıdaki indeks kuralına uygun bir
                biçimde yapılır. 

            Aşağıda heap ağaçları ile öncelik kuyruklarının oluşturulmasına bir örnek verilmektedir.
                * Örnek 1,
                    /* hpqueue.h */
                        #ifndef PQUEUE_H_
                        #define PQUEUE_H_

                        #include <stddef.h>
                        #include <stdbool.h>

                        #define PQUEUE_DEF_CAPACITY		8

                        /* Type Declarartion */

                        typedef struct tagPERSON {
                            char name[32];
                        } PERSON;

                        typedef PERSON VALUETYPE;

                        typedef struct tagHEAP_ITEM {
                            int prio;
                            VALUETYPE value;
                        } HEAP_ITEM;

                        typedef struct PQUEUE {
                            HEAP_ITEM *hitems;
                            size_t capacity;
                            size_t count;
                        } PQUEUE, *HPQUEUE;

                        /* Function Prototypes */

                        HPQUEUE create_pq(void);
                        bool put_pq(HPQUEUE hpqueue, int prio, VALUETYPE *value);
                        bool get_pq(HPQUEUE hpqueue, int *prio, VALUETYPE *value);
                        bool resize_pq(HPQUEUE hpqueue, size_t new_capacity);
                        void destroy_pq(HPQUEUE hqueue);


                        /* inline Function Definitions */

                        static inline bool isempty_pq(HPQUEUE hpqueue)
                        {
                            return hpqueue->count == 0;
                        }

                        static inline void clear_pq(HPQUEUE hpqueue)
                        {
                            hpqueue->count = 0;
                        }

                        #endif

                    /* hpqueue.c */
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include "pqueue.h"

                        HPQUEUE create_pq(void)
                        {
                            HPQUEUE hpqueue;

                            if ((hpqueue = (HPQUEUE)malloc(sizeof(PQUEUE))) == NULL)
                                return NULL;

                            if ((hpqueue->hitems = (HEAP_ITEM *)malloc(sizeof(HEAP_ITEM) * PQUEUE_DEF_CAPACITY)) == NULL) {
                                free(hpqueue);
                                return NULL;
                            }
                            hpqueue->capacity = PQUEUE_DEF_CAPACITY;
                            hpqueue->count = 0;

                            return hpqueue;
                        }


                        bool put_pq(HPQUEUE hpqueue, int prio, VALUETYPE *value)
                        {
                            size_t index;

                            if (hpqueue->count + 1 == hpqueue->capacity) 
                                if (!resize_pq(hpqueue, hpqueue->capacity * 2))
                                    return false;

                            index = hpqueue->count + 1;

                            while (index > 1 && prio > hpqueue->hitems[index / 2].prio) {
                                hpqueue->hitems[index] = hpqueue->hitems[index / 2];
                                index /= 2;
                            }
                            hpqueue->hitems[index].prio = prio;
                            hpqueue->hitems[index].value = *value;
                            ++hpqueue->count;

                            return true;
                        }

                        bool get_pq(HPQUEUE hpqueue, int *prio, VALUETYPE *value)
                        {
                            size_t i, ci;

                            if (hpqueue->count == 0)
                                return false;

                            *prio = hpqueue->hitems[1].prio;
                            *value = hpqueue->hitems[1].value;

                            i = 1;
                            ci = 2;

                            while (ci <= hpqueue->count) {
                                if (ci + 1 < hpqueue->count && hpqueue->hitems[ci + 1].prio > hpqueue->hitems[ci].prio)
                                    ++ci;
                                if (hpqueue->hitems[hpqueue->count].prio > hpqueue->hitems[ci].prio)
                                    break;
                                    
                                hpqueue->hitems[i] = hpqueue->hitems[ci];
                                i = ci;
                                ci *= 2;
                            }
                            hpqueue->hitems[i] = hpqueue->hitems[hpqueue->count];
                            --hpqueue->count;

                            return true;
                        }

                        bool resize_pq(HPQUEUE hpqueue, size_t new_capacity)
                        {
                            HEAP_ITEM *hitems;
                            
                            if (new_capacity <= hpqueue->capacity)
                                return false;

                            if ((hitems = (HEAP_ITEM *)realloc(hpqueue->hitems, new_capacity * sizeof(HEAP_ITEM))) == NULL)
                                return false;

                            hpqueue->hitems = hitems;
                            hpqueue->capacity = new_capacity;

                            return true;
                        }

                        void destroy_pq(HPQUEUE hpqueue)
                        {
                            free(hpqueue->hitems);
                            free(hpqueue);
                        }

                    /* app.c */
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include "pqueue.h"

                        void disp_pq(HPQUEUE hpqueue)
                        {
                            for (size_t i = 1; i <= hpqueue->count; ++i)
                                printf("%d  ", hpqueue->hitems[i].prio);
                            printf("\n");
                        }

                        int main(void)
                        {
                            HPQUEUE hpqueue;
                            int prios[] = {100, 85, 90, 60, 70, 10, 40, -1};
                            VALUETYPE values[] = {{"Ali Serce"}, {"Sacit Bulut"}, {"Ayse Er"}, {"Necati Ergin"}, {"Guray Sonmez"},
                                {"Ziya Taskent"}, {"Gencay Coskun"}};
                            int prio;
                            VALUETYPE value;

                            if ((hpqueue = create_pq()) == NULL) {
                                fprintf(stderr, "cannot create priority queue!...\n");
                                exit(EXIT_FAILURE);
                            }

                            for (int i = 0; prios[i] != -1; ++i)
                                if (!put_pq(hpqueue, prios[i], &values[i])) {
                                    fprintf(stderr, "cannot add item!..\n");
                                    exit(EXIT_FAILURE);
                                }

                            disp_pq(hpqueue);

                            while (!isempty_pq(hpqueue)) {
                                if (!get_pq(hpqueue, &prio, &value)) {
                                    fprintf(stderr, "cannot get value!..\n");
                                    exit(EXIT_FAILURE);
                                }
                                printf("prio: %d, value: %s\n", prio, value.name);
                                disp_pq(hpqueue);
                                printf("----------------------\n");
                            }

                            destroy_pq(hpqueue);

                            return 0;
                        }

	        >>>> Graph Veri Yapısı: En sık karşılaşılan veri yapılaran biri de "graph" denilebn veri yapısıdır. Bir graph düğümlerden ve kenarlardan oluşur. Düğümlere İngilizce "vertex" ya da "node" denilmektedir. Düğüm arasındaki bağlantıyı temsil eden kenarlara da
            İngilizce "edge" denilmektedir. Aslında düğümlerden Ve kenarlardan oluşan en genel veri yapısı "graph" veri yapısıdır. Ağaçlar aslında bir çeşit graph'tır. Belli bir düğüm kök yapıldığında her düğüme bu kök düğümden yalnızca tek bir yol ile gelinen özel
            graph'lara "ağaç (tree)" denilmektedir. Yani aslında her ağaç bir graph'tır, ancak her graph bir ağaç değildir. Dolayısıyla genel olarak graph'larda bir düğüme biren fazla yerden gelinebilmektedir. Graph veri yapılarının pratikte pek çok uygulama alanı
            vardır. Graplar üzerinde yüzden fazla uygulaması olan problem tanımlanmıştır. Graph'lar konusunda çalışmadan önce temel graph terminolojisini bilmek gerekir. Tmel graph terminolojisi şöyledir:

                >>>>> Yönlü ve Yönsüz Graflar (Directed and Undirected): Eğer düğümler arasındaki yollarda bir yön belirtiliyorsa bu tür graflara "yönlü graflar" denilmektedir. Düğümler arasındaki kenarlarda bir yön bilgisi yoksa bu tür graflara da "yönsüz graflar"
                denilmektedir. Aslında yönsüz graflar iki yönlü graflar gibi de düşünülebilir. Örneğin kara yolları yönlü bir grafla, sosyal ağlar (hepsi değil) yönsüz bir grafla temsil edilebilir. 

                >>>>> Döngüsel Olan (Cyclic) ve Döngüsel Olmayan (Acyclic) Graflar: Bir grafta bir düğümden başlanarak aynı düğüme gelebilmenin bir yolu varsa bu tür graflara döngüsel graflar denilmektedir. Döngüsel graflarda her düğüm için kendine gelen bir yol
                olması gerekmez. Herhangi bir düğümden kendisine gelen herhangi bir yol varsa bu grafı döngüsel graf yapmaktadır. Döngüsellik tipik olarak yönlü graflar için kullanılan bir terimdir. İngilizce buna "directed acyclic grapg (DAG)" da denilmektedir. 

                >>>>> Yol (Path): Bir grafta bir düğümden diğerine varabilmek için geçilen kenarların sırasıyla dizilimine "yol (path)" denilmektedir. 

                >>>>> Tur (Cycle): Bir yolun ilk ve son düğümü aynıysa başka bir deyişle bir düğümden çıkılıp yeniden aynı düğüme gelen yola "tur" denilmektedir. Tuların tüm düğümleri kapsaması gerekmez. 

                >>>>> Bağlantılı Graflar (Connected Graphs): Her düğümle her düğüm arasında en az bir yolun olduğu yönsüz graflara "bağlantılı graflar (connected graphs)" denilmektedir. Graflardaki düğümleri bilye, kenarları da bunları bağlayan ip olarak düşünürsek
                bağlantılı graflarda herhangi bir bilyeyi tutup yukarı kaldırdığımızda tüm bilyelerin kalkması gerekir. 

                >>>>> Öz döngülü (self-loop) Graflar: Eğer graflarda kendindne kendine bir kenar tanımlanabiliyorsa böylesi graflara öz döngülü graflar (self-loop graphs) denilmektedir. Genellikle gragflar öz döngülü olmazlar. 
                
                >>>>> Alt Graflar (Subgraphs): Bir grafın belli bir alt kümesine alt graph denilmektedir. 

                >>>>> Tam Graflar (Complete Graphs): Bir yönsüz grafta her düğümden her düğüme bir kenar varsa bu tür graflara "tam graflar (complete graphs)" denilmektedir.	

            Graflarla çalışmak için öncelikle grafları veri yapısı olarak temsil etmek gerekir. Grafların temsil edilmesi için temel iki yöntem kullanılmaktadır.

                -> Komşuluk Matrisi (Adjacency-Matrix) Yöntemi 
                -> Komşuluk Listeleri (Adjacency-Lists) Yöntemi

            Bu yöntemlerden,
                >>>>> Komşuluk matrisi yönteminde düğümlerden bir kare matris oluşturulur. Matrisin elemanları 0 ve 1'lerden oluşturulabilir. 0 ilgili iki düğüm arasında bir kenar olmadığını 1 ise olduğunu gösterebilir. Örneğin:

                    A B C D
                    A 0 1 0 1 
                    B 0 0 1 1
                    C 1 1 0 0
                    D 0 1 1 0

                Burada örneğin C'den C'ye kenar yoktur, ancak C'den D'ye kenar vardır. Tabii eğer kenarlara bilgiler iliştirilecekse (örneğin bir yol uzunluğu gibi) bu durumda matrisin elemanları birer gösterici olabilir. Kenar bilgileri bu göstericilerin gösterdiği
                yerdedir. İki düğüm arasında yol yoksa matrisin ilgili elemanı NULL adres içerebilir. Yönsüz graflarda komşuluk matirisinin simetrik bir matris olması gerektiğine dikkat ediniz. 

                >>>>> Komşuluk listeleri yönteminde her düğümün bir listesi vardır. Bu liste o düğümden gidilebilecek düğümleri belirtir. Buradakli liste dinamik büyütülen bir dizi olabilir ya da bağlı liste olabilir. Yukarıdaki graf'ın komşuluk listeleri yoluyla temsili
                şöyle olacaktırÇ:

                    A: B, C
                    B: C, D
                    C: A, B
                    D: B, C

                BUrada eğer yollara bilgiler iliştirilecekse listenin elemanları birer gösterici olabilir ya da o bilgilerdne oluşan birer yapı da olabilir. 

            Pekiyi hangi temsil daha iyidir? Aslında iki yöntemin de avantajları ve dezavantajları bulunmaktadır. Komşul matrisi yönteminde kenara iliştirilen bilgiye O(1) karmaşıklıkta erişilebilir. Komşuluk listeleri yönteminde sıralı arama gerekir. Eğer kenar sayısı çok
            fazla ise bu yöntemde her düğüm için bir hash tablosu ya da ikili arama ağacı kullanılabilir. Uygulamada genellikle "komşuluk listeleri" yöntemi tercih edilmektedir. Bu temsillerde düğümlerin nasıl temsil edileceği de bir problemdir. Düğümlere isim verilirse
            ismin aranması uzun sürebilir. Bu durumda en etkin yöntem düğümlere isim değil numara vermektir. Tabii numaradan isim elde edilebilir ya da isimden numara alde edilebilir. Graflarlar üzerinde algoritmalar için değişik graf kütüphaneleri oluşturulmuştur. En
            yaygın kullanılan graf kütüphanesi C++'taki "Boost Graf Kütüphanesi (Boost Graph Library (BGL))" denilen kütüphanedir. Bu kütüphanede düğümler ve kenarlar sınıflarla temsil edilmiştir. Boost Graf Kütüphanesi pek çok graf kütüphanesine de ilham kaynağı olmuştur.
            Benzer biçimde Java için, C# için Python için çeşitli graf kütüphaneleri geliştirilmiştir. C için yaygın kullanılan bir graf kütüphanesi bulunmamaktadır. Ancak incelemek için "igraph" kütüphanesi önerilebilir. Kütüphanenin kaynak kodlarına aşağıdan
            erişebilirisiniz:

                https://igraph.org/

            Yukarıda da belirttiğimiz gibi graf veri yapısı için iki yöntem kullanılmaktadır. Ancak ağırlıklı tercih "komşuluk listeleri" yöntemidir. Bu yöntemin türden bağımsız uygulaması biraz zor olabilmektedir. Biz burada makul bir gerçekleştirim üzerinde duracağız. 
            Gerçekleştiririmizde DGRAPH nesnesi VERTEX nesnelerini, VERTEX nesneleri de EDGE nesnelerini tutacaktır. Komşuluk listeleri yönteminde her vertex'in o vertex'ten gidilebilecek vertex'leri tuttuğunu belirtmiştik. Ancak biz burada bir vertex'ten gidilecek
            vertex'leri değil gidilecek vertex'lere ilişkin kenar nesnelerini tutacağız. DGRAPH yapısı şöyleolabilir:

                typedef struct tagDGRAPH{
                    VERTEX **vertices;
                    size_t count;
                    size_t capacity;
                } DGRAPH;

            Görüldüğü gibi burada graf veri yapısı vertex'lerin kendilerini değil adreslerini tutmaktadır. Bunun nedeni bu dizi büyütüldüğünde VERTEX nesnelerinin adreslerinin değişmemesinin sağlanmasıdır. Buradaki count bu gösterici dizisinin dolu olan eleman sayısını,
            capacity ise gösterici dizisi için ayrılan kapasiteyi belirtmektedir. VERTEX yapısı aşağıdakai gibi olabilir:
                
                typedef struct tagVERTEX {
                    EDGE **edges;
                    size_t count;
                    size_t capacity;

                    /* VERTEX INFO */
                    char name[32];
                } VERTEX;

            Görüldüğü gibi VERTEX nesneleri EDGE nesnelerinin adreslerini tutmaktadır. Yine bu dizinin dolu olan eleman sayısı count elemanı ile dizi için tahsis edilen toplam alan ise capacity elemanı ile tutulmaktadır. Burada biz vertex'e bir isim verdik. İsterseniz
            burada vertex'lere başka bilgiler de iliştirebilirsiniz. EDGE yapısı da şöyle olabilir:

                typedef struct tagEDGE {
                    VERTEX *v1;
                    VERTEX *v2;

                    /* EDGE INFO */
                    int length;
                } EDGE;

            Görüldüğü gibi bir EDGE nesnesi başlangıç ve bitiş VERTEX nesnelerinin adreslerini tutmaktadır. Burada EDGE nesnesine bir uzunluk bilgisi iliştirilmiştir. Tabi başka bilgiler de iliştirilebilir. Bu tasarımda biz DGRAPH nesnesinin tuttuğu vertex'leri dinamik
            büyütülen bir dizi ile, vertex'lerin tuttuğu kenarları da dinamik büyütülen bir dizi ile temsil ettik. Burada bağlı listeler ya da hash tabloları da kullanılabilir. Graf veri yapısını oluşturduktan sonra graflar üzerinde işlem yapan algoritmaların oluşturulması
            gerekir. Ancak çok çeşitli graf algoritmaları vardır. Biz kursumuzda yalnızca birkaç algoritma üzerinde duracağız. Bunlardan biri belli bir düğümden başlanarak grafın gidilebilen tüm düğümlerinin dolaşılmasıdır. Tabii bu da özyinelemeli bir biçimde yapılmalıdır.
            Yani bir düğümden gidilebilen tüm düğümler için fonksiyon kendini çağırmalıdır. Ancak graflarda düğümlere birden fazla yolla gelinebildiği için döngüsel bir sonsuz döngüye girmemek gerekir. Bunu engellemenin tipik yolu her ziyaret edilen düğümün ziyaret edildiğini
            bir yerde tutmak ve eğer düğüm daha önce ziyaret edilmişse onu yeniden ziyaret etmemektir. Graf veri yapısını kurduktan sonra graf üzerinde pek çok problemin çözümü yapılabilir. Literatürden yüzün üzerinde graf problemi tanımlanmıştır. Graf problemlerinin en çok
            bilinenlerinden bazıları şunlardır:

                -> Grafın dolaşılması
                -> Grafta iki düğüm arasındaki tüm yolların (paths) elde edilmesi (shortest path problem)
                -> Grafta iki düğüm arasında en kısa yolun elde edilmesi (path finding problem)
                -> En küçük örten ağaç problemi (minimum spanning tree)
                -> Gezgin satıcı problemi (travelling salesperson problem)
                -> Maximum akış problemi (maximum flow problem)
                -> Graf boyama problemi (graph coloring problem)
                -> Graf çizdirme problemi (graph drawing problem)

            Aşağıda graf veri yapısının oluşturulmasına ilişkin bir örnek verilmiştir. Buradaki veri yapılarını kullanarak yukarıdaki problemleri çözecek algoritmaları deneyebilirsiniz.
                * Örnek 1,
                    /* graph.h */
                        #ifndef GRAPH_H_
                        #define GRAPH_H_

                        #include <stddef.h>
                        #include <stdbool.h>

                        /* Symbolic Constants */

                        #define DEF_VERTEX_CAPACITY			4
                        #define DEF_EDGE_CAPACITY			4

                        #define MAX_CSV_LINE_LENGTH			1024

                        /* Type Declarations */

                        typedef struct tagEDGE {
                            struct tagVERTEX *v1;
                            struct tagVERTEX *v2;

                            /* EDGE INFO */
                            double length;
                        } EDGE;

                        typedef struct tagVERTEX {
                            EDGE **edges;
                            size_t count;
                            size_t capacity;
                            size_t index;
                            
                            /* VERTEX INFO */
                            char name[32];

                        } VERTEX;

                        typedef struct tagDGRAPH{
                            VERTEX **vertices;
                            size_t count;
                            size_t capacity;
                            size_t ecount;
                        } DGRAPH, *HDGRAPH;

                        /* Function Prototypes */

                        HDGRAPH create_dgraph(void);
                        VERTEX *add_vertex(HDGRAPH hdgraph, VERTEX *vertex);
                        VERTEX *add_vertex_info(HDGRAPH hdgraph, const char *name);
                        EDGE *add_edge(HDGRAPH hdgraph, VERTEX *v1, VERTEX *v2, double length);
                        EDGE *add_edge_info(HDGRAPH hdgraph, const char *name1, const char *name2, double length);
                        DGRAPH *build_graph(const char *path);
                        bool traverse_depth_first_vertex(HDGRAPH hdgraph, VERTEX *vertex, bool (*proc)(VERTEX *));
                        bool traverse_depth_first_name(HDGRAPH hdgraph, const char *name, bool (*proc)(VERTEX *));
                        void clear_dgraph(HDGRAPH hdgraph);
                        void destroy_dgraph(HDGRAPH hdgraph);

                        /* inline Funcrion Definitions */

                        static inline size_t vertex_count(HDGRAPH hdgraph)
                        {
                            return hdgraph->count;
                        }

                        #endif

                    /* graph.c */
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include <string.h>
                        #include "graph.h"

                        static VERTEX *find_vertex_name(HDGRAPH hdgraph, const char *name);
                        static EDGE *create_edge(VERTEX *v1, VERTEX *v2, double length);
                        static VERTEX *create_vertex(const char *name);
                        static bool traverse_depth_first_vertex_recur(VERTEX *vertex, int *visiteds, bool (*proc)(VERTEX *));

                        HDGRAPH create_dgraph(void)
                        {
                            HDGRAPH hdgraph;

                            if ((hdgraph = (HDGRAPH)malloc(sizeof(DGRAPH))) == NULL)
                                return NULL;

                            if ((hdgraph->vertices = (VERTEX **)malloc(DEF_VERTEX_CAPACITY * sizeof(VERTEX *))) == NULL) {
                                free(hdgraph);
                                return NULL;
                            }
                            hdgraph->count = 0;
                            hdgraph->capacity = DEF_VERTEX_CAPACITY;
                            hdgraph->ecount = 0;

                            return hdgraph;
                        }

                        VERTEX *add_vertex(HDGRAPH hdgraph, VERTEX *vertex)
                        {
                            VERTEX **new_vertices;

                            if (find_vertex_name(hdgraph, vertex->name) != NULL)
                                return NULL;

                            if (hdgraph->count == hdgraph->capacity) {
                                if ((new_vertices = realloc(hdgraph->vertices, hdgraph->capacity * sizeof(VERTEX *) * 2)) == NULL)
                                    return NULL;
                                hdgraph->vertices = new_vertices;
                                hdgraph->capacity *= 2;
                            }
                            vertex->index = hdgraph->count;
                            hdgraph->vertices[hdgraph->count] = vertex;
                            ++hdgraph->count;

                            return vertex;
                        }

                        VERTEX *add_vertex_info(HDGRAPH hdgraph, const char *name)
                        {
                            VERTEX *vertex;
                            VERTEX **new_vertices;

                            if (find_vertex_name(hdgraph, name) != NULL)
                                return NULL;

                            if ((vertex = create_vertex(name)) == NULL)
                                return NULL;

                            if (hdgraph->count == hdgraph->capacity) {
                                if ((new_vertices = realloc(hdgraph->vertices, hdgraph->capacity * sizeof(VERTEX *) * 2)) == NULL)
                                    return NULL;
                                hdgraph->vertices = new_vertices;
                                hdgraph->capacity *= 2;
                            }
                            vertex->index = hdgraph->count;
                            hdgraph->vertices[hdgraph->count] = vertex;
                            ++hdgraph->count;

                            return vertex;
                        }

                        EDGE *add_edge(HDGRAPH hdgraph, VERTEX *v1, VERTEX *v2, double length)
                        {
                            EDGE *edge;
                            EDGE **new_edges;

                            if ((edge = create_edge(v1, v2, length)) == NULL)
                                return NULL;

                            if (v1->count == v1->capacity) {
                                if ((new_edges = realloc(v1->edges, v1->capacity * 2 * sizeof(EDGE *))) == NULL) {
                                    free(edge);
                                    return NULL;
                                }
                                v1->capacity *= 2;
                            }
                            v1->edges[v1->count] = edge;
                            ++v1->count;

                            ++hdgraph->ecount;

                            return edge;
                        }

                        EDGE *add_edge_info(HDGRAPH hdgraph, const char *name1, const char *name2, double length)
                        {
                            VERTEX *v1, *v2;
                            EDGE *edge;

                            if ((v1 = find_vertex_name(hdgraph, name1)) == NULL) {
                                if ((v1 = create_vertex(name1)) == NULL) 
                                    return NULL;
                                if (add_vertex(hdgraph, v1) == NULL)
                                    goto EXIT1;
                            }

                            if ((v2 = find_vertex_name(hdgraph, name2)) == NULL) {
                                if ((v2 = create_vertex(name2)) == NULL) 
                                    goto EXIT1;
                                if (add_vertex(hdgraph, v2) == NULL)
                                    goto EXIT2;
                            }

                            if ((edge = add_edge(hdgraph, v1, v2, length)) == NULL) 
                                goto EXIT2;

                            return edge;

                        EXIT2:
                            free(v2);
                        EXIT1:
                            free(v1);

                            return NULL;
                        }

                        DGRAPH *build_graph(const char *path)
                        {
                            FILE *f;
                            HDGRAPH hdgraph;
                            char buf[MAX_CSV_LINE_LENGTH + 2];
                            const char *name1, *name2, *length;
                            char *str;

                            if ((f = fopen(path, "r")) == NULL)
                                goto EXIT1;

                            if ((hdgraph = create_dgraph()) == NULL)
                                goto EXIT2;

                            while (fgets(buf, MAX_CSV_LINE_LENGTH + 2, f) != NULL) {
                                if ((name1 = strtok(buf, ",\n")) == NULL)
                                    continue;
                                if ((name2 = strtok(NULL, ",\n")) == NULL)
                                    goto EXIT3;
                                if ((length = strtok(NULL, ",\n")) == NULL)
                                    goto EXIT3;
                                if (strtok(NULL, ",\n") != NULL)
                                    goto EXIT3;
                                if (add_edge_info(hdgraph, name1, name2, atof(length)) == NULL)
                                    goto EXIT3;
                            }

                            return hdgraph;

                        EXIT3:
                            destroy_dgraph(hdgraph);
                        EXIT2:
                            fclose(f);
                        EXIT1:
                            return NULL;
                        }

                        bool traverse_depth_first_vertex(HDGRAPH hdgraph, VERTEX *vertex, bool (*proc)(VERTEX *))
                        {
                            int *visiteds;
                            bool result;

                            if (!proc(vertex))
                                return false;

                            if ((visiteds = (int *)calloc(hdgraph->count, sizeof(int))) == NULL)
                                return false;

                            result = traverse_depth_first_vertex_recur(vertex, visiteds, proc);

                            free(visiteds);

                            return result;
                        }

                        bool traverse_depth_first_name(HDGRAPH hdgraph, const char *name, bool (*proc)(VERTEX *))
                        {
                            VERTEX *vertex;

                            if ((vertex = find_vertex_name(hdgraph, name)) == NULL)
                                return false;

                            return traverse_depth_first_vertex(hdgraph, vertex, proc);
                        }

                        void clear_dgraph(HDGRAPH hdgraph)
                        {
                            for (size_t v = 0; v < hdgraph->count; ++v) {
                                for (size_t e = 0; e < hdgraph->vertices[v]->count; ++e)
                                    free(hdgraph->vertices[v]->edges[e]);
                                hdgraph->vertices[v]->count = 0;
                                free(hdgraph->vertices[v]);
                            }
                            hdgraph->count = 0;
                        }

                        void destroy_dgraph(HDGRAPH hdgraph)
                        {
                            for (size_t v = 0; v < hdgraph->count; ++v) {
                                for (size_t e = 0; e < hdgraph->vertices[v]->count; ++e)
                                    free(hdgraph->vertices[v]->edges[e]);
                                free(hdgraph->vertices[v]->edges);
                            
                            }
                            free(hdgraph->vertices);
                            free(hdgraph);
                        }

                        static VERTEX *create_vertex(const char *name)
                        {
                            VERTEX *vertex;

                            if ((vertex = (VERTEX *)malloc(sizeof(VERTEX))) == NULL)
                                return NULL;

                            if ((vertex->edges = (EDGE **)malloc(DEF_EDGE_CAPACITY * sizeof(EDGE *))) == NULL) {
                                free(vertex);
                                return NULL;
                            }
                            vertex->count = 0;
                            vertex->capacity = DEF_EDGE_CAPACITY;
                            strcpy(vertex->name, name);

                            return vertex;
                        }

                        static VERTEX *find_vertex_name(HDGRAPH hdgraph, const char *name)
                        {
                            for (size_t i = 0; i < hdgraph->count; ++i)
                                if (!strcmp(name, hdgraph->vertices[i]->name))
                                    return hdgraph->vertices[i];

                            return NULL;
                        }

                        static EDGE *create_edge(VERTEX *v1, VERTEX *v2, double length)
                        {
                            EDGE *edge;

                            if ((edge = (EDGE *)malloc(sizeof(EDGE))) == NULL)
                                return NULL;

                            edge->v1 = v1;
                            edge->v2 = v2;
                            edge->length = length;

                            return edge;
                        }

                        static bool traverse_depth_first_vertex_recur(VERTEX *vertex, int *visiteds, bool (*proc)(VERTEX *))
                        {
                            VERTEX *v;

                            visiteds[vertex->index] = 1;
                            for (size_t e = 0; e < vertex->count; ++e) {
                                v = vertex->edges[e]->v2;
                                if (visiteds[v->index])
                                    continue;
                                if (!proc(v))
                                    return false;
                                if (!traverse_depth_first_vertex_recur(v, visiteds, proc))
                                    return false;
                            }

                            return true;
                        }

                    /* app.c */
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include <stdbool.h>
                        #include "graph.h"

                        void err_exit(const char *msg);
                        bool disp_vertex(VERTEX *v);

                        int main(void)
                        {
                            HDGRAPH hdgraph;

                            if ((hdgraph = build_graph("graph.csv")) == NULL) {
                                fprintf(stderr, "cannot build graph!..\n");
                                exit(EXIT_FAILURE);
                            }

                            traverse_depth_first_name(hdgraph, "A", disp_vertex);

                            destroy_dgraph(hdgraph);

                            return 0;
                        }

                        void err_exit(const char *msg)
                        {
                            fprintf(stderr, "%s\n", msg);

                            exit(EXIT_FAILURE);
                        }

                        bool disp_vertex(VERTEX *v)
                        {
                            printf("%s\n", v->name);

                            return true;
                        }


                        
                        >> Veri Yapılarının Genelleştirilmesi : Şimdiye kadar yaptığımız örneklerde ilgili veri yapılarının türleri baştan belirlenmiş durumdaydı. Her ne kadar bazı örneklerde biz veri yapısı içerisinde tutulacak dğerlerin türlerini DATATYPE, VALUETYPE gibisi isimlerle
                        typedef ettiysek de bu durum bir genelleme oluşturmamaktadır. Başka bir deyişle şimdiye kadar yaptığımız örneklerde veri yapılarımız toplamda tek bir türe ilişkin olabilmektedir. Örneğin bağlı listeler için şu yapıları kullanmıştık:

                            typedef int DATATYPE;

                            typedef struct tagNODE {
                                DATATYPE val;
                                struct tagNODE *next;
                            } NODE;

                            typedef struct tagLLIST {
                                NODE head;
                                NODE *tail;
                                size_t count;
                            } LLIST, *HLLIST;

                        Burada biz birden fazla bağlı liste oluşturabilecek bir mekanizma sağlamıştık. Ancak tüm bağlı listelerimiz DATATYPE türünü tutmaktadır. DATATYPE türü int olarak typedef edilldiğine göre biz ne kadar bağlı liste yaratırsak yaratalım hepsi int değerleri tutan bağlı
                        listeler olacaktır. Örneğin İkili arama ağaçları için şu yapıları kullanmıştık:

                            typedef struct tagPERSON {
                                char name[32];
                                int city;
                            } PERSON;

                            typedef struct tagNODE {
                                int key;
                                PERSON value;
                                struct tagNODE *left;
                                struct tagNODE *right;
                            } NODE;

                            typedef struct tagBTREE {
                                NODE *root;
                                size_t count;
                            } BTREE, *HBTREE;

                        Burada da biz birden fazla bağlı liste oluşturabiliyorduk. Ancak bu bağlı listelerin hepsinin anahtarı int değerleri için PERSON türünden olmak zorundadır. Özetle şimdiye oluşturduğumuz veri yapıları "genel" değil belli bir tür için oluşturuldu. Şimdi biz
                        "türden bağımsız" yani her türle çalışabilecke veri yapılarının nasıl oluşturalacağı üzerinde duracağız. Böylelikle veri yapılarını her tür için çalışabilir hale getirebileceğiz. Türden bağımsız veri yapılarının oluşturulabilmesi için iki teknik kullanılabilir:

                            -> void Gösterici Tekniği
                            -> Gömme Tekniği

                        Bu yöntemlerden,
                            >> void gösterici tekniği aslında etkin bir yöntem değildir. Bu yöntemin hem kullanımı zordur hem de bu yöntem diğerine göre yavaştır. Bu nedenle programcılar gömme tekniğini tercih etmektedir. Örneğin Linux kaynak kodlarında veri yapılarında genellik sağlamak için
                            hep bu teknik kullanılmıştır. void gösterici tekniğinde veri yapısının tutacağı değerlerin türleri yerine onların adresleri ve uzunlukları kullanılır. Eğer karşılaştırma yapılmak istenirse callback fonksiyonlardan faydalanılmaktadır. Örneğin ikili arama ağacını bu
                            teknikle gerçekleştirmek isteyelim. Biz artık ağaç düğümlerinde tutulacak anahtar ve değerin türünü bilmek zorunda değiliz. Ancak onların uzunluklarını bilmek zorundayız. Bunun için gereken yapı bildirimleri şöyle olabilir:
                                    
                                typedef struct tagNODE {
                                    struct tagNODE *left;
                                    struct tagNODE *right;
                                    char key_value[];
                                } NODE;

                                typedef struct tagQNODE {
                                    struct tagQNODE *next;
                                    NODE *node;
                                } QNODE;

                                typedef struct tagBTREE {
                                    NODE *root;
                                    size_t count;
                                    QNODE *head;
                                    QNODE *tail;
                                    size_t key_size;
                                    size_t value_size;
                                    bool (*compare)(const void *, const void *);
                                } BTREE, *HBTREE;

                            Burada tagNODE yapısının son elemanına dikkat ediniz. Burada C99 ile birlikte C'ye eklenmiş olan "flexible array member" özelliği kullanılmıştır. Bu özelliğe göre bir yapının son elemanı (başka elemanlarında bu yapılamaz) uzunluğu belirtilmemiş bir dizi olabilir. 
                            Derleyici bu dizi için bir yer ayırmamaktadır. Bu diziden amaç ilgili yapı nesnesinin bellekteki bitim adresinin kolay bir biçimde tespit edilmesini sağlamaktır. Handle alanında (tagBTREE yapısı) anahtar ve değer olarak kullanılacak bilgilerin uzunluğunun ve bir
                            karşılaştırma fonksiyonunun adresinin bulundurulduğna dikkat ediniz. Biz ikili arama ağacını yaratırken bu bilgileri vermek zorundayız.
                                * Örnek 1, Aşağıda void göstericiler kullanılarak türden bağımsız ikili arama ağacına bir örnek verilmiştir.
                                    /* binarytree.h */
                                        #ifndef BINARYTREE_H_
                                        #define BINARYTREE_H_

                                        #include <stddef.h>
                                        #include <stdbool.h>

                                        /* Type Declararions */

                                        typedef struct tagNODE {
                                            struct tagNODE *left;
                                            struct tagNODE *right;
                                            char key_value[];
                                        } NODE;

                                        typedef struct tagQNODE {
                                            struct tagQNODE *next;
                                            NODE *node;
                                        } QNODE;

                                        typedef struct tagBTREE {
                                            NODE *root;
                                            size_t count;
                                            QNODE *head;
                                            QNODE *tail;
                                            size_t key_size;
                                            size_t value_size;
                                            int (*compare)(const void *, const void *);
                                        } BTREE, *HBTREE;

                                        /* Function Prototypes */

                                        HBTREE create_bt(size_t key_size, size_t value_size, int (*compare)(const void *, const void *));
                                        bool insert_item_bt(HBTREE hbtree, const void *key, const void *value);
                                        bool walk_inorder_lr_bt(HBTREE hbtree, bool (*proc)(const void *, const void *));
                                        bool walk_inorder_rl_bt(HBTREE hbtree, bool (*proc)(const void *, const void *));
                                        bool walk_postorder_lr_bt(HBTREE hbtree, bool (*proc)(const void *, const void *));
                                        bool walk_preorder_lr_bt(HBTREE hbtree, bool (*proc)(const void *, const void *));
                                        bool walk_breadth_first_bt(HBTREE hbtree, bool (*proc)(const void *, const void *));
                                        bool delete_bt(HBTREE hbtree, const void *key);
                                        void clear_bt(HBTREE hbtree);
                                        void destroy_bt(HBTREE hbtree);

                                        /* inline Function Fefinitions */

                                        static inline size_t count_bt(HBTREE hbtree)
                                        {
                                            return hbtree->count;
                                        }

                                        #endif

                                    /* binarytree.c */
                                        #include <stdio.h>
                                        #include <stdlib.h>
                                        #include <string.h>
                                        #include "binarytree.h"

                                        static bool walk_inorder_lr_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *));
                                        static bool walk_inorder_rl_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *));
                                        static bool walk_postorder_lr_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *));
                                        static bool walk_preorder_lr_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *));
                                        static void create_queue(HBTREE hbtree);
                                        static NODE *put_queue(HBTREE hbtree, NODE *node);
                                        static NODE *get_queue(HBTREE hbtree);
                                        static void destroy_queue(HBTREE hbtree);
                                        static void subtree_shift(HBTREE hbtree, NODE *node1, NODE *node2, NODE *node3);
                                        static void clear_recur(NODE *node);

                                        HBTREE create_bt(size_t key_size, size_t value_size, int (*compare)(const void *, const void *))
                                        {
                                            HBTREE hbtree;

                                            if ((hbtree = (HBTREE)malloc(sizeof(BTREE))) == NULL)
                                                return NULL;

                                            hbtree->root = NULL;
                                            hbtree->count = 0;
                                            hbtree->key_size = key_size;
                                            hbtree->value_size = value_size;
                                            hbtree->compare = compare;

                                            return hbtree;
                                        }

                                        bool insert_item_bt(HBTREE hbtree, const void *key, const void *value)
                                        {
                                            NODE *new_node, *node, *parent_node = NULL;
                                            int result;

                                            if ((new_node = (NODE *)malloc(sizeof(NODE) + hbtree->key_size + hbtree->value_size)) == NULL)
                                                return false;
                                            memcpy(new_node->key_value, key, hbtree->key_size);
                                            memcpy(new_node->key_value + hbtree->key_size, value, hbtree->value_size);
                                            
                                            new_node->left = NULL;
                                            new_node->right = NULL;

                                            if (hbtree->root == NULL) {
                                                hbtree->root = new_node;
                                                ++hbtree->count;
                                                return true;
                                            }
                                            node = hbtree->root;

                                            while (node != NULL) {
                                                parent_node = node;
                                                result = hbtree->compare(key, node->key_value);

                                                if (result < 0)
                                                    node = node->left;
                                                else if (result > 0)
                                                    node = node->right;
                                                else {
                                                    memcpy(node->key_value + hbtree->key_size, value, hbtree->value_size);
                                                    return true;
                                                }
                                            }

                                            if (hbtree->compare(key, parent_node->key_value) <  0)
                                                parent_node->left = new_node;
                                            else
                                                parent_node->right = new_node;

                                            ++hbtree->count;

                                            return true;
                                        }

                                        bool walk_inorder_lr_bt(HBTREE hbtree, bool (*proc)(const void *, const void *))
                                        {
                                            if (hbtree->root != NULL)
                                                return walk_inorder_lr_recur(hbtree->root, hbtree->key_size, proc);

                                            return true;
                                        }

                                        bool walk_inorder_rl_bt(HBTREE hbtree, bool (*proc)(const void *, const void *))
                                        {
                                            if (hbtree->root != NULL)
                                                return walk_inorder_rl_recur(hbtree->root, hbtree->key_size, proc);

                                            return true;
                                        }

                                        bool walk_postorder_lr_bt(HBTREE hbtree, bool (*proc)(const void *, const void *))
                                        {
                                            if (hbtree->root != NULL)
                                                return walk_postorder_lr_recur(hbtree->root, hbtree->key_size, proc);

                                            return true;
                                        }

                                        bool walk_preorder_lr_bt(HBTREE hbtree, bool (*proc)(const void *, const void *))
                                        {
                                            if (hbtree->root != NULL)
                                                return walk_preorder_lr_recur(hbtree->root, hbtree->key_size, proc);

                                            return true;
                                        }

                                        static bool walk_preorder_lr_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *))
                                        {
                                            if (!proc(node->key_value, node->key_value + key_size))
                                                return false;

                                            if (node->left != NULL)
                                                if (!walk_preorder_lr_recur(node->left, key_size, proc))
                                                    return false;

                                            if (node->right != NULL)
                                                if (!walk_preorder_lr_recur(node->right, key_size, proc))
                                                    return false;
                                            
                                            return true;
                                        }

                                        bool walk_breadth_first_bt(HBTREE hbtree, bool (*proc)(const void *, const void *))
                                        {
                                            NODE *node;
                                            bool result = true;

                                            create_queue(hbtree);
                                            put_queue(hbtree, hbtree->root);

                                            while ((node = get_queue(hbtree)) != NULL) {
                                                if (!proc(node->key_value, node->key_value + hbtree->key_size)) {
                                                    result = false;
                                                    break;
                                                }
                                                if (node->left != NULL)
                                                    if (put_queue(hbtree, node->left) == NULL) {
                                                        fprintf(stderr, "put_queue cannot allocate memory!..\n");
                                                        result = false;
                                                        break;
                                                    }
                                                if (node->right != NULL)
                                                    if (put_queue(hbtree, node->right) == NULL) {
                                                        result = false;
                                                        fprintf(stderr, "put_queue cannot allocate memory!..\n");
                                                        break;
                                                    }
                                            }

                                            destroy_queue(hbtree);

                                            return result;
                                        }

                                        static void create_queue(HBTREE hbtree)
                                        {
                                            hbtree->head = NULL;
                                            hbtree->tail = NULL;
                                        }

                                        static NODE *put_queue(HBTREE hbtree, NODE *node)
                                        {
                                            QNODE *new_qnode;

                                            if ((new_qnode = (QNODE *)malloc(sizeof(QNODE))) == NULL)
                                                return NULL;

                                            new_qnode->node = node;
                                            new_qnode->next = NULL;

                                            if (hbtree->tail != NULL)
                                                hbtree->tail->next = new_qnode;
                                            else
                                                hbtree->head = new_qnode;
                                            hbtree->tail = new_qnode;

                                            return node;
                                        }

                                        static NODE *get_queue(HBTREE hbtree)
                                        {
                                            QNODE *qnode;
                                            NODE *rnode;

                                            if (hbtree->head == NULL)
                                                return NULL;
                                            qnode = hbtree->head;
                                            hbtree->head = qnode->next;
                                            if (hbtree->head == NULL)
                                                hbtree->tail = NULL;

                                            rnode = qnode->node;
                                            free(qnode);

                                            return rnode;
                                        }

                                        bool delete_bt(HBTREE hbtree, const void *key)
                                        {
                                            NODE *delete_node, *delete_parent_node, *replace_parent_node, *replace_node;
                                            int result;

                                            delete_node = hbtree->root;
                                            delete_parent_node = NULL;

                                            while (delete_node != NULL) {
                                                result = hbtree->compare(key, delete_node->key_value);
                                                if (result == 0)
                                                    break;
                                                delete_parent_node = delete_node;
                                                if (result < 0)
                                                    delete_node = delete_node->left;
                                                else if (result > 0)
                                                    delete_node = delete_node->right;
                                            }

                                            if (delete_node == NULL)
                                                return false;

                                            if (delete_node->left == NULL)
                                                subtree_shift(hbtree, delete_parent_node, delete_node, delete_node->right);
                                            else if (delete_node->right == NULL)
                                                subtree_shift(hbtree, delete_parent_node, delete_node, delete_node->left);
                                            else {
                                                replace_parent_node = delete_node;
                                                replace_node = delete_node->right;
                                                while (replace_node->left != NULL) {
                                                    replace_parent_node = replace_node;
                                                    replace_node = replace_node->left;
                                                }
                                                if (replace_parent_node != delete_node) {
                                                    subtree_shift(hbtree, replace_parent_node, replace_node, replace_node->right);
                                                    replace_node->right = delete_node->right;
                                                }
                                                subtree_shift(hbtree, delete_parent_node, delete_node, replace_node);
                                                replace_node->left = delete_node->left;
                                            }

                                            free(delete_node);
                                            --hbtree->count;

                                            return true;
                                        }

                                        void clear_bt(HBTREE hbtree)
                                        {
                                            if (hbtree->root != NULL) {
                                                clear_recur(hbtree->root);
                                                hbtree->root = NULL;
                                                hbtree->count = 0;
                                            }
                                        }

                                        void destroy_bt(HBTREE hbtree)
                                        {
                                            if (hbtree->root != NULL)
                                                clear_recur(hbtree->root);

                                            free(hbtree);
                                        }

                                        static bool walk_inorder_lr_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *))
                                        {
                                            if (node->left != NULL)
                                                if (!walk_inorder_lr_recur(node->left, key_size, proc))
                                                    return false;

                                            if (!proc(node->key_value, node->key_value + key_size))
                                                return false;

                                            if (node->right != NULL)
                                                if (!walk_inorder_lr_recur(node->right, key_size, proc))
                                                    return false;

                                            return true;
                                        }

                                        static bool walk_inorder_rl_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *))
                                        {
                                            if (node->right != NULL)
                                                if (!walk_inorder_rl_recur(node->right, key_size, proc))
                                                    return false;

                                            if (!proc(node->key_value, node->key_value + key_size))
                                                return false;

                                            if (node->left != NULL)
                                                if (!walk_inorder_rl_recur(node->left, key_size, proc))
                                                    return false;
                                            return true;
                                        }

                                        static bool walk_postorder_lr_recur(NODE *node, size_t key_size, bool (*proc)(const void *, const void *))
                                        {
                                            if (node->left != NULL)
                                                if (!walk_postorder_lr_recur(node->left, key_size, proc))
                                                    return false;

                                            if (node->right != NULL)
                                                if (!walk_postorder_lr_recur(node->right, key_size, proc))
                                                    return false;

                                            if (!proc(node->key_value, node->key_value + key_size))
                                                return false;

                                            return true;
                                        }

                                        static void destroy_queue(HBTREE hbtree)
                                        {
                                            QNODE *qnode, *temp_qnode;

                                            qnode = hbtree->head;

                                            while (qnode != NULL) {
                                                temp_qnode = qnode->next;
                                                free(qnode);
                                                qnode = temp_qnode;
                                            }
                                        }

                                        static void subtree_shift(HBTREE hbtree, NODE *node1, NODE *node2, NODE *node3)
                                        {
                                            if (node1 == NULL)
                                                hbtree->root = node3;
                                            else if (node1->left == node2)
                                                node1->left = node3;
                                            else
                                                node1->right = node3;
                                        }


                                        static void clear_recur(NODE *node)
                                        {
                                            if (node->left != NULL)
                                                clear_recur(node->left);

                                            if (node->right != NULL)
                                                clear_recur(node->right);

                                            free(node);
                                        }

                                    /* app.c */
                                        #include <stdio.h>
                                        #include <stdlib.h>
                                        #include "binarytree.h"

                                        typedef struct tagPERSON {
                                            char name[32];
                                            int no;
                                        } PERSON;

                                        bool disp_node(const void *key, const void *value);
                                        int comp_person(const void *key1, const void *key2);

                                        int main(void)
                                        {
                                            HBTREE hbtree;
                                            PERSON per = {"Noname", 0};
                                            int keys[] = {70, 50, 34, 56, 19, 80, 67, 43, 27, 76, 79, 105, 82, 65, 0};
                                            int del_key = 70;

                                            if ((hbtree = create_bt(sizeof(int), sizeof(PERSON), comp_person)) == NULL) {
                                                fprintf(stderr, "cannot create binary tree!..\n");
                                                exit(EXIT_FAILURE);
                                            }

                                            for (int i = 0; keys[i] != 0; ++i)
                                                if (!insert_item_bt(hbtree, &keys[i], &per)) {
                                                    fprintf(stderr, "cannot insert item: %d\n", keys[i]);
                                                    exit(EXIT_FAILURE);
                                                }
                                            
                                            walk_inorder_lr_bt(hbtree, disp_node);
                                            printf("\n------------------------------\n");
                                            walk_inorder_rl_bt(hbtree, disp_node);
                                            printf("\n------------------------------\n");
                                            walk_postorder_lr_bt(hbtree, disp_node);
                                            printf("\n------------------------------\n");
                                            walk_preorder_lr_bt(hbtree, disp_node);
                                            printf("\n------------------------------\n");
                                            walk_breadth_first_bt(hbtree, disp_node);
                                            printf("\n------------------------------\n");
                                            if (!delete_bt(hbtree, &del_key)) {
                                                fprintf(stderr, "cannot find item!...\n");
                                                exit(EXIT_FAILURE);
                                            }
                                            walk_breadth_first_bt(hbtree, disp_node);

                                            destroy_bt(hbtree);

                                            return 0;
                                        }

                                        bool disp_node(const void *key, const void *value)
                                        {
                                            const int *ikey = (const int *)key;
                                            printf("%d ", *ikey);
                                            fflush(stdout);

                                            return true;
                                        }

                                        int comp_person(const void *key1, const void *key2)
                                        {
                                            const int *ikey1 = (const int *)key1;
                                            const int *ikey2 = (const int *)key2;

                                            if (*ikey1 > *ikey2)
                                                return 1;

                                            if (*ikey1 < *ikey2)
                                                return -1;

                                            return 0;
                                        }

                            >> Genelleştirmede void gösterici tekniği yerine gömme tekniğinin tercih edildiğini belirtmiştik. Bu tekniği açıklamadna önce hazırlık amacıyla C'ye ilişkin bir konunun üzerinde duracağız. C'nin <stddef.h> içerisinde bildirilmiş olan offsetof makrosu yapının tür
                            ismini ve yapıdaki bir eleman ismini parametre olarak alır, o elemanın yapının başından itibaren kaçıncı offsette olduğunu verir. Örneğin:

                                struct SAMPLE {
                                    int a;					
                                    int b;
                                    char c[32];
                                    char d;
                                    int e;
                                };
                                size_t result;

                                result = offsetof(struct SAMPLE, e);

                            Burada yapının e elemanı yapı nesnesinin başından itibaren muhtemelen 44'üncü offset'indedir. Elemanların offset numaraları aşağıdaki gibi olacaktır:

                                struct SAMPLE {
                                    int a;				/* 0 */		
                                    int b;				/* 4 */
                                    char c[32];			/* 8 */
                                    char d;				/* 40 */
                                    int e;				/* 44 */
                                };

                            İşte offsetof makrosu bir yapı elemanının yapın nesnesnin kaçıncı offsetinde olduğunu elde etmek için kullanılmaktadır. offsetof makrosu size_t türündne bir değer vermektedir.
                                * Örnek 1,
                                    #include <stdio.h>
                                    #include <stddef.h>

                                    struct SAMPLE {
                                        int a;
                                        int b;
                                        char c[32];
                                        char d;
                                        int e;
                                    };

                                    int main(void)
                                    {
                                        size_t result;

                                        result = offsetof(struct SAMPLE, e);
                                        printf("%zd\n", result);					/* 44 */

                                        return 0;
                                    }

                            offsetof makrosu tipik olarak aşağıdakine benzer bir biçimde yazılmaktadır:

                                #define myoffsetof(type, member)		((size_t)&((type *)0)->member)

                            Burada 0 adresi önce ilgili yapı türünden adrese dönüştürülmüştür. (0 değerini herhangi türden bir adrese dönüştürürsek bu NULL adres anlamına gelmemektedir. 0 dğeri void * türüne dönüştürülürse bu NULL ares anlamına gelmektedir.) Sonra yapının elemanına eriilip
                            onun adresi alınmıştır. Bu durumda adresin sayısal bileşeni aslında ilgili eelemanın offset'i olacaktır. Nihayet bu değer son olarak size_t türüne dönüştürülmüştür. Yukarıdaki 0 adresinden başlayan yapının elemanına erişip onun adresini alma işlemi C'de "tanımsız
                            davranış" değildir. Çünkü burada standartlara göre gerçek bir erişim yapılmamaktadır. Yalnızca oranın adresi elde edilmiştir.
                                * Örnek 1,
                                    #include <stdio.h>
                                    #include <stdlib.h>
                                    #include <stddef.h>

                                    #define myoffsetof(type, member)		((size_t)&((type *)0)->member)

                                    struct SAMPLE {
                                        int a;
                                        int b;
                                        char c[32];
                                        char d;
                                        int e;
                                    };

                                    int main(void)
                                    {
                                        size_t result;

                                        result = myoffsetof(struct SAMPLE, e);
                                        printf("%zd\n", result);					/* 44 */

                                        return 0;
                                    }

                            Bir yapı içerisindeki bir elemanın adresini, o elemanın ismini ve yapının türünü bildiğimizi varsayalım. Bu durumda elemanın adresine ilişkin yapı nesnesinin başlangıç adresini veren container_of biçiminde bir makro yazabiliriz:

                                #define container_of(ptr, type, member)			((type *) ((char *) (ptr) - offsetof(type, member)))

                            Makronun birinci parametresi nesne içerisindeki elemanın adresi, ikinci parametresi yapının tür ismi ve üçüncü parametresi de elemanın ismini almaktadır. C standartlarında offsetof bir makro bulunmakla birlikte bu işi yapabilecek bir makro bulunmamaktadır. Aşağıdaki
                            container_of makrosunn kullanımına ilişkin bir örnek verilmektedir.
                                * Örnek 1,
                                    #include <stdio.h>
                                    #include <stddef.h>

                                    #define container_of(ptr, type, member)			((type *) ((char *) (ptr) - offsetof(type, member)))

                                    struct SAMPLE {
                                        int a;
                                        char b;
                                        int c;
                                        char d;
                                        double e;
                                        int f;
                                    };

                                    int main(void)
                                    {
                                        struct SAMPLE s = { 10, 'x', 20, 'y', 12.4, 100 };
                                        double *pd = &s.e;
                                        struct SAMPLE *ps;

                                        ps = container_of(pd, struct SAMPLE, e);
                                        printf("%d, %f\n", ps->a, ps->e);

                                        return 0;
                                    }

                            Gömme yöntemiyle veri yapıları genelleştirilirken aslında veri yapıları adeta kendi çekirdek kısımlarından oluşturulur. Örneğin bir bağlı listenin türden bağımsız bir biçimde bu teknikle oluşturulmak istendiğini düşünelim. Bağlı liste belli türdne bilgileri değil
                            NODE isimli düğümleri birbirine bağlayacaktır. Ancak NODE isimli düğümler bağlı liste elemanlarının tutacağı nesneleri içermeyecektir. Örneğin:

                                typedef struct tagNODE {
                                    struct tagNODE *next;
                                    struct tagNODE *prev;
                                } NODE;

                            Görüldüğü gibi burada NODE yapısı düğümğn tuttuğu bilgiyi içermemektedir. İşte bağlı liste bu biçimdeki düğümleri birbirine bağlamaktadır. Örneğin:

                                head_node <---> node <----> node <---> node <---> ....

                            Pekiyi bağlı liste düğümleri yalnızca link tuttuğuna göre böyle bir bağlı listeninin nasıl bir faydası olabilir? İşte bu düğümler aslında başka bir yapının içerisinde bir eleman olarak tutulacaktır. Örneğin:

                                struct PERSON {
                                    char name[32];
                                    int no;
                                    NODE link;
                                };

                            Görüldüğü gibi PERSON yapısının bir elemanı bağlı listenin düğümündne oluşmaktadır. Yani biz aslında düğümlerdne bağlı liste oluşturmaktayız ancak bu düğümler de ilgili türden nesnelerin elemanı durumundadır. Nasıl olsa biz yapının bir elemanının adresini
                            bildiğimizde o yapı nesnesinin başlangıç adresini yukarıda gösterdiğimiz gibi container_of makrosu ile elde edebiliriz. Bu yöntemde bir yapı nesnesi tek bir bağlı liste içerisinde bulunmak zorunda değildir. Örneğin Linux çekirdeğinde proses kontrol bloğu temsil 
                            eden task_struct yapısı pek çok bağlı listede bulunmaktadır. Burada yapılacak şey yapı içerisinde birden fazla link elemanı tutmaktır. Örneğin:

                                struct PERSON {
                                    char name[32];
                                    int no;
                                    NODE link1;
                                    NODE link2;
                                };

                            Aşağıdaki örnekte bir handle sistemi kullanılarak gömme tekniği ile türden bağımsız bağlı liste oluşturulmuştur. Burada yine bağlı listeler create_llist gibi bir fonksiyonla yaratılmaktadır. Gömme tekniğinde handle sisteminin kullanılması aşağı seviyeli çekirdek
                            kodları için uygun bir yöntem olmayabilir. Ancak biz aşağıda önce handle sistemi ile gömme tekniğine örnek vereceğiz. Sonra handle sistemi olmadan aynı tekniği kullanacağız. Yukarıda da belirttiğimiz gibi aslında örneğin Linux, BSD, CSD gibi işletim sistemi
                            kodlarında bu handle sistemi kullanılmamaktadır.
                                * Örnek 1,
                                    /* llist.h */
                                        #ifndef LLIST_H_
                                        #define LLIST_H_

                                        #include <stddef.h>
                                        #include <stdbool.h>

                                        /* Type Declarations  */

                                        typedef struct tagNODE {
                                            struct tagNODE *next;
                                            struct tagNODE *prev;
                                        } NODE;

                                        typedef struct tagLLIST {
                                            NODE head;
                                            size_t count;
                                        } LLIST, *HLLIST;

                                        /* Function Prototypes */

                                        HLLIST create_llist(void);
                                        NODE *insert_next(HLLIST hllist, NODE *node, NODE *new_node);
                                        NODE *insert_prev(HLLIST hllist, NODE *node, NODE *new_node);
                                        NODE *add_tail(HLLIST hllist, NODE *new_node);
                                        NODE *add_head(HLLIST hllist, NODE *new_node);
                                        void remove_node(HLLIST hllist, NODE *node);
                                        NODE *getp_item(HLLIST hllist, size_t index);
                                        bool walk_llist(HLLIST hllist, bool (*proc)(NODE *));
                                        bool walk_llist_rev(HLLIST hllist, bool (*proc)(NODE *));
                                        void clear_llist(HLLIST hllist);
                                        void destroy_llist(HLLIST hllist);

                                        /* inline Function Definitions */

                                        static inline size_t count_llist(HLLIST hllist)
                                        {
                                            return hllist->count;
                                        }

                                        static inline NODE *head_llist(HLLIST hllist)
                                        {
                                            return hllist->head.next;
                                        }

                                        static inline NODE *tail__llist(HLLIST hllist)
                                        {
                                            return hllist->head.prev;
                                        }

                                        /* Macro Definitions */

                                        #define container_of(ptr, type, member)			((type *) ((char *) (ptr) - offsetof(type, member)))

                                        #define FOR_EACH(hllist, node)		for (node = (hllist)->head.next; node != &(hllist)->head; node = node->next)
                                        #define FOR_EACH_REV(hllist, node)	for (node = (hllist)->head.prev; node != &(hllist)->head; node = node->prev)
                                        #define FREE_LLIST(hllist, node)	for (NODE *tnode = (hllist)->head.next;  node = tnode, tnode = tnode->next, node != &(hllist)->head; )

                                        #endif

                                    /* llist.c */
                                        #include <stdio.h>
                                        #include <stdlib.h>
                                        #include "llist.h"

                                        /* Function Definitions */

                                        HLLIST create_llist(void)
                                        {
                                            HLLIST hllist;

                                            if ((hllist = (HLLIST)malloc(sizeof(LLIST))) == NULL)
                                                return NULL;

                                            hllist->head.next = &hllist->head;
                                            hllist->head.prev = &hllist->head;
                                            hllist->count = 0;

                                            return hllist;
                                        }

                                        NODE *insert_next(HLLIST hllist, NODE *node, NODE *new_node)
                                        {
                                            node->next->prev = new_node;
                                            new_node->next = node->next;
                                            node->next = new_node;
                                            new_node->prev = node;

                                            ++hllist->count;

                                            return new_node;
                                        }

                                        NODE *insert_prev(HLLIST hllist, NODE *node, NODE *new_node)
                                        {
                                            node->prev->next = new_node;
                                            new_node->next = node;
                                            new_node->prev = node->prev;
                                            node->prev = new_node;

                                            ++hllist->count;

                                            return new_node;
                                        }

                                        NODE *add_tail(HLLIST hllist, NODE *new_node)
                                        {
                                            return insert_prev(hllist, &hllist->head, new_node);
                                        }

                                        NODE *add_head(HLLIST hllist, NODE *new_node)
                                        {
                                            return insert_next(hllist, &hllist->head, new_node);
                                        }

                                        void remove_node(HLLIST hllist, NODE *node)
                                        {
                                            node->prev->next = node->next;
                                            node->next->prev = node->prev;

                                            --hllist->count;
                                        }

                                        NODE *getp_item(HLLIST hllist, size_t index)
                                        {
                                            NODE *node;

                                            if (index >= hllist->count)
                                                return NULL;

                                            node = hllist->head.next;
                                            for (size_t i = 0; i < index; ++i)
                                                node = node->next;

                                            return node;
                                        }

                                        bool walk_llist(HLLIST hllist, bool (*proc)(NODE *))
                                        {
                                            for (NODE *node = hllist->head.next; node != &hllist->head; node = node->next)
                                                if (!proc(node)) 
                                                    return false;

                                            return true;
                                        }

                                        bool walk_llist_rev(HLLIST hllist, bool (*proc)(NODE *))
                                        {
                                            for (NODE *node = hllist->head.prev; node != &hllist->head; node = node->prev)
                                                if (!proc(node))
                                                    return false;

                                            return true;
                                        }

                                        void clear_llist(HLLIST hllist)
                                        {
                                            hllist->head.next = &hllist->head;
                                            hllist->head.prev = &hllist->head;

                                            hllist->count = 0;
                                        }

                                        void destroy_llist(HLLIST hllist)
                                        {
                                            free(hllist);
                                        }

                                    /* app.c */
                                        #include <stdio.h>
                                        #include <stdlib.h>
                                        #include "llist.h"

                                        typedef struct tagPERSON {
                                            char name[32];
                                            int no;
                                            NODE link;
                                        } PERSON;

                                        bool disp_person(NODE *node);

                                        int main(void)
                                        {
                                            HLLIST hllist;
                                            PERSON *per;
                                            NODE *node;
                                            
                                            if ((hllist = create_llist()) == NULL) {
                                                fprintf(stderr, "cannot create linked list...\n");
                                                exit(EXIT_FAILURE);
                                            }

                                            for (int i = 0; i < 100; ++i) {
                                                if ((per = (PERSON *)malloc(sizeof(PERSON))) == NULL) {
                                                    fprintf(stderr, "ccano tallocate memory!..\n");
                                                    exit(EXIT_FAILURE);
                                                }
                                                per->no = i;
                                                per->name[0] = '\0';

                                                add_tail(hllist, &per->link);
                                            }

                                            walk_llist(hllist, disp_person);
                                            
                                            printf("\n--------------------\n");
                                            
                                            FOR_EACH (hllist, node) {
                                                per = container_of(node, PERSON, link);
                                                printf("%d ", per->no);
                                                fflush(stdout);
                                            }

                                            printf("\n--------------------\n");

                                            FOR_EACH_REV (hllist, node) {
                                                per = container_of(node, PERSON, link);
                                                printf("%d ", per->no);
                                                fflush(stdout);
                                            }

                                            FREE_LLIST(hllist, node) {
                                                per = container_of(node, PERSON, link);
                                                free(per);
                                            }

                                            return 0;
                                        }

                                        bool disp_person(NODE *node)
                                        {
                                            PERSON *per;

                                            per = container_of(node, PERSON, link);
                                            printf("%d ", per->no);
                                            fflush(stdout);

                                            return true;
                                        }

            Graph çizdirmek için en fazla kullanılan araç "graphviz" isimli programdır. Bu programda bir grafı çizdirmek için önce graf bir dosyada ismine "dot dili (dot language)" bir dilde betimlenir. Sonra "dot" isimli programa bu dosya girdi olarak verilir. Bu program
            da bu girdi dosyasından hareketle istenilen formatta bir çıktı dosyası üretir. Tabii bunları yapabilmek için önce graphviz programını bilgisayarımıza kurmamız gerekir. Graphviz aşağıdaki bağlantıdan indirilebilir:

                https://graphviz.org/download/

            Graphviz'de bir graf çizmek için grafın türü belirtilerek blok oluşturulur. Sonra bloğun içerisinde grafın düğümleri ve kenarları belirtilir. Örneğin:

                digraph G {
                    size="30, 40!"
                    A -> B 
                    B -> D
                    B -> C
                    C -> A
                    D -> C
                    D -> E
                    E -> D
                    E -> F
                    F -> C
                    C -> F
                    G -> F
                    C -> G
                    C -> E
                    D -> H
                    H -> I
                    I -> D
                }

            Buradaki size ibaresi inch cinsinden grafin genişlik ve yülksekliğiniş belirtmektedir. Satırların yanlarına köşeli parantez içerisinde label eklenebilir. Bu durumda belirtilen yazılar kenarların yanlarında görüntülenir. Örneğin:

                digraph G {
                    A -> B [label="10"]
                    B -> D [label="7"]
                    B -> C [label="15"]
                    C -> A [label="5"]
                    D -> C [label="20"]
                    D -> E [label="18"]
                    E -> D [label="18"]
                    E -> F [label="19"]
                    F -> C [label="16"]
                    C -> F [label="16"]
                    G -> F [label="11"]
                    C -> G [label="25"]
                    C -> E [label="12"]
                    D -> H [label="11"]
                    H -> I [label="9"]
                    I -> D [label="20"]
                }

            Aşağıdaki örnekte Windows'ta CSV dosyasından hareketle bir ".dot" dosyasını programlama yoluyla oluşturulmuş sonra da "dot" programı çalıştırılarak ".png" dosyası elde edilmiştir. Nihayet bu ".png" dosyası da yine programlama yoluyla görüntülenmiştir. Burada
            kullanılabielcek örnek "graph.csv" dosyası şöyledir:

                A,B,10
                B,D,7
                B,C,15
                C,A,5
                D,C,20
                D,E,18
                E,D,18
                E,F,19
                F,C,16
                C,F,16
                G,F,11
                C,G,25
                C,E,12
                D,H,11
                H,I,9
                I,D,20
                A,I,40
                I,J,11
                J,D,21
                D,A,17
                F,H,30
                G,J,40

            Programın kodları ise aşağıdaki gibidir:
                * Örnek 1,
                    /* graphmake.c */
                        #include <stdio.h>
                        #include <string.h>
                        #include <stdlib.h>
                        #include <stdbool.h>
                        #include <windows.h>

                        #define MAX_LINE_LEN		4096

                        void ExitSys(LPCSTR lpszMsg);

                        bool csv2dot(const char *path_csv, const char *path_dot)
                        {
                            FILE *f_csv, *f_dot;
                            char buf[MAX_LINE_LEN];
                            char *name1, *name2, *length;
                            bool retval = false;

                            if ((f_csv = fopen(path_csv, "r")) == NULL)
                                return false;

                            if ((f_dot = fopen(path_dot, "w")) == NULL)
                                goto EXIT1;

                            if (fprintf(f_dot, "digraph G {\n") < 0)
                                goto EXIT2;

                            while (fgets(buf, MAX_LINE_LEN, f_csv) != NULL) {
                                if ((name1 = strtok(buf, ",\n")) == NULL)
                                    continue;
                                if ((name2 = strtok(NULL, ",\n")) == NULL)
                                    goto EXIT2;
                                if ((length = strtok(NULL, ",\n")) == NULL)
                                    goto EXIT2;
                                if (strtok(NULL, ",\n") != NULL)
                                    goto EXIT2;

                                if (fprintf(f_dot, "\t%s -> %s [label=\"%s\"]\n", name1, name2, length) < 0)
                                    goto EXIT2;
                            }

                            if (fprintf(f_dot, "}\n") < 0)
                                goto EXIT2;

                            retval = true;

                        EXIT2:
                            fclose(f_dot);
                        EXIT1:
                            fclose(f_csv);

                            return retval;
                        }

                        bool dot2png(const char *path_dot, char *path_png)
                        {
                            char cmdline[4096];
                            STARTUPINFO si = {sizeof(si)};
                            PROCESS_INFORMATION pi;
                            bool result;

                            sprintf(cmdline, "dot -Tpng %s -o %s", path_dot, path_png);
                            
                            result = CreateProcess(NULL, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);

                            CloseHandle(pi.hThread);
                            CloseHandle(pi.hProcess);

                            return result;
                        }

                        int main(void)
                        {
                            HINSTANCE hResult;

                            if (!csv2dot("graph.csv", "test.dot")) {
                                fprintf(stderr, "cannot generate dot file!..\n");
                                exit(EXIT_FAILURE);
                            }

                            if (!dot2png("test.dot", "test.png")) {
                                fprintf(stderr, "cannot generate png file!..\n");
                                exit(EXIT_FAILURE);
                            }

                            hResult = ShellExecute(NULL, "open", "test.png", NULL, NULL, SW_NORMAL);

                            if ((INT_PTR)hResult < 32)
                                ExitSys("ShellExecute");

                            return 0;
                        }

                        void ExitSys(LPCSTR lpszMsg)
                        {
                            DWORD dwLastError = GetLastError();
                            LPTSTR lpszErr;

                            if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
                                fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
                                LocalFree(lpszErr);
                            }

                            exit(EXIT_FAILURE);
                        }
                      
> Hatırlatıcı Notlar:
    >> Stack (yığın) sözcüğü hem işlemciler tarafından kullanılan bir mekanizmayı hem de bir veri yapısını anlatmaktadır. Yani işlemciler kendi çalışmaları
    sırasında ismine "stack" denilen bir alanı kullanmaktadır. Ancak aynı zamanda algoritmalar ve veri yapıları dünyasında "stack" isimli bir veri yapısı da
    vardır. (Tabii stack veri yapısına işlemcilerin kullandığı "stack mekanizmasına" benzemekten dolayı "stack" ismi verilmiştir.) Biz C derlerinden
    fonksiyonların yerel değişkenlerinin stack'te yaratıldığını biliyoruz. Fonksiyonların parametre değişkenleri de bazı sistemlerde stack'te bazı sistemlerde
    CPU yazmaçlarında yaratılmaktadır. Stack denilen alan RAM'in bir bölgesidir. Yani RAM'in içerisinde bir yerdir. Bir programın (genel olarak thread'in)
    kullanacağı stack alanı ve miktarı işletim sistemi tarafından belirlenmektedir. Yani program yüklendiğinde işlemcinin kullanacağı stack alanı ve miktarı
    zaten belirlenmiş durumdadır. Stack aalanı genellikle işlemcilerde aşağıdan yukarıya doğru kullanılmaktadır. Bir fonksiyon çağrıldığında o fonksiyonun
    yerel değişkenleri stack'te yaratılır. Stack'in aktif noktası (top of the stack) işlemcinin bir yazmacı (register) tutulmaktadır. Bu yazamaca genel olarak
    "stack pointer" denilmektedir. Her fonksiyon çağrılmasında stack pointer o fonksiyonun yerel değişkenleri kadar yukarı çekilir ve fonksiyonun yerel
    değişkenleri orada yaratılır. Örneğin:

        void bar(void)
        {
            int x, y;
        }

        void foo(void)
        {
            int a, b;

            bar();
        }

    Bu tanımlamalar doğrultusunda,

        -> Buraada başlangıç noktasının aşağıdaki gibi olduğunu düşünelim:

            SP ----> Stack'in sonu

        -> foo çağrıldığında şöyle bir durum oluşacaktır:

            SP ---->
                    a
                    b
                    Stack'in sonu

        -> Şimdi foo fonksiyonu bar fonksiyonunu çağırmış olsun:

            SP ---->
                    x
                    y
                    a
                    b
                    Stack'in sonu

        -> Şimdi bar fonksiyonunun sonlandığını düşünelim:

            SP ---->
                    a
                    b
                    Stack'in sonu

    şeklinde olacaktır. Stack konusundaki şu noktalara da dikkat etmeliyiz:
        >>> Fonksiyonun yerel değişkenlerinin stack'teki konumları için standart bir belirleme yapılmamıştır. Genellikle derleyiciler fonksiyonların yerel
        değişkenlerini ardışıl bir biçimde stack'te oluştururlar. Bazı derleyiciler ilk bildirilen yerel değişken düşük adreste olacak biçimde bazıları ise
        yüksek adreste olacak biçimde oluşturmaktadır. Ancak stack yalnızca yerel değişkenler için kullanılmaktadır.
        
        >>> Bir fonksiyon CALL makine komutu ile çağrıldığında geri dönüşün mümkün olabilmesi için CALL makine komutunda işlemci sonraki komutun adresini
        stack'te saklar. ret makine komutu da stack'ten bu adresi alarak geri dönüşü sağlar. Yani bir fonksiyon çağırdığımızda da stack'te dolaylı bir biçimde
        yer ayrılmaktadır. Yukarıdaki foo fonksiyonunun bar fonksiyonu çağırması durumunun daha gerçekçi stack götüntüsü şöyle olacaktır:

        SP ---->
                x
                y
                <bar için geri dönüş adresi>
                a
                b
                <foo için geri dönüş adresi>
                Stack'in sonu

        >>> Stack'te yerel değişkenlerin tahsisatı çok hızlı bir biçimde tek bir makine komutuyla yapılabilmektedir. Örneğin bir fonksiyonun toplam 100 byte
        uzunluğunda yerel değişkenleri olsun. Tahisat stack pointer'ın 100 byte azaltılması ile yani tek bir makine komutuyla yapılabilmektedir. Benzer
        biçimde tahsisatın geri alınması da tek bir makine komutuyla stack pointer'ın 100 byte artırılması ile yapılabilmektedir. Pekiyi stack için
        ayrılan alan yetmezse ne olur? Eğer fonksiyon çağrılarıyle stack'ta çok fazla alan tahsis edilirse stack yukarıdan taşabilir. Buna İngilizce
        "stack overflow" denilmektedir. Tabii stack'in taşması durumu derleme aşamasında tespit edilemez. Çünkü derleme sırasında hangi fonksiyonun hangi
        fonksiyonu çağıracağı kesin olarak bilinememektedir. Stack taşması durumunda koruma mekanizmasının olduğu Windows gibi, Linux gibi, macOS gibi
        sistemlerde taşma işlemci tarafından belirlenip işletim sistemine bildirilmektedir. İşletim sistemi de taşmaya yol açan prosesi sonlandırmaktadır.
        32 bit ve 64 bit Windows sistemlerinde default stack 1MB'tır. Ancak 32 bit ve 64 bit Linux sistemlerinde default stack 8MB'dir. 1MB stack
        aslında genel olarak büyük bir stack'tir.
        
        >>> Pekiyi fonksiyonların parametre değişkenleri nerede ve nasıl yaratılmaktadır? Yukarıda da belirttiğimiz gibi parametre aktarımı stack yoluyla
        ya da yazmaç yoluyla yapılabilmektedir. Örneğin 32 bit Windows, Linux ve macOS sistemlerinde aktarım stack yoluyla yapılırken, 64 bir Windows
        Linux ve macOS sistemlerinde yazmaç yoluyla yapılmaktadır. Fonksiyon çağrısı sırasındaki aşağı seviyeli bu ayrıntılara genel olarak "Application
        Binary Interface (ABI)" denilmektedir. Fonksiyon çağrısı özelinde uygulanan yönteme "fonksiyon çağırma biçimi (function calling convention)"
        da denilmektedir. Eğer parametreler yazmaç yoluyla aktarılıyorsa iç içe çağırmalarda yazmaçların korunması çağrılan fonksiyonun (callee)
        sorumluluğundadır. Tabii içteki fonksiyon bunun için stack kullanır. O halde özünde parametre değişkenlerinin de stack yoluyla saklandığını 
        söyleyebiliriz. 
