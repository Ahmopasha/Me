> C dilinde Tanımsız Davranış, Derleyiciye Bağlı Davranış ve Belirsiz Davranış Kavramları: C programcısı olarak bu durumlardan 
GÖZ ARDI ETMEMELİYİZ.  
    >> Tanımsız Davranış: Dilin sentaks kurallarına uygundur fakat yapıldığı taktirde her şey olabilir demektir. Çalışma zamanında 
    ne olacağı kestirilemeyen şeyler için veya farklı derleyiciler arasında ortak bir şey belirlenmeyen durumlar için 
    Tanımsız Davranış terimi kullanılır. İngilizce'si "Undefined Behavior" demektir.  
    
    >> Derleyiciye Bağlı: Bir kodun çıktısının derleyiciye bağlı olarak değişmesi durumudur. Derleyiciyi yazanlar böylesi durumları 
    dökümante etmelidir. İngilizce'si "Implementation Defined" demektir.  

    >> Belirsiz Davranış: Derleyiciye Bağlı durumların dökümante edilmemiş versiyonlarıdır. Sonuçta patolojik bir durum meydana gelmez 
    fakat işleyişin nasıl yapılacağı derleyiciye yazanlara bırakılmıştır. Fakat derleyiciyi yazanlar bu tip durumları dökümante etmek 
    zorunda değildir. İngilizce'si "Unspecified Behavior" demektir. 

> Derleyicilerin Hata Mesajları ve Standartlara Uyum: C derleyicileri hata/uyarı mesajlarını vermekle yükümlüdür fakat hatalı bir şekilde 
programı da derleyebilir. Standartlara göre yükümlü olduğu şey hata/uyarı mesajlarının verilmesi. Öte yandan derleyiciler ekstra
uyarı mesajları da verebilirler, bu konuda da bir kısıtlama getirilmemiştir. Dolayısıyla BAŞARILI BİR ŞEKİLDE DERLENEN C KODU İÇİN  
GEÇERLİ BİR KOD DENMEZ. Burada bizler hangi kodların Tanımsız Davranış, Derleyiciye Bağlı Davranış veya Belirsiz Davranış içerdiğini 
bilmeliyiz ve yazdığımız kodlarda bunları göz önünde BULUNDURMALIYIZ.

> C Programlarının Derlenmesi: 
    >> "Microsoft Visual Studio" programını yüklediğimiz zaman aynı zamanda "Microsoft" derleyicisi de yüklenir. Bu programın adı 
    "cl" biçimindedir. Dolayısıyla "sample.c" isimli dosyayı bu derleyici ile derlemek için "cl sample.c" demeliyiz. 
        >>> "cl" derleyicisine ilişkini bazı seçenekler: "Developer Command Prompt" isimli "shell" programını kullanmalıyız. 
            >>>> "/Fe" seçeneğini kullanırsak, oluşturulacak "executable" dosyasının adını değiştirebiliriz. 
            >>>> "/c" seçeneğini kullanırsak, sadece derler. 
            >>>> "link" programını kullanırsak, ilgili ".obj" dosyasını link edecektir. 
    
    >> UNIX/Linux türevi sistemlerde "gcc" derleyicisi kullanılır. Varsayılan bir bileşen olarak işletim sistemini kurarken 
    kurulur. "gcc" derleyicisine ek olarak "clang" derleyicisi de kullanılmaktadır. Apple ailesinde genellikle "clang" derleyicisi 
    kullanılır. Bu derleyiciyi kurmak için 

        sudo apt-get install clang 

    komutunu "shell" programından çalıştırmalıyız. Bu iki derleyicinin komut satırı argümanları birbiriyle uyumludur. Öte yandan
    "gcc" derleyicisinin "Windows" uyumlu hale getirilmiş versiyonuna "MinGW" denmektedir. 

> "Linux" komut satırı komutlarından çoğunu öğrenmeliyiz. "%80-%20" kuralına göre bir şeyin %20'si yapacağımız şeyin %80'ini 
karşılamaktadır. 
    >> "file" komutu, argüman olarak aldığı dosyanın özelliklerini ekrana yazdırır. Örneğin, "file sample.c" biçiminde kullanılır. 

> "Microsoft Visual Studio" ile çalışırken;
    >> "Solution" kavramı bünyesinde birden fazla "proje" barındırabilmektedir. Dolayısıyla "Solution" kavramı ile "Project"
    kavramı birbirinden farklı kavramlardır. Yani bir "Solution" içerisine birden fazla "Project" ekleyebiliriz.
    >> Proje Özellikleri'ni açıp "C/C++" başlığı altındaki "Genel" sekmesine geldikten sonra "SDL Denetimleri" özelliğini devre
    dışı bırakmalıyız. Aksi halde "_CRT_SECURE_NO_WARNINGS" sembolik sabitini "define" etmemiz gerekmektedir. 
    >> "Ctrl + F5" yaparsak derler ve çalıştırır. "Ctrl + Shift + B" yaparsak derlenmiş ise onu bağlar, derlenmemiş ise derler 
    ve bağlar. 

> Hatırlatıcı Notlar: 
    >> C dilinde çift tırnak içerisindeki karakterleri değiştirmek Tanımsız Davranıştır. Bunun istisnai durumu bir diziye ilk değer 
    verilmesi durumudur. 
        * Örnek 1, Elemanları "char" olan bir diziye ilk değer verirken kullanılan çift tırnak, bu durumda istisnaidir. 
            //...

            int main()
            {
                /*
                * Burada "string" isminde bir dizi oluşturulu ve her bir indisie sırasıyla
                * "A", "h", "m", "e", "t" ve "\0" karakterleri getirilir. 
                */
                char string[] = "Ahmet";

                /*
                * Dolayısıyla yukarıda yapılan şey aslında aşağıdaki ile aynıdır. Yani ikisi 
                * arasında bir fark yoktur. 
                */
                char str[] = { 'a', 'h','m','e','t','\0' };
            }

        * Örnek 2,
            //...
            int main()
            {
                /*
                * Burada aslında "Ahmet" yazısı bellekte bir yere yerleştiriliyor. "string" isimli gösterici 
                * ise bu yazıyı gösterir durumdadır. Bellekte yerleştirilen yeri bizler değiştiremiyoruz. 
                */
                char* string = "Ahmet";
            }

    >> "Visual Studio" ile "debugger" çalıştırdığımız vakit, yani F11 tuşuna bastığımızda, standart C fonksiyonlarının içerisine 
    girmesini istiyorsak, "Araçlar > Seçenekler > Hata Ayıklama / Yalnızca Kendi Kodumu Etkinleştir" özelliğini "uncheck" yapıyoruz. 

    >> Hex Editor: HxD - Freeware Hex Editor and Disk Editor

	>> "https://calcoen.web.cern.ch/Linux_keys.htm" adresi üzerinden Linux sistemlerindeki alternatif terminal açma yöntemlerine bakabiliriz. 

    >> Bir bit'i bir, diğerleri sıfır olan değerleri "&" operatörü ile işleme sokmak:
        #include <stdio.h>

        #define GENERIC_READ    0x0001
        #define GENERIC_WRITE   0x0010

        void foo(int flags){
            if(flags & GENERIC_READ)
                printf("Read\n");

            if(flags & GENERIC_WRITE)
                printf("Write\n");
        }

        int main(void){
            /*
                # OUTPUT #
                Read
                Write
                Read
                Write
            */

            foo(GENERIC_READ); 
            foo(GENERIC_WRITE);
            foo(GENERIC_READ | GENERIC_WRITE);
        }