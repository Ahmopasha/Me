> İşlemcilerin Koruma Mekanizması: Bugün kullandığımız güçlü mikroişlemciler "koruma mekanizması (protection mechanism)" denilen önemli
bir özelliğe sahiptir. Örneğin A serisi ARM işlemcileri, Intel işlemcileri, Power PC işlemcileri, Alpha işlemcileri, Itanium işlemcileri
koruma mekanizmalarına sahiptir. Ancak mikrodenetleyiciler ve küçük kapasiteli işlemcilerde bu mekanizma bulunmamaktadır. Intel işlemcileri
80286 modelleriyle birlikte segment tabanlı, 80386 modelleriyle birlikte sayfa tabanlı koruma mekanizmasına sahip olmuşlardır. A (Applivation)
serisi cortex'lere sahip ARM işlemcilerinde koruma mekanizması vardır. Ancak M (Microcontroller) cortext'lerine sahip ARM işlemcilerinde
genel olarak bu mekanizma bulunmamaktadır. Bugün Windows, Linux, macOS gibi işletim sistemleri ancak koruma mekanizmasına sahip işlemcilerde
çalışabilmektedir. Koruma mekanizmasının temelde iki işlevi vardır:

    -> Bellek Koruması
    -> Komut Koruması

Bu korumalarda,
    >> Bellek Koruması: Çok prosesli işletim sistemlerinde farklı programlar aynı anda RAM'de bulunmaktadır. Bir program kendi bellek alanının
    dışına çıkıp başka programların (ve hatta işletim sisteminin) bellek alanına erişip orada değişiklikler yaparsa bundan tüm sistem olumsuz
    etkilenebilir, diğer prgramın çalışması bozulabilir, o programlar yaznlı çalışabilirler. Bir programın değişiklik yapmadan başka bir
    programın bellek alanına erişmesi de tehlikeldir. Bu sayede kötü amaçlı programlar başka programın çalışması hakkında casusluk yapabilirler.
    Halbuki C'de bir göstericiye RAM'deki herhangi bir adresi yerleştirip RAM'in o bölgesine erişebiliriz. Pekiyi bir programın kendi bellek alanı
    dışına erişmesi nasıl engellenebilir? Bu engelleme yalnızca işletim sistemi tarafından yapılamaz. Engellemenin en alt düzeyde işlemci
    tarafından yapılması gerekir. Bir program kendi bellek alanının dışına eriştiği zaman bu erişim birinci elden işlemci tarafından tespit edilir.
    İşlemci bu durumu işletim sistemine bildirir. İşletim sistemi de programı cezalandırarak sonlandırır. 

    >> Komut Koruması: Bazı makine komutları uygunsuz kullanıldığında tüm sistemin çökmesine yol açabilmektedir. İşte işlemcilerin koruma mekanizmaları
    bu makine komutlarını da denetlemektedir. Buna "komut koruması" denilmektedir. Bu tür komutları kullanan programlar işlemci tarafından tespit edilir.
    İşlemci durumu işletim sistemine bildirir. İşletim sistemi de programı cezalandırarak sonlandırır. 

Yukarıda açıkladığımız koruma mekanizmasının işlemci tarafından nasıl sağlandığı ve ihlallerin işletim sistemine nasıl iletildiği kişiler
tarafından merak edilmektedir. Bu konu kursumuzun konusu dışındadır. Mekanizmanın ayrıntıları "Sembolik Makine Dili" kurslarında ele 
alınmaktadır. Öte yandan işletim sistemleri bellekte her yere erişebilmeli her makine komutunu kullanabilmeldir. Aksi takdirde faaliyetlerini yürütemezler.
O halde koruma mekanizması işletim sistemi için uygulanmamalı yalnızca sıradan uygulama programları için uygulanmalıdır. İşte işlemcileri tasarlayanlar genellikle
çalışmakta olan akış için iki çalışma modu kullanırlar:
    
    -> Kernel mod
    -> User mod.
    
Bir kod kernel modda çalışıyorsa ona koruma mekanizması uygulanmaz. Böylece kernel modda çalışan programlar bellekte her yere erişebilirler her makine komutunu
kullanabilirler. Ancak user modda çalışan kodlara koruma mekanizması uygulanmaktadır. Programların hemen hepsi user modda çalımaktadır. örneğin Windows'taki Excel,
Word, Visual Studio, Internet Explorer vs hep user modda çalışırlar. Benzer biçimde UNIX/Linux sistemlerindeki programlar kabuğun kendisi (örneğin bash), dışsal
komutlar user modda çalışırlar. UNIX/linux sistemlerindeki root proseslerin bu konuyla hiçbir ilgisi yoktur. Yani bu sistemlerde biz bir programı sudo yaparak
çalıştırdığımızda yine o program user modda çalışmaktadır. Örneğin, bir işletim sisteminin kodları, aygıt sürücü kodları kernel modda çalışmaktadır. Programcı bir
kod parçasının koruma engeline takılmadan kernel modda çalışmasını istiyorsa onu "aygıt sürücüsü (device driver)" olarak yazmalıdır. Intel işlemcilerinde dört
çalışma modu vardır. Bunlara "ring" de denilmektedir. Bu çalışma modlarına 0, 1, 2, 3 biçiminde numara verilmiştir. Korumanın hiç uygulanmadığı mod 0, korumanın tam
uygulandığı mod 3'tür. Windows, Linux ve macOS sistemleri Intel işlemcilerinin iki modunu kullanmaktadır: 0 ve 3. Yani her ne kadar Intel işlemcilerinde 4 çalışam
modu olsa da aktif olarak zaten iki mod kullanılmaktadır. Pekiyi user mod bir program işletim sisteminin istem fonksiyonunu çağırdığında ne olur? İşletim sisteminin
sistem fonksiyonları bellekte her yere erişebilmekte ve özel makine komutlarını kullanabilmektedir. Eğer user mod program işletim sisteminin sistem fonksyonarını user
modda çalıştırsa hemen koruma mekanizmasına takılırdı. İşte user mod bir program işletim sisteminin sistem fonksiyonlarını çağırdığında geçici süre otomatik olarak user
mod'tan kernel mod'a geçirilmektedir. Böylece sistem fonksiyonları kernel modda çalıştırılmaktadır. Sistem fonksiyonundan çıkılırken yeniden user moda geri dönülmektedir.
Bu duruma "prosesin user mod'tan kernel moda geçmesi" ve "kernel moddan user moda geri dönmesi" denilmektedir. Tabii kernel moda geçişin ve geri dönüşün bir zaman maliyeti
vardır. Yani işletim sisteminin sistem fonksiyonlarını çağırmanın diğer fonksiyonları çağırmaktan zamansal bakımdan daha maliyetli olduğu söylenebilir. Aşağıda bu konuya
ilişkin bir örnek verilmiştir:
    * Örnek 1, Bir dosyanın bütün byte'ları üzerinde bir işlem yapacak olalım. Dosyanın her byte'ını tek tek read fonksiyonu ile aşağıdaki gibi okumaya çalışmak kötü bir
    tekniktir:

        while ((result = read(fd, &ch, 1)) > 0) {
            /* ... */
        }

    Çünkü her byte için read fonksiyonun çağrılması (read fonksiyonu da sistem fonksiyonunu doğrudan çağırmaktadır) user mod, kernel mod geçişleri nedneiyle zaman kaybının
    oluşmasına yol açar. Bu durumda ilk akla gelen alternatif yöntem okuma işlmelerini blok blok yapmaktır. Örneğin:

        while ((result = read(fd, buf, 8192)) > 0) 
            for (ssize_t i = 0; i < result; ++i) {
                /* ... */
            }

    Burada sistem fonksiyonu çok daha az çağrılacak ve önemli bir hız kanacı oluşacaktır. Aşağıda bu durumun simülasyonuna ilişkin bir örnek verilmiştir. Örneğimizde içi sıfırlarla
    dolu 5120000 uzunluğunda bir dosya kullanılmıştır. Bu dosya aşağıdaki gibi yaratılabilir:

        dd if=/dev/zero of=test.dat bs=512 count=10000

    Aşağıdaki örnekte test1 programı her byte için read fonksiyonunu çağırmıştır. test2 programı ise 8192 byte'lık bloklarlarla okumayaı yapmıştır. test1 programının çalışma süresi
    3.040 saniye, test2 programının çalışma süresi ise 0.014 saniye sürmüştür. İki yöntem arasında yaklaşık 300 kat bir hız farkı vardır. 
        /* test1.c */
            #include <stdio.h>
            #include <stdlib.h>
            #include <time.h>
            #include <fcntl.h>
            #include <unistd.h>

            void exit_sys(const char *msg);

            void proc(int ch)
            {
                /* EMPTY */
            }

            int main(int argc, char *argv[])
            {
                int fd;
                char ch;
                ssize_t result;
                clock_t start, stop;
                double telapsed;

                if (argc != 2) {
                    fprintf(stderr, "wrong number of arguments!..\n");
                    exit(EXIT_FAILURE);
                }

                start = clock();

                if ((fd = open(argv[1], O_RDONLY)) == -1)
                    exit_sys("open");

                while ((result = read(fd, &ch, 1)) > 0)
                    proc(ch);

                if (result == -1)
                    exit_sys("read");

                close(fd);

                stop = clock();

                telapsed = (double) (stop - start) / CLOCKS_PER_SEC;

                printf("%.3f\n", telapsed);

                return 0;
            }

            void exit_sys(const char *msg)
            {
                perror(msg);
                exit(EXIT_FAILURE);
            }

        /* test2.c */
            #include <stdio.h>
            #include <stdlib.h>
            #include <time.h>
            #include <fcntl.h>
            #include <unistd.h>

            void exit_sys(const char *msg);

            void proc(int ch)
            {
                /* empty */
            }

            int main(int argc, char *argv[])
            {
                int fd;
                ssize_t result;
                clock_t start, stop;
                double telapsed;
                char buf[8192];

                if (argc != 2) {
                    fprintf(stderr, "wrong number of arguments!..\n");
                    exit(EXIT_FAILURE);
                }

                start = clock();

                if ((fd = open(argv[1], O_RDONLY)) == -1)
                    exit_sys("open");

                while ((result = read(fd, buf, 8192)) > 0) 
                    for (ssize_t i = 0; i < result; ++i)
                        proc(buf[i]);
                    
                if (result == -1)
                    exit_sys("read");

                close(fd);

                stop = clock();

                telapsed = (double) (stop - start) / CLOCKS_PER_SEC;

                printf("%.3f\n", telapsed);

                return 0;
            }

            void exit_sys(const char *msg)
            {
                perror(msg);
                exit(EXIT_FAILURE);
            }

Biz kendi programımızın belleğin her yerine erişmesini istiyorsak, onun özel makine komutlarını kullanmasını sağlamak isiyorsak programamızı "aygıt sürücü (device driver)"
biçiminde organize etmeliyiz. Tabii aygıt sürücüleri sisteme sıradan kullanıcılar yükleyememektedir. Aygıt sürücüler sistemin yöneticileri tarafından (örneğin Linux'ta root
kullanıcısı tarafından) yüklenebilmektedir. Aygıt sürücüler sistemin boot edilmesi sırasında işletim sisteminin bir parçası olarak yüklenebilir ya da sistem çalışırken çeşitli
komutlarla da yklenebilmektedir. Bir diğer husus da işlemcileri tasarlayanlar genellikle koruma mekanizamasını "açılıp kapatılacak biçimde" tasarlamalarıdır. Pek çok işlemci reset
edildiğinde koruma mekanizması aktif değildir. Koruma mekanizasması genellikle işletim sistemi yüklenirken işletim sisteminn kodları tarafından aktif hale getirilmektedir. Koruma
mekanizmasını kapatabilmek için yine kernel modda olnması gerekmektedir. Ancak işletim sistemleri bir kere koruma mekanizmasını aktif hale getirince artık bir daha pasif hale
getirmemektedir. 

> Hatırlatıcı Notlar:
    >> 32 bit Windows sistemleri 32 bit işlemciler için yazılmıştır. Bu işlemcilerin toplam adresleyebildiği fiziksel RAM 4GB'dir. Dolayısıyla bu sistemlerde zaten sayfa tabloları 4GB'lik bir fiziksel alanı
    haritalandırmaktadır. 32 bit Windows sistemlerinde her proses sanki 4GB'lik bir sanal belleğe tek başına yükleniyormuş gibi sanal bellek kullanmaktadır. Ancak Windows 4GB alanın 2GB'sini user için 2GB'sini
    de kernel için ayırmıştır. Bu durumda 32 bit Windows sistemlerinde normal bir prosesin kullanabileceği maksimum sanal bellek 2GB'dir. 64 bit Windows sistemleri 64 bit işlemciler için yazılmıştır. Bu işlemciler
    teorik olarak 16EB belleği adresleyebilmektedir. 64 bit Windows sistemleri eskiden yalnızca belleğin ilk 16TB'sini kullanıyordu. Ancak Windows 10 ile birlikte bu sistemlerde 128TB alan user prosesler için 
	128TB alan da kernel tarafından kullanılmaktadır. Bu konun ayrıntıları vardır. 32 bit Linux sistemlerinde sanal bellek alanının ilk 3GB'si user prosesler tarafından kalan 1GB'si kernel tarafından ayrılmıştır.
    64 bit Linux sistemlerinde ise user alanı ve kernel alanı 128TB kadar olabilmektedir. İşlemci destekliyor olsa da işletim sistemleri gereksiz büyüklükleri onları kontrol etmek için alan gerektiği için
    desteklememektedir. 