> C'de Çok Boyutlu Diziler: Çok boyutlu diziler aslında C'de dizi dizileri olarak düşünülmelidir. Öneğin:

    int a[3][2];

Burada a aslında 3 elemanlı bir dizidir. Ancak dizinin her elemanı "int[2] türünden yani 2 elemanlı bir int dizidir. İlk köşeli parantez 
her zaman asıl dizinin uzunluğunu belirtmektedir. Diğer köşeli parantezler eleman olan dizinin türü ile ilgilidir. Bir dizinin ismi dizinin
ilk elemanın adresini belirttiğine göre yukarıdaki iki boyutlu dizide a ifadesi aslında iki elemanlı bir int dizinin adresini belirtir. 
Biz C'de dizilerin adreslerini alabiliriz. Bu durumda elde edilen adres dizi türünden adres olur. Dizi türünden adresler sembolik olarak 
"tür (*)[uzunuk]" biçiminde ifade edilir. Dizi türünden adresleri tutan göstericilere "dizi göstericileri (pointer to array)" denilmektedir. Örneğin:

    int a[2];
    int (*pa)[2];

    pa = &a;

Mademki bir dizinin ismi o dizinin ilk elemanın adresini belirtmektedir. O halde aşağıdaki iki boyutlu dizinin ismi hangi türden adres belirtir?

	int a[3][2];

Burada a 3 elemanlı, her elemanı 2 elemanlı birint dizi olan bir dizidir. Yani a dizisinin türü int[2] biçimindedir. O halde a ifadesi de aslında
int (*)[2] türündendir. Biz a adresini aynı türden bir dizi göstericisine yerleştirebiliriz. Örneğin:

	int a[3][2];
	int(*pa)[2];

	pa = a;

C'de Çok Boyutlu Diziler ile çalışırken şu noktalara da dikkat etmeliyiz:
    >> Dizi göstericileri bildirilirken ilk boyut dışındaki boyut uzunlukları belirtilemk zorundadır. Örneğin:

        int (*pa)[];		/* geçersiz! */

    >> Bir dizinin adresini, aynı uzunluğa ilişkin bir dizi göstericisine atayamayız. Örneğin:

        int a[3];
        int (*pa)[2];

        pa = &a; /* geçersiz! */

    Burada pa göstericisinin aşağıdaki gibi tanımlanması gerekirdi:

        int (*pa)[3];

    >> Çok boyutlu dizilerin adresleri de benzer biçimde aynı türden bir dizi göstericisine atanabilir. Örneğin:

        int a[2][3][4];
        int (*pa)[3][4];

        pa = a;		/* geçerli */

    >> C'de çok yapılan bir hata bir matrisin adresinin gösterici göstericiye atanmaya çalışılmasıdır. Örneğin:

        void foo(int **ppi)
        {
            ...
        }
        ...
        int a[3][2];
        ...
        foo(a);		/* geçersiz! */

    Burada foo fonksiyonunun parametresinin aşağıdaki gibi olması gerekirdi:

        void foo(int (*pa)[2])
        {
            ...
        }
        ...
        int a[3][2];
        ...
        foo(a);		/* geçerli ! */

    Maalesef C'de her uzunlukta çok boyutlu dizinin adresinin atanabileceği gösterici oluşturmak mümkün değildir. Bu tür durumlarda ne yapılması
    gerektiği izleyen paragraflarda açıklanmaktadır. 

    >> Bir dizi göstericisinin gösterdiği yere erişirsek o dizinin tamamına erişmiş oluruz. Örneğin:

        int a[3][2];
        int (*pa)[2];
        pa = a;

    Burada pa aslında matrisin ilk elemanı olan iki elemanlı int dizinin tamamını göstermektedir. Dolayısıyla *pa ifadesi ya da pa[0] ifadesi 
	aslında 2 elemanlıbir int diziyi temsil eder. Burada pa[1] ifadesi bu matrisin ikinci satırını oluşturan 2 elemanlı int diziyi temsil 
	etmektedir. 

    >> Dizi isimler dizinin tamamını temsil etmektedir. Ancak C'de dizi isimleri ifade içerisinde kullanıldığında aslında dizinin ilk elemanının
    adresi anlamına gelmektedir. Dizi isimleri bu nedenle nesne belirtmez. Dizi isimleri C'de adeta bir sembolik sabit gibi düşünülmelidir.
    Örneğin:

        int a[3] = {1, 2, 3};

        a = 100;		/* a nesne belirtmiyor, bir adres sabiti belirtiyor */

	Bu durumda örneğin:

    	int a[3][2];

	burada a[i] ifadesi de *a ifadesi de nesne belirtmemektedir. Bu ifadeler adeta dizi isimleri gibi düşünülmelidir. 

    >> 	Biz C'de çok boyutlu dizilerin elemanlarına birden fazla [...]  ile erişiriz. Bunun neden böyle olduğu açıktır. Örneğin:

	    int a[3][2] = {{1, 2}, {3, 4}, {5, 6}};

	Burada a[i] aslında a matrisinin i'inci satırındaki diziyi belirtmektedir. O halde a[i][k] ifadesi de aslında a matrisinin i'inci
    satırındaki dizinin k'ıncı sütunundaki eleman anlamına gelmektedir. Aşağıda bu konuya ilişkin bir örnek verilmiştir: 
        * Örnek 1,
            #include <stdio.h>

            int main(void)
            {
                int a[3][2] = { {1, 2}, {3, 4}, {5, 6} };
                int(*pa)[2];

                pa = a;

                printf("%d\n", (*pa)[0]);
                printf("%d\n", (*pa)[1]);

                printf("%d\n", pa[1][0]);
                printf("%d\n", pa[1][1]);

                printf("%d\n", pa[2][0]);
                printf("%d\n", pa[2][1]);

                return 0;
            }

    >> Pekiyi bir matrisi fonksiyona partametre olarak nasıl geçirebiliriz? İşte fonksiyonun parametre değişkeninin bir dizi göstricisi olması 
	gerekir. Ayrıca yukarıda da belirtitğimiz gibi matrisin satır uzunluğunun da fonksiyona aktarılması uygun olur. Ne de olsa biz dizilerin 
	uzunluklarını da fonksiyona aktarmaktayız. Örneğin:

	    void foo(int (*pa)[2], size_t size);

	Bu fonksiyon sütun sayısı 2 olan ancak herhangi miktarda satıra sahip olan iki boyutlu diziler üzerinde işlem yapabilme potansiyelindedir.
        * Örnek 1,
            #include <stdio.h>

            void foo(int(*pa)[2], size_t size)
            {
                size_t i, k;

                for (i = 0; i < size; ++i) {
                    for (k = 0; k < 2; ++k)
                        printf("%d ", pa[i][k]);
                    printf("\n");
                }
            }

            int main(void)
            {
                int a[3][2] = { {1, 2}, {3, 4}, {5, 6} };

                foo(a, 3);

                return 0;
            }

    >> Çok boyutlu dizi kavramı aslında yapay bir kavramdır. Çünkü bellek çok boyutlu değildir tek boyutludur. Dolayısıyla çok boyutlu dizileri 
	derleyici aslında tek boyutlu dizilermiş gibi bellekte tutmaktadır. C standartları çok boyutlu dizilerin tüm elemanlarının ardışıl olduğunu 
	ve bu ardışıllığın satır tabanlı biçimde olduğunu belirtmektedir. Örneğin:

	    int a[3][2] = {
            {1, 2}, 
            {3, 4},
            {5, 6}
        };

	Buradaki a dizisi aslında iki elemanlı int dizilerin dizisi olduğuna göre elemanların bellekteki yerleşimi aşağıdaki olacaktır:

        1
        2
        3
        4
        5
        6

	Örneğin:

	    int a[2][2][3] = {
            {
                {1, 2, 3}, 
                {4, 5, 6}
            }, 
            {
                {7, 8, 9},
                {10, 11, 12}
            }
        };

	Bu dizinin bellekteki yerleşimi ise şöyle olacaktır:

        1
        2
        3
        4
        5
        6
        7
        8
        9
        10
        11
        12

	Bu durumda çok boyutlu bir dizinin ismi tek boyutlu bir göstericiye atanıp çok boyutlu dizinin bütün elemanlarına ulaşılabilir. 

    >> 	Tek boyutlu bir dizi de bir dizi göstericisine tür dönüştürme operatörü kullanılarak dönüştürülebilir. Bundan sonra dizi elemanlarına 
	matris sentaksıyla erişilebilir. 
        * Örnek 1,
            int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
            int (*pa)[3];

            pa = (int (*)[3]) a;

            for (int i = 0; i < 4; ++i) {
                for (int k = 0; k < 3; ++k)
                    printf("%d ", pa[i][k]);
                putchar('\n');
            }

        * Örnek 2, 
            #include <stdio.h>

            int main(void)
            {
                int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
                int (*pa)[3];

                pa = (int (*)[3]) a;

                for (int i = 0; i < 4; ++i) {
                    for (int k = 0; k < 3; ++k)
                        printf("%d ", pa[i][k]);
                    putchar('\n');
                }

                return 0;
            }

    >> 	Bir matiris için de dinamik tahsisatlar yapabiliriz. Tabii buradaki önemli nokta tahsis edilen alanın başlangıç adresinin atanacağı dizi
	göstericisinin nasıl tanımlanacağıdır. Örneğin biz 4x3'lik bir matris için malloc fonksiyonu ile tahsisat yapmak isteyelim. Bu durumda 
	tahsis edilen alanın adresi aşağıdaki gibi bir dizi göstericisine atanbilir:

	    int (*pa)[3];

	Örneğin:

        int(*pa)[3];

        if ((pa = (int(*)[3])malloc(4 * 3 * sizeof(int))) == NULL) {
            fprintf(stderr, "cannot allocate memory!..\n");
            exit(EXIT_FAILURE);
        }
    
    Aşağıda bu kullanıma ilişkin bir örnek verilmiştir:
        * Örnek 1,
            #include <stdio.h>
            #include <stdlib.h>

            int main(void)
            {
                int(*pa)[3];

                if ((pa = (int(*)[3])malloc(4 * 3 * sizeof(int))) == NULL) {
                    fprintf(stderr, "cannot allocate memory!..\n");
                    exit(EXIT_FAILURE);
                }

                for (int i = 0; i < 4; ++i) 
                    for (int k = 0; k < 3; ++k)
                        pa[i][k] = i + k;

                for (int i = 0; i < 4; ++i) {
                    for (int k = 0; k < 3; ++k)
                        printf("%d ", pa[i][k]);
                    putchar('\n');
                }

                free(pa);

                return 0;
            }

    >> Fonksiyon göstericileri konusunda da belirttiğimiz belli bir türden her uzunluktaki matrisi (çok boyutlu diziyi) parametre olarak alabilecek genel
    bir fonksiyon yazılamamaktadır. Bu tür genel fonksiyonları yazmanın en pratik yolu onları tek boyutluymuş gibi düşünmektir. Örneğin iki boyutlu
    int türden bir	matrisi parametre olarak alan bir fonksiyonun parametrik yapısı şöyle olabilir:

        void foo(int *pi, size_t rowsize, size_t colsize);

    Fonksiyon içerisinde bu matrisin i'inci satır k'ıncı sütun elemanlarına pi[i * colsize + k] ifadesiyle erişebiliriz. Aslında bu erişim doğal matris
    erişiminde daha yavaş değildir. Çünkü matrisler zaten doğal türler değildir. Yani bir matrisin elemanına a[i][k] biçiminde eriştiğimizde de zaten
    derleyici aynı işlemleri yapmaktadır. Tabii bu fonksiyonu çağırırken tür dönüştürmesi yapmak gerekir. Örneğin:

        int a[3][2] = { {1, 2}, {3, 4}, {5, 6} };
        ...
        foo(a, 3, 2);					/* geçersiz! */
        foo((int *)a, 3, 2);			/* geçerli

    Tabii tür dönüştürmesi yapılmak istenmiyorsa fonksiyonun parametresi void gösterici alınıp tür dönüştürmesi fonksiyonun içinde de yapılabilir.
    Örneğin:

        void foo(void *pv, size_t rowsize, size_t colsize)
        {
            int *pi = (int *)pv;
            ...
        }

    Artık tür dönüştürmesine gerek yoktur:

        foo(a, 3, 2);

    Aşağıda bu konuya ilişkin bir örnek verilmiştir: 
        * Örnek 1,
            #include <stdio.h>

            void disp_matrix(void *pv, size_t rowsize, size_t colsize)
            {
                int *pi = (int *)pv;
                
                for (size_t i = 0; i < rowsize; ++i) {
                    for (size_t k = 0; k < colsize; ++k)
                        printf("%d ", pi[i * colsize + k]);
                    putchar('\n');
                }
            }

            int main(void)
            {
                int a[3][2] = {{1, 2}, {3, 4}, {5, 6}};

                disp_matrix(a, 3, 2);

                return 0;
            }

    >> Her elemanı bir dizi göstericisi olan bir dizi de oluşturulabilir. Örneğin:

	    int (*a[10])[2];

	Burada a 10 elemanlı bir dizidir. Ancak bu dizinin her elemanı int (*)[2] türünden yani sütun uzunluğu 2 olan matrisleri gösteren dizi 
	göstericisidir. 

    >> Fonksiyonun parametre parantezi içerisinde çok boyutlu dizi sentaksı dizi göstericisi anlamına gelmektedir. Örneğin:

        void foo(int a[][3])
        {
            ...
        }

	Bu tanımlama tamamen aşağıdakiyle eşdeğerdir:

        void foo(int (*a)[3])
        {
            ...
        }

	Tabii dizisel gösterimde ikinci koşeli parantezin (çok boyutlu dizilerde ilki haricindeki tüm köşeli parantezlerin) içinde uzunluk belirten 
	bir sabit ifadesinin bulunuyor olması gerekir. Ancak ilk köşeli parantezin içi boş olabilir. İlk köşeli parantezin içine yazılacak 
	uzunluğun hiçbir önemi yoktur. Örneğin aşağıdaki prototipler tamamen eşdeğerdir:

        void foo(int a[][3]);
        void foo(int a[10][3]);
        void foo(int (*a)[3]);

    Aşağıda buna ilişkin bir örnek verilmiştir:
        * Örnek 1,
            void foo(int a[][5])			/* int (*a)[5] */
            {
                /* ... */
            }

            int main(void)
            {
                int a[5];

                foo(&a);

                return 0;
            }

    >> Fonksiyonların geri dönüş değerleri de dizi türünden adresler olabilir. Bu durumda dekleratörde yine * atomu paranteze içerisine alınır. 
	Parantezin soluna geri dönüş değerine ilişkin dizinin türü, sağında geri dönüş değerine ilişkin didizinin uzunluğu yazılır. Örneğin:

        int (*foo(int a))[3]
        {
            ...
        }

	Burada foo fonksiyonunun parametresi int türdendir. Ancak geri dönüş değeri 3 elemanlı bir dizinin adresidir. 
        * Örnek 1,
            #include <stdio.h>

            int(*foo(void))[5]
            {
                static int a[3] = {1, 2, 3, 4, 5};

                return &a;
            }

            int main(void)
            {
                int(*pa)[5];
                int i;

                pa = foo();
                for (i = 0; i < 5; ++i)
                    printf("%d ", (*pa)[i]);
                printf("\n");

                return 0;
            }