> "HANDLE" Sistemleri: "HANDLE" sözcüğü bir grup bilgiye erişmek için kullanılan, anahtar niteliğindeki tekil bilgiler 
anlamındadır. "HANDLE" kavramı karşımıza çeşitli formlarda çıkabilir. Örneğin, "int" türden değer olabilir, adres türünden 
olabilir vs. 
    * Örnek 1, Aşağıdaki "fd", kavramsal olarak bir "HANDLE" belirtmektedir. Çünkü bu "fd" değeri ile bizler bir grup bilgiye 
    ulaşabiliriz.  
        #include <stdio.h>
        #include <stdlib.h>
        #include <fcntl.h>

        int main(void)    
        {
            /* 
                # OUTPUT #
                open: No such file or directory
            */

            int fd;
            if((fd = open("test.dat", O_RDONLY)) == -1){
                perror("open");
                exit(EXIT_FAILURE);
            }
            
            puts("Ok");
            return 0;
        }

Diğer yandan bir "HANDLE" sisteminde üç tür fonksiyon bulunmaktadır. Bunlar "HANDLE" sistemini kuran fonksiyonlar,
"HANDLE" sistemini kullanan fonksiyonlar ve "HANDLE" sistemini yok eden fonksiyonlardır. 
    >> Kurucu Fonksiyonlar: Bu tip fonksiyonlar, "HANDLE" sistemi için alan tahsisi yaparlar. Bu alandaki değişkenlere 
    ilk değerini verirler ve "HANDLE" olarak kullanılacak değer ile geri dönerler. Örneğin, standart C fonksiyonu olan 
    "fopen" fonksiyonu böyle bir fonksiyondur. Bu kategorideki fonksiyon isimleri genellikle "create" veya "open" ön ekini
    içermektedir. 
    
    >> Kullanan Fonksiyonlar: "HANDLE" değerini argüman olarak alan ve tahsis edilmiş olan ilgili alandaki değerleri 
    kullanan fonksiyonlardır. Örneğin, standart C fonksiyonu olan "fgetc" fonksiyonu böyle bir fonksiyondur.   
    
    >> Yok Eden Fonksiyonlar: "HANDLE" değerini argüman olarak alarak tahsis edilmiş olan ilgili alanı tamamen yok eden 
    ve "HANDLE" sistemi kurulurken yapılan bir takım işlemleri de geri alan fonksiyonlardır. Örneğin, standart C fonksiyonu 
    olan "fclose" fonksiyonu böyle bir fonksiyondur. 

Aşağıda örnek kullanımlar verilmiştir:
    * Örnek 1, Aşağıdaki örnekte "HANDLE" sistemine bir örnek verilmiştir.
        #include <stdio.h>
        #include <stdlib.h>

        typedef struct tagMATRIX{
            size_t row_size;
            size_t col_size;
            int* matrix;
        }MATRIX, *HMATRIX;

        HMATRIX CreateMatrix(size_t row_size, size_t col_size);
        void SetElem(HMATRIX hMatrix, size_t row_index, size_t col_index, size_t value);
        int GetElem(HMATRIX hMatrix, size_t row_index, size_t col_index);
        void DispMatrix(HMATRIX hMatrix);
        void CloseMatrix(HMATRIX hMatrix);

        int main(void)    
        {
            /* 
                # OUTPUT #
                0 0 0
                0 1 2
                0 2 4
            */

            HMATRIX hMatrix;
            
            if((hMatrix = CreateMatrix(3,3)) == NULL){
                fprintf(stderr, "Cannot create a matrix!..\n");
                exit(EXIT_FAILURE);
            }
            
            for(int row = 0; row < 3; ++row)
                for(int col = 0; col < 3; ++col)
                    SetElem(hMatrix, row, col, row * col);
            
            DispMatrix(hMatrix);
            
            CloseMatrix(hMatrix);

            return 0;
        }

        HMATRIX CreateMatrix(size_t row_size, size_t col_size){
            HMATRIX hMatrix;
            
            if((hMatrix = (HMATRIX)malloc(sizeof(MATRIX))) == NULL)
                return NULL;
                
            hMatrix->row_size = row_size;
            hMatrix->col_size = col_size;
            if((hMatrix->matrix = (int*)malloc(sizeof(int) * row_size * col_size)) == NULL){
                free(hMatrix);
                return NULL;
            }
            
            return hMatrix;
        }

        void SetElem(HMATRIX hMatrix, size_t row_index, size_t col_index, size_t value)
        {
            size_t index = row_index * hMatrix->col_size + col_index;
            hMatrix->matrix[index] = value;
        }

        int GetElem(HMATRIX hMatrix, size_t row_index, size_t col_index)
        {
            size_t index = row_index * hMatrix->col_size + col_index;
            return hMatrix->matrix[index];
        }

        void DispMatrix(HMATRIX hMatrix)
        {
            // Version - I
            for(size_t i = 0; i < hMatrix->row_size * hMatrix->col_size; ++i){
                printf(
                    "%d%c", 
                    hMatrix->matrix[i], 
                    i % hMatrix->col_size == hMatrix->col_size - 1 ? '\n' : ' '
                );
            }
            
            /*
                // Version - II
                for(size_t row = 0; row < hMatrix->row_size; ++row){
                    for(size_t col = 0; col < hMatrix->col_size; ++col)
                        printf("%d ", hMatrix->matrix[row * hMatrix->col_size + col]);
                    
                    printf("\n");
                }
            */
        }

        void CloseMatrix(HMATRIX hMatrix)
        {
            free(hMatrix->matrix);
            free(hMatrix);
        }

    * Örnek 2, Aşağıdaki örnekte ise "HANDLE" değeri "void*" olarak belirtilmiş ve arka plandaki esas tür 
    gizlenmiştir.
        /* matrix.h */
            #ifndef MATRIX_H_
            #define MATRIX_H_

            #include <stdlib.h>

            /* Type Declarations */
            typedef void* HMATRIX;

            /* Function Prototypes */
            HMATRIX CreateMatrix(size_t row_size, size_t col_size);
            void SetElem(HMATRIX hMatrix, size_t row_index, size_t col_index, size_t value);
            int GetElem(HMATRIX hMatrix, size_t row_index, size_t col_index);
            void DispMatrix(HMATRIX hMatrix);
            void CloseMatrix(HMATRIX hMatrix);

            #endif

        /* matrix.c */
            #include "matrix.h"
            #include <stdio.h>

            /* Type Declarations */
            typedef struct tagMATRIX{
                size_t row_size;
                size_t col_size;
                int* matrix;
            }MATRIX;

            /* Function Definitons */
            HMATRIX CreateMatrix(size_t row_size, size_t col_size){
                MATRIX* matrix;
                
                if((matrix = (HMATRIX)malloc(sizeof(MATRIX))) == NULL)
                    return NULL;
                    
                matrix->row_size = row_size;
                matrix->col_size = col_size;
                if((matrix->matrix = (int*)malloc(sizeof(int) * row_size * col_size)) == NULL){
                    free(matrix);
                    return NULL;
                }
                
                return matrix;
            }

            void SetElem(HMATRIX hMatrix, size_t row_index, size_t col_index, size_t value)
            {
                MATRIX* matrix = (MATRIX*)hMatrix;
                size_t index = row_index * matrix->col_size + col_index;
                matrix->matrix[index] = value;
            }

            int GetElem(HMATRIX hMatrix, size_t row_index, size_t col_index)
            {
                MATRIX* matrix = (MATRIX*)hMatrix;
                size_t index = row_index * matrix->col_size + col_index;
                return matrix->matrix[index];
            }

            void DispMatrix(HMATRIX hMatrix)
            {
                MATRIX* matrix = (MATRIX*)hMatrix;
                
                // Version - I
                for(size_t i = 0; i < matrix->row_size * matrix->col_size; ++i){
                    printf(
                        "%d%c", 
                        matrix->matrix[i], 
                        i % matrix->col_size == matrix->col_size - 1 ? '\n' : ' '
                    );
                }
                
                /*
                // Version - II
                for(size_t row = 0; row < matrix->row_size; ++row){
                    for(size_t col = 0; col < matrix->col_size; ++col)
                        printf("%d ", matrix->matrix[row * matrix->col_size + col]);
                    
                    printf("\n");
                }
                */
            }

            void CloseMatrix(HMATRIX hMatrix)
            {
                MATRIX* matrix = (MATRIX*)hMatrix;
                
                free(matrix->matrix);
                free(matrix);
            }

        /* main.c */
            #include <stdio.h>
            #include "matrix.h"

            int main(void)    
            {
                /* 
                    # OUTPUT #
                    0 0 0
                    0 1 2
                    0 2 4
                */

                HMATRIX hMatrix;
                
                if((hMatrix = CreateMatrix(3,3)) == NULL){
                    fprintf(stderr, "Cannot create a matrix!..\n");
                    exit(EXIT_FAILURE);
                }
                
                for(int row = 0; row < 3; ++row)
                    for(int col = 0; col < 3; ++col)
                        SetElem(hMatrix, row, col, row * col);
                
                DispMatrix(hMatrix);
                
                CloseMatrix(hMatrix);

                return 0;
            }

Öte yandan Macar Notasyonunda "H" öneki almış olan bütün "typedef" isimler bir "HANDLE" belirtmektedir ve Windows API sisteminde arka
planda "void*" türüne açılmaktadır. Burada "void*" kullanılma sebebi ise esas gerçek türün programcıdan gizlenmek istenmesidir.  